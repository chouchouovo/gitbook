{"COPYRIGHT.html":{"url":"COPYRIGHT.html","title":"版权","keywords":"","body":"版权 http://creativecommons.org/licenses/by-nc-sa/4.0/ 《C! 前端》由 chouchou 编写，采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。 本人保留所有权限，保留出版权限，未经本人书面许可任何人不得用于商业出版。 支付宝捐赠请扫码. Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-09-05 17:04:20 "},"./":{"url":"./","title":"序言","keywords":"","body":"序言 《C! 前端》系列篇： 《C! 前端 -- HTML 篇》 《C! 前端 -- CSS 篇》 《C! 前端 -- ECMASCript 篇》 《C! 前端 -- 计算机网络篇》 《C! 前端 -- 数据操作 篇》 《C! 前端 -- 正则 篇》 《C! 前端 -- 安全 篇》 《C! 前端 -- Vue 篇》 《C! 前端 -- React 篇》 《C! 前端 -- 动画 篇》 《C! 前端 -- node 篇》 《C! 前端 -- 架构 篇》 《C! 前端 -- 现代 Web 技术发展》 《C! 前端 -- 3D 篇》 本书讲解的是《C! 前端 -- CSS 篇》，如何构建 CSS 知识体系 主要内容： [x] 版权 [x] 序言 [x] CSS 2.2 中文版 [x] 1 关于 CSS 2.2 规范 [x] 2 CSS 2.2 简介 [x] 3 一致性：要求和建议 [x] 4 语法和基本数据类型 [x] 5 选择器 [x] 6 分配属性值、层叠、继承 [x] 7 媒体类型 [x] 8 盒子模型 [x] 9 视觉格式化模型 [x] 10 视觉格式化模型细节 [x] 11 视觉效果 [x] 12 生成内容，自动编号，列表 [x] 13 分页媒体 [x] 14 颜色和背景 [x] 15 字体 [x] 16 文本 [x] 17 表格 [x] 18 用户界面 [ ] CSS 模块和标准化演进 [ ] CSS 模块 [ ] 推荐 [ ] 候选推荐 [ ] 建议推荐 [ ] 草案 [ ] CSS 社区 [ ] 预处理语言 [ ] Less [ ] Sass [ ] Scss [ ] Stylus [ ] CSS 解析工具 PostCSS [ ] CSS 命名设计模式 [ ] CSS 使用规范 [ ] CSS 库 [ ] CSS 与现代 Web 技术的实践 [ ] 参考资料 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-11-18 17:10:33 "},"docs/CSS/CSS2.2/":{"url":"docs/CSS/CSS2.2/","title":"CSS 2.2 中文版","keywords":"","body":"参考资料 https://www.w3.org/TR/CSS22/ Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-11-18 16:09:13 "},"docs/CSS/CSS2.2/1 关于 CSS 2.2 规范.html":{"url":"docs/CSS/CSS2.2/1 关于 CSS 2.2 规范.html","title":"1 关于 CSS 2.2 规范","keywords":"","body":"1 关于 CSS 2.2 规范 1.1 CSS 2.2 与 CSS 2 CSS 社区自 1998 年成为推荐（规范）以来，从 CSS 2 中获得了丰富的经验。虽然 CSS 2 规范中的错误在 2011 年的第一个修订版[CSS 21]得到了修正，但有新的勘误表是有必要的。 虽然很多问题可以通过接下来的 CSS 3 规范解决，但目前的状况阻碍了 CSS 2 的实现与互通性。CSS 2.2 规范试图通过以下方式解决这种情况： 保持 CSS 2 中那些已经被广泛接受和实现的部分的兼容性。 合并所有已发布的 CSS 2 勘误表。 如果实现与 CSS 2 规范完全不同，则将规范修改为符合普遍接受的做法。 移除 CSS 2 中那些因为没有被实现而被 CSS 社区拒绝的特性，CSS 2.2 旨在反映那些在HTML 和 XML 语言中被广泛实现的合理特性（不单单是对XML语言，或者HTML）。 移除将被 CSS 3 废弃的 CSS 2 功能，因此鼓励采用 CSS 3 所提出的 功能。 当实现经验表明 CSS 2 需要实现（新特性）时，添加（非常）少量的新属性值。 因此，虽然 CSS 2 样式表不一定与 CSS 2.2 保持向前兼容，但是符合 CSS 2.2 规范的样式更可能兼容现有用户代理，并在将来保持向前兼容。虽然不希望破坏兼容性，但我们认为 CSS 2.2 中修订版本的优点是值得的。 CSS 2.2 源于 CSS 2.1 和 CSS 2，并旨在替代它们。在 CSS 2.2 中，CSS 2的一部分保留一部分删除一部分更改，删除的部分可以用于将来的 CSS 2.2。将来的新规范应该参考 CSS 2.2（除非他们需要 CSS 2 中那些已经在 CSS 2.2 被移除的特性，然后应该仅参考 CSS 2 的这些特性，或者优先参考包含这些特性的 CSS 3 模块）。 1.2 本规范的阅读 这部分非规范。 本规范同时考虑了两种类型的读者：CSS 作者和 CSS 实现者。我们希望该规范将为作者提供编写高效、有吸引力、可访问的文档，不把 CSS 实现的细节告诉他们。而实现者，应该从中寻找构建 符合标准的用户代理 所需的所有内容。规范开篇是 CSS 的一般描述，然后越来越技术和具体。为了快速获取信息，电子版和打印版每章开头都有速查表和内容详情表，以及索引导航。 本规范编写时考虑了两种表现形式：电子版和打印版。虽然这两种形式无疑是相似的，但读者仍会发现一些区别。比如，打印版中链接将失效，并且电子版没有页码。如果存在差异，电子版是文档的权威版本。 1.3 本规范如何组织 这部分非规范。 本规范的章节组织如下： 第 2 章 CSS 2.2 简介：简介包括 CSS 2.2 的简单教程和对 CSS 2.2 中背后的设计原则的讨论。 第 3 - 18 章：CSS 2.2 参考手册：参考手册主要由 CSS 2.2 语言组成，本参考定义了CSS 2.2 样式表中会出现的东西（语法，属性，属性值），以及用户代理该怎样解释这些样式表才能保证一致性 附录：附录包含有关听觉属性（非规范）的信息，HTML 4 的样本样式表，CSS 2.1 的更改，CSS 2.2的语法，规范和信息引用的列表，以及两个索引：一个用于属性，一个用于一般索引。 1.4 约定 1.4.1 文档语言元素和属性（Document language elements and attributes） CSS 属性(原：property)和伪类使用 单引号 CSS 值使用 单引号 文档语言属性(原：attribute)使用小写字母，并用 双引号 1.4.2 CSS 属性定义 CSS 属性的关键信息摘要： Name：属性名称（property-name） Value：合法值和语法 Initial：初始值 Applies to：该属性的适用元素 Inherited：该属性是否继承 Percentages：如何解析百分比值 Media：该属性适用于哪些媒体设备 Computed value：如何计算 计算值（Computed value） 1.4.2.1 值 此部分指定名称为 “property-name” 的属性的合法值集合。属性值可以包含一个或多个组成部分。组成部分值类型以多种方式指定： 关键字值（比如，auto，disc 等等）。 基本数据类型，出现在 “”之间（比如， 和 等等）。 有相同范围的值类型，与属性名相同（比如，、等等）。这种情况下，出现在 “” 之间的类型名就是属性名（比如，），这样的类型不包括 inherit 值。在电子版文档中，每个该类型的实例的非终结符都链接到相应的值定义。 非终结符不会出现同名属性。在这种情况下，非终结符出现在 “” 之间，如。注意 和 之间的区别：后者是根据前者定义的。非终结符位于它在规范中的首次出现的地方。在文档的电子版本中，此类值的每个实例都链接到相应的值定义。 其它的定义的词语以 字面量 形式出现的关键字，没有引号（比如，red）。斜杠（/）和逗号（，）也按字面意思显示。 组成部分的值可以按如下方式排列到属性值中： 几个并列的单词，表示它们必须以给定的顺序全部出现 单竖线(|)分隔两个或者更多可选值：其中必须出现且仅出现一个 双竖线(||)分隔的两个或者更多项：必须出现一个或者多个，顺序随意 双 & 号(&&)分隔的两个或更多部分：必须全部出现，顺序随意 方括号([ ])用来分组 并列比 双 & 号优先级高，双 & 号比双竖线优先级高，双竖线比单竖线优先级高。因此，以下写法是等价的： a b | c || d && e f [ a b ] | [ c || [ d && [ e f ]]] 每个类型，关键字，或者方括号分组都可以跟随以下修饰符之一： 星号（*）表示前面的类型，单词或组出现零次或多次 加号（+）表示前面的类型，单词或组出现零次或多次 问号（?）表示前面的类型，单词或组出现可有可无 花括号中的一对数字（{A, B}）表示前面的类型，，单词或组出现至少出现 A 次 或 B 次。 下面的示例描述了不同的值类型： Value: N | NW | NE Value: [ | thick | thin ]{1,4} Value: [ , ]* Value: ? [ / ]? Value: || Value: inset? && [ {2,4} && ? ] 组成部分的值是根据附录 G.2中的 token 指定的。由于语法允许 expr 生成的组成部分中的 token 之间的空格，因此属性值中的 token 之间可能出现空格。 注意：大多数情况下，使用 空格 区分 token。比如，值 '1em2em' 将被解析为一个带有数字 '1' 和标识符 'em2em'（不是有效单位）的 DIMEN。在这种情况下，在 '2' 之前需要一个空格来将其解析为两个长度 '1em' 和 '2em'。 1.4.2.2 初始值 这部分指定属性的初始值。有关样式表的 指定（值）、继承值、初始值之间的作用，请看 层叠 部分。 1.4.2.3 适用 这部分指定属性适用的元素。任何元素都拥有所有属性，但一些属性对某些元素没有渲染效果，比如，clear 属性只对块级元素起作用。 1.4.2.4 继承 这部分指定属性的值是否继承于祖先元素。有关样式表的 指定（值）、继承值、初始值之间的作用，请看 层叠 部分。 1.4.2.5 百分比 这部分指定属性值如何是百分比的话，应该如何计算。如果出现的是 “N/A”，则表明不支持百分比。 1.4.2.6 媒体类型 这部分指定属性适用的媒体组（类型）。关于媒体组（类型）的信息不是规范的。 1.4.2.7 计算值 这部分指定属性的计算值。关于计算值如何定义的，见 计算值 这一节。 1.4.3 简写属性 某些属性是简写属性，这意味着它们允许作者可以使用单个属性指定多个属性值。 比如，font 属性是可以一次性设置 font-size、font-variant、font-weight、font-size、line-height、font-family 的简写属性。 当简写属性中某些值被省略时，会为每个 省略值 分配其 初始值（见 层叠 部分）。 示例： h1 { font-weight: bold; font-size: 12pt; line-height: 14pt; font-family: Helvetica; font-variant: normal; font-style: normal; } 可以重写为： h1 { font: bold 12pt/14pt Helvetica } 1.4.4 注意事项和示例 所有说明不合法使用的示例都会标记 “ILLEGAL EXAMPLE”。 缺少 DOCTYPE 声明的 HTML 示例是符合 HTML 4.01 Strict DTD HTML4，其它示例与示例给出的 DTD 一致。 所有注意事项都只是一些参考。 规范中的示例和注意事项都会在 HTML 源码中标记出来 1.4.5 图片与长描述 本规范大部分图片都含有 “长描述信息”，“长描述信息” 由 “此图长描述” 来表示。 1.5 致谢 这部分非规范。 CSS 2.2 基于 CSS 2.2 和 CSS 2。对 CSS 2 和 CSS 2.1 贡献的人员见 CSS 2 的致谢部分和CSS 2.1 的致谢部分。 我们感谢以下人员，通过 www-style 邮件的反馈，帮助我们创建了这个规范：TBD。 此外，我们还要特别感谢 TBD。 非常感谢以下人员对测试套件的帮助：TBD ...以及 CSS 1 测试套件的所有贡献者。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/2 CSS 2.2 简介.html":{"url":"docs/CSS/CSS2.2/2 CSS 2.2 简介.html","title":"2 CSS 2.2 简介","keywords":"","body":"2 CSS 2.2 简介 2.1 CSS 2.2 的 HTML 简明教程 这部分非规范。 在本教程中，我们展示设计简单样式表是多么容易。在本教程中，您需要了解一些 HTML（见 HTML4）和一些基本桌面排版术语。 我们从一段简短的 HTML 开始： Bach's home page Bach's home page Johann Sebastian Bach was a prolific composer. 设置 H1 元素的文本为红色： h1 { color: red } 一条 CSS 规则由两个主要组成部分组成：选择器（'h1'）和声明（'color: red'）。在 HTML 中，元素名称不区分大小写，因此 h1 与 H1 一样有效。声明有两部分：属性名称（'color'）和属性值（'red'）。虽然上面的示例试图仅影响呈现 HTML 文档所需的一个属性，但它本身就可以作为样式表。结合其他样式表（CSS 的一个基本特征是样式表被组合），规则将确定文档的最终呈现。 HTML 4 规范定义了如何为 HTML 文档指定样式表规则：在 HTML 文档中，或通过外部样式表。要将样式表放入文档，请使用 STYLE 元素： Bach's home page h1 { color: red } Bach's home page Johann Sebastian Bach was a prolific composer. 为了更大的灵活性，我们建议作者指定外部样式表; 它们可以在不修改源 HTML 文档的情况下进行更改，并且可以在多个文档之间共享。要链接到外部样式表，您可以使用 LINK 元素： Bach's home page Bach's home page Johann Sebastian Bach was a prolific composer. LINK 元素指定： link 的类型：stylesheet href 属性指定样式表的位置 link 的样式表类型：text/css 为了展示样式表与结构化标签的密切联系，我们在教程中继续使用 STYLE 元素，来添加更多颜色： Bach's home page body { color: black; background: white } h1 { color: red; background: white } Bach's home page Johann Sebastian Bach was a prolific composer. 样式表现在有四个规则：前两个设置 BODY 元素的颜色和背景（最好将文本颜色和背景颜色设置在一起），而后两个设置 H1 元素的颜色和背景。 由于没有为 P 元素指定颜色，因此它将从其父元素（即 BODY）继承颜色。 H1 元素也是 BODY 的子元素，但第二个规则会覆盖继承的值。 在 CSS 中，不同值之间经常存在此类冲突，本规范描述了如何解决它们。 CSS 2.2 有超过 90个 属性，包括 color。 让我们看看其他一些： Bach's home page body { font-family: \"Gill Sans\", sans-serif; font-size: 12pt; margin: 3em; } Bach's home page Johann Sebastian Bach was a prolific composer. 首先要注意的是，几个声明被分组，然后由大括号（{...}）括起来的块中，并用分号分隔，尽管最后一个声明后面也可能跟一个分号。 BODY 元素的第一个声明将字体系列设置为 “Gill Sans”。如果该字体不可用，则用户代理（通常称为 “浏览器”）将使用 “sans-serif” 字体系列，该字体系列是所有用户代理知道的五个通用字体系列之一。 BODY 的子元素将继承 font-family 属性的值。 第二个声明将 BODY 元素的字体大小设置为 12pt。 “点” 单元通常用于基于打印的排版，以指示字体大小和其他长度值。这是绝对单位的一个例子，它不会相对于环境进行缩放。 第三个声明使用一个相对单位，它相对于周围环境进行缩放。 “em” 单位指的是元素的字体大小。在这种情况下，结果是 BODY 元素周围的外边距是字体大小的三倍。 2.2 CSS 2.2 的 XML 简明教程 这部分非规范。 CSS 可以与任何结构化文档格式一起使用，比如使用可扩展标记语言[XML11]的应用程序。 事实上，XML 更多地依赖样式表而不是 HTML，因为作者可以创作他们自己的元素，用户代理不知道如何显示（这些）。 这是一个简短的 XML 片段： Fredrick the Great meets Bach Johann Nikolaus Forkel One evening, just as he was getting his flute ready and his musicians were assembled, an officer brought him a list of the strangers who had arrived. 为了以类似文档的方式显示这个片段，我们必须首先声明哪些元素是行内级别的（即，不引起换行符），哪些元素是块级的（即导致换行符）。 INSTRUMENT { display: inline } ARTICLE, HEADLINE, AUTHOR, PARA { display: block } 第一个规则声明 INSTRUMENT 是行内的，第二个规则用逗号分隔的选择器列表声明所有其他元素是块级的。XML 中的元素名称区分大小写，因此以小写形式（比如，“instrument”）编写的选择器与大写（比如，“INSTRUMENT”）不同。 将样式表链接到 XML 文档的一种方法是使用处理指令： Fredrick the Great meets Bach Johann Nikolaus Forkel One evening, just as he was getting his flute ready and his musicians were assembled, an officer brought him a list of the strangers who had arrived. 一个可视化用户代理能够把上面的示例格式化为： 此图长描述 请注意，“flute” 一词仍在段落中，因为它是行内元素 INSTRUMENT 的内容。 尽管如此，文本的格式仍然没有您期望的那样。比如，标题字体大小应该大于文本的其余部分，并且您可能希望以斜体显示作者的名称： INSTRUMENT { display: inline } ARTICLE, HEADLINE, AUTHOR, PARA { display: block } HEADLINE { font-size: 1.3em } AUTHOR { font-style: italic } ARTICLE, HEADLINE, AUTHOR, PARA { margin: 0.5em } 一个可视化用户代理能够把上面的示例格式化为： 此图描述 在样式表中添加更多规则将允许您进一步描述文档的表现。 2.3 CSS 2.2 的处理模型 这部分（除了小节）非规范。 本节介绍了一种支持 CSS 的用户代理如何工作的可能模型。这只是一个概念模型，实际实施可能会有所不同。 在此模型中，用户代理通过执行以下步骤来处理源（文档）： 解析源文档并创建文档树。 确定目标媒体类型。 检索与为目标媒体类型指定的文档相关联的所有样式表。 通过为适用于目标媒体类型的每个属性分配值来标注文档树的每个元素。根据 层叠和继承 一节中描述的机制为属性分配值。 值的计算的一部分取决于适用于目标媒体类型的格式化算法。比如，如果目标媒体是屏幕，则用户代理使用视觉格式化模型。 从有标注的文档树中，生成格式化结构。通常，格式化结构与文档树结构相似，但也可能有很大不同，特别是作者使用伪元素和生成内容时。首先，格式化结构可以不需要时 “树形的”-结构的性质取决于实现。其次，格式化结构可以包含比文档树更多或更少的信息。比如，如果文档树中的元素有 display: none，则元素不会在该格式化结构中生成任何内容。另一方面列表元素可以生成更多信息：列表元素的内容和列表样式信息（比如，▪️）。 注意：CSS 用户代理在此阶段不会改变文档树。特别是，由于样式表产生的内容不会反馈给文档语言处理器（比如，重新解析） 将格式化结构传送给目标媒体（比如，打印结果，在屏幕上显示它们，将它们呈现为语音等）。 2.3.1 canvas 对于所有媒体，术语 canvas 描述 “呈现格式化结构的空间”。画布对于空间的每个维度是无限的，但是渲染通常发生在画布的有限区域内，（该区域）由用户代理根据目标介质建立。比如，呈现给屏幕的用户代理通常施加最小宽度并基于视口的尺寸选择初始宽度。呈现给页面的用户代理通常会施加宽度和高度约束。听觉用户代理可能会对音频空间施加限制，但并不及时。 2.3.2 CSS 2.2 的元素查找模型 CSS 2.2 选择器和属性允许样式表引用文档或用户代理的以下部分： 文档树中的元素以及它们之间的某些关系（见 选择器 部分）。 文档树中元素的属性以及这些属性的值（见 属性选择器部分）。 元素内容的某些部分（见 :first-line和 :first-letter 伪元素）。 文档树处于特定状态时的元素（见 伪类 部分）。 canvas 用来渲染文档的某些部分。 一些系统信息（见 用户界面部分）。 2.4 CSS 设计原则 这部分非规范。 在 CSS 2 和 CSS 1 之前的 CSS 2.2，基于以下设计原则： 向前向后兼容：CSS 2.2 用户代理将能够理解 CSS1 样式表。 CSS1 用户代理将能够读取CSS 2.2 样式表并丢弃他们不理解的部分。此外，没有 CSS 支持的用户代理将能够显示样式增强的文档。当然，通过 CSS 实现的样式增强将不会被渲染，但会呈现所有内容。 对结构化文档的补充：样式表补充了结构化文档（比如，HTML 和 XML 应用程序），为标记文本提供样式信息。在对标记（文本）产生较少或者零影响的前提下，它应该能够轻易改变样式。 供应商，平台和设备的独立性：样式表使文档能够独立于供应商，平台和设备。 样式表本身也与供应商和平台无关，但 CSS 2.2 允许您为一组设备（比如，打印机）设定样式表。 可维护性：通过从文档中指向样式表，网站管理员可以简化站点维护并在整个站点中保持一致的外观。比如，如果组织的背景颜色发生更改，则只需更改一个文件。 简洁：CSS 是一种简单的样式语言，有很好的可读可写性。CSS 属性在最大程度上保持彼此独立，并且通常只有一种方法可以实现某种效果。 网络性能：CSS 提供了如何呈现内容的简洁编码。与 作者经常用于实现某些特定渲染效果的图像或音频文件 相比，样式表通常会减小内容大小。此外，必须打开更少的网络连接，这进一步提高了网络性能。 灵活性：CSS 可以通过多种方式应用于内容。关键功能是能够层叠 默认（用户代理）样式表，用户样式表，链接样式表，文档头以及构成文档正文的元素的属性中指定的样式信息。 丰富性：为作者提供丰富的渲染效果可以增加 Web 作为表达媒介的丰富性。设计人员一直渴望桌面出版和幻灯片应用程序中常见的功能。虽然一些需要的渲染效果与设备独立性有冲突，但 对设计者，CSS 2.2 给予了充分的空间设计。 可选的语言绑定：本规范中描述的 CSS 属性集形成了视觉和听觉呈现的一致格式化模型。可以通过 CSS 语言访问此格式化模型，但也可以绑定到其他语言。比如，JavaScript 程序可以动态地更改某个元素的 “颜色” 属性的值。 可访问性：一些 CSS 功能将使障碍用户更容易访问 Web 控制字体外观的属性，允许作者消除难以访问的位图文本图像 定位属性允许作者消除标记技巧（比如，不可见图像）以用于实现布局效果。 !important 规则的语义意味着具有特定表现要求的用户可以覆盖作者的样式表。 所有属性的 “继承” 值可提高层叠通用性，并允许调整统一风格。 增强媒体支持，包括媒体组和盲文，浮雕和 tty 等媒体类型。允许用户和作者为这些设备定制页面。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/3 一致性：要求和建议.html":{"url":"docs/CSS/CSS2.2/3 一致性：要求和建议.html","title":"3 一致性：要求和建议","keywords":"","body":"3 一致性：要求和建议 3.1 定义 本文档中的关键词 \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", 和 \"OPTIONAL\" 都按照 RFC2119（见RFC2119）中描述的来解释。但是，为了便于阅读，这些词在本说明书中并未以全部大写字母出现。 有时，本规范会为作者和用户代理建议好的实践。这些建议是非规范性的，与本规范的一致性取决于实现。这些建议包括 \"我们建议\"、\"本规范建议\" 或者类似的措辞。 功能被标记为已弃用（如 aural 关键字），或将在 CSS3 中弃用（如 system colors）事实上都不会影响一致性（aural 关键字是非规范的，所以 UA 不需要支持它；system colors 是规范的，所以 UA 必须支持它）。 除注意事项说明的部分外，本规范的所有章节包括附录都是规范的。 示例和注意事项都是非规范的。 示例的开头一般都有 \"比如\" 之类的词语（\"示例：\"、\"下例\"、\"比如\"等等） 注意事项以 \"注意\" 两字开头 图表仅提供说明，不是参考效果图，除非有明确说明 样式表（原：Style sheet） 一组指定文档呈现的语句 样式表可能有 3 个不同的来源：作者、用户和用户代理。这些来源之间的相互作用请查看层叠和继承 合法样式表（原：Valid style sheet） 样式表的合法性取决于样式表使用的 CSS 级别。所有有效的 CSS 1 样式表都是有效的 CSS 2.2 样式表，但 CSS 1 的一些变化意味着 一些 CSS 1 样式表在 CSS 2.2 中的语义略有不同。CSS 2 中的某些功能不是 CSS 2.2 的一部分，因此并非所有 CSS 2 样式表都是有效的 CSS 2.2 样式表。 合法的 CSS 2.2 样式表必须根据 CSS 2.2 的语法编写。此外，它必须仅包含本规范定义的 @规则、属性名称和属性值。任何不合法的@规则、属性名称和属性值无效。 源文档（原：Source document） 应用了一个或多个样式表规则的文档。这是以某种语言编码的，该语言以元素树表示文档。每个元素由一个标识元素类型的名称、多个可选的属性（原：attributes）、一个可能为空的内容组成。比如源文档可以是 XML 或 SGML 实例 文档语言（原：Document language） 源文档的编码语言（比如：HTML、XHTML 或 SVG）。CSS 用来描述文档语言的呈现（形式），而不会改变文档语言的底层语义。 元素（原：Element） （一个 SGML 的术语，见ISO8879）。文档语言的主要语法结构，大多数 CSS 样式表规则都通过元素名称（比如，HTML 中的 、、）来指定该元素应该怎样渲染 替换元素（原：Replaced element） 内容（原：content）超出 CSS 格式化模型范围的元素，如图片、内嵌文档、applet。比如，HTML 中的 元素的内容常常被其 src 属性指定的图片替换。替换元素通常具有固有尺寸：固有宽度、固有高度和固有比率。比如，位图图片有绝对单位指定的固有宽度、固有高度（显然可以确定固有比率）。另一方面，其它文档可能没有固有尺寸（比如，空白 HTML 文档） 用户代理如果觉得这些尺寸可能会泄漏敏感信息给第三方的话，可以认为一个替换元素没有任何固有尺寸。比如，如果一份 HTML 文档是根据用户的银行余额改变固有尺寸，则 UA 可能需要假装这个资源没有固有尺寸。 CSS 的渲染模型不会考虑替换元素的内容 固有尺寸（原：Intrinsic dimensions） 由元素自身定义的宽度和高度，不受环境影响。CSS 不定义如何拿到这些固有尺寸。CSS 2.2 中，只有替换元素有固有尺寸。对于没有可靠分辨率信息的光栅图像，假设每个图像源像素的单位为 1 像素单位。 属性（原：Attribute） 与元素关联的值，由名称和关联（文本）值组成。 内容（原：Content） 与文档中的元素关联的内容。有些元素没有内容，在这种情况下称它为空（元素）。元素的内容可以包括文本，并且可以包括多个子元素，在这种情况下，该元素被称为那些子元素的额父元素。 忽略（原：Ignore） 本规范中该术语有两个略微差异的含义。 第一个，CSS 解析器在样式表中发现未知或不合法语法时必须遵循某些规则。然后就是解析器必须忽略样式表的某些部分。哪些部分应该被忽略的规则在（声明与属性，处理解析错误的规则，不支持的值）小节中有详细描述。 第二个，即使语法合法，用户代理也可能（并且在某些情况下必须）忽略样式表中的某些属性或值。 呈现内容（原：Rendered content） 根据相关样式表应用于渲染后元素的内容。此规范未定义如何渲染替换元素的内容。呈现的内容可以是元素的替代文本（比如，XHTML 的 alt 属性），还可能包含通过样式表隐式或显示插入的项目（符号），比如黑点、数字等。 文档树（原：Document tree） 源文档中编码的元素树。此树中的每个元素只有一个父元素，除根元素外。 子（元素）（原：Child） 当且仅当 B 是 A 的父元素时，元素 A 才被称为是 元素 B 的子元素 后代（元素）（原：Descendant） 如果 A 是 B 的子元素，或者 A 是 B 的其它后代元素 C 的子元素，那么 A 被称为是 元素 B 的后代 祖先（元素）（原：Ancestor） 当且仅当 B 是 A 的后代时，元素 A 才是元素 B 的 祖先 兄弟（原：Sibling） 当且仅当 B 和 A 共享相同的父元素时，元素 A 才是 元素 B 的兄弟。如果元素 A 位于文档树中的 B 之前，则 A 是前导兄弟。如果 元素 B 位于文档树中的 A 之后，则 B 是后继兄弟 前导元素（原：Preceding element） 当且仅当 元素 A 是 B 的祖先，或者 B 是 A 的前导兄弟，A 是 B 的前导元素 后继元素（原：Following element） 当且仅当元素 B 是 A 的前导元素时，A 是 B 的后继元素 作者（原：Author） 作者是编写文档和相关样式表的人。编辑工具是一种用来生成样式表的用户代理 用户（原：User） 用户是与用户代理交互，以查看、听或其它方式使用文档与相关样式表的人。用户可能提供一份个人样式表作为个人偏好 用户代理（UA）（原：User agent (UA)） 用户代理可以是任何程序，该程序能够解释用文档语言编写的文档，并根据本规范的条款应用相关的样式表。 用户代理可以显示文档、大声朗读文档、打印出来、甚至转换为其它各种格式等 属性（原：Property） CSS 定义了一个有限的参数集，称为属性，用于指导文档的呈现。每个属性都有一个名称（比如：color、font 或 border）和一个值（比如：red、12px、dotted）。文档的各个部分，以及文档将通过特殊性、层叠和继承（见：分配属性值、级联、继承 章节）机制的方式把属性附加其中 一个 HTML 源文档示例： My home page My home page Welcome to my home page! Let me tell you about my favorite composers: Elvis Costello Johannes Brahms Georges Brassens 生成的树如下： 此图长描述 根据 HTML4 定义，HEAD 元素将在解析期间被推断出来并作为文档树的一部分，即便源文档里没有出现 \"head\" 标签。类似的，即便源文档中没有 和 标签，解析器也知道 P 和 LI 元素结束的位置。 XHTML（和其它基于 XML 的语言）文档行为不同：没有元素推断，并且所有元素都要有结束标签。 3.2 UA 一致性 本节只定义和 CSS 2.2 规范的一致性。将来还会有其它 CSS 级别，为了保持一致，可能需要用户代理实现不同的特性集。 一般情况，用户代理必须遵守以下几点一致性规范： 必须识别一个或多个 CSS 2.2 媒体类型 对于每个源文档，必须试图检索 适用于已识别媒体类型 的所有相关样式表。如果无法获取所有相关样式表（比如，因为网络错误），必须用那些可以检索的（样式表）显示文档 必须根据本规范解析样式表，特别是，必须识别所有@规则、块、声明和选择器（见 CSS 2.2语法 ）。如果用户代理遇到一个 适用于支持的媒体类型的属性，用户代理必须根据属性定义解析其值。这意味着，用户代理必须接受所有合法值并且必须忽略含有非法值的声明。用户代理必须忽略适用于不支持的媒体类型的规则 对于文档树中的每个元素，它必须根据属性定义和层叠与继承规则给每个属性赋值 如果源文档有可选的样式表集（比如，有 HTML4[HTML4]的 \"alternate\" 关键字），UA 必须允许用户选择 UA 应该适用哪份样式表集 UA 必须允许用户去掉作者（提供的）样式表的影响 不是所有用户代理都必须遵守每一点，然而： 读取样式表但不渲染任何内容的应用程序（比如，CSS 2.2 校验工具）必须遵守 1-3 点 编辑工具只需要输出合法的样式表 渲染具有相关联样式表的文档的用户代理必须遵守 1-6 点，并根据本规范中阐述的媒体特定要求呈现文档。必要时，用户代理可以用近似值 由于特定设备（比如，用户代理无法在单色监视器或页面上渲染颜色）的限制，用户代理无法实现本规范的一部分并不意味着不一致。 UA 必须允许用户指定含有用户样式表的文件。UA 面向的设备无任何写入或指定文件的方式时可以免除此要求。此外，UA 可以提供其它方式来指定用户偏好，比如通过 GUI CSS 2.2 没有定义哪些属性适用于表单控件和框架，以及怎样用 CSS 给它们设置样式。用户代理可能会给这些元素适用 CSS 属性，建议作者把此类支持当做实验性的，CSS 后续版本可能会进一步指定这些 3.3 错误条件 一般情况，本文档通过规范说明了错误处理行为。比如，见处理解析错误的规则 3.4 text/css 内容类型 独立文件中的 CSS 样式表会通过网络作为结合编码信息的字节序列来发送。传输的结构，术语叫消息实体，是在 RFC 2045 和 RFC 2616（见 [RFC2045] 和 [RFC2616] ）中定义的。一个内容类型为 \"text/css\" 的消息实体表示一个独立的 CSS 文档，\"text/css\" 内容类型是在 RFC 2318（[RFC2318]）中提出的 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-11-18 16:08:01 "},"docs/CSS/CSS2.2/4 语法和基本数据类型.html":{"url":"docs/CSS/CSS2.2/4 语法和基本数据类型.html","title":"4 语法和基本数据类型","keywords":"","body":"4 语法和基本数据类型 4.1 语法 本节描述的语法（以及向前兼容的解析规则）适用于任何级别的 CSS（包括CSS 2.2）。CSS 将来的更新也将遵守此处的核心语法，尽管它们可能添加了额外的语法约束。 这些描述都是规范的内容，它们也会被 附录 G 中提出的规范语法规则所补充。 本规范中，类似于 “前面紧跟” 或者 “后面紧跟” 的表述意味着之间没有空格或者注释。 4.1.1 符号化 所有级别的 CSS — CSS 1、CSS 2和将来的任何级别 — 用的都是相同的核心语法。这样 UA 就可以解析（虽然不完全能理解）以 UA 发布时 尚不存在的 CSS 版本编写的样式表。设计者可以根据该特征来创建兼容旧版本用户代理的样式表，同时也能运用最新版本的CSS 在词法层面，CSS 样式表由一系列 标记（符号）组成。CSS 标记（符号）列表如下，这些定义了使用了 Lex 风格的正则表达式。八进制码参考了 ISO 10646（[ISO10646]），和词法分析一样，存在多个匹配时，把最长的匹配作为 标记（符号）。 以上定义中花括号({})中的宏定义（macros）如下： 比如，最长匹配规则意味着 “red-->” 会被符号化为一个 IDENT “red--” 后面跟着一个DELIM “>”，而不是一个 IDENT 后面跟着一个 CDC。 下面是 CSS 的核心语法，本节接着描述怎样使用它。附录 G 描述了一个约束更多的更接近 CSS 2 的语法。能根据本语法解析，但不能用附录 G中的语法解析 的部分样式表都是按照处理解析错误的规则应该忽略的部分 \"unused\" 产生式不用在 CSS 中，也不会被任何将来的扩展使用。这里提到它只是为了帮助完成错误处理。（见 4.2 “处理解析错误的规则”） 注意：标记（符号）不会出现在语法中（为了保持其可读性），但任意数量的标记（符号）都可以出现在其它标记（符号）外的任何地方（注意，然而，出现在 @charset 前或者里面的注释都会导致 @charset 无效）。 上面语法中的标记 S 代表空白字符，空白字符中只能出现 \"space\" (U+0020)、\"tab\" (U+0009)、\"line feed\" (U+000A)、\"carriage return\" (U+000D)和 \"form feed\" (U+000C)。其它的类空白字符，例如\"em-space\" (U+2003)和\"ideographic space\" (U+3000)不会被当作空白字符的一部分。 不能被符号化或解析的输入的含义在 CSS 2.2 中未定义。 4.1.2 关键字 关键字是标识符（原：identifiers）形式的，不能放在引号(\"...\"或者'...')中，因此，而 \"red\" 不是，（它是一个字符串）。 其它非法示例： width: \"auto\"; border: \"none\"; background: \"red\"; 4.1.2.1 特定供应商的扩展 CSS 中，标识符可能以 '-'（短线）或者 ''（下划线）开头，以 '-'或者 ''开头的关键字和属性名是为特定供应商扩展保留的。这样的特定供应商扩展应该满足下列任一格式： '-' + vendor identifier + '-' + meaningful name '_' + vendor identifier + '-' + meaningful name 比如，如果 XYZ 组织添加了一个用来描述东边边框颜色属性，他们可能叫它 -xyz-border-east-color 其它众所周知的示例： -moz-box-sizing -moz-border-radius -wap-accesskey 开头的短线或下划线用来保证不会被现在及将来的任意版本 CSS 用作属性或关键字。因此，通常CSS 实现可能无法识别这种属性，而会根据处理解析错误的规则忽略掉它。然而，因为开头短线或下划线也是语法的一部分，CSS 2.2 的实现者们都应该采用遵从 CSS 的解析器，无论是否支持任何特定供应商扩展。 作者应该避免特定供应商扩展。 4.1.2.2 信息性历史记录 本节内容是信息性的 编写本文档时，下列众所周知的前缀已经存在了： 4.1.3 字符和大小写 下列规则一直是有效的： ASCII 范围内的所有 CSS 语法都是大小写不敏感的（比如，[a-z]和[A-Z]是等效的），那些不由 CSS 控制的部分除外。比如，HTML 中属性 id 和 class 的值，字体名的值和本规范外的 URI 都是大小写敏感的。特别注意，HTML 中元素名是大小写不敏感的，但在 XML 中是大小写敏感的。 CSS 中，标识符（包括选择器中的元素名，类和 ID）都只含有字符 [a-zA-Z0-9] 和 ISO 10646字符中 U+00A0 及之后的，以及连字符(-)和下划线(_)，它们不能以一个数字，2个连字符，或者后面跟着数字的连字符开头。标识符可以含有转义字符和任意作为数字代码的ISO 10646字符。比如，标识符 \"B&W?\" 可以写成 \"B\\&W\\?\" 或者 \"B\\26 W\\3F\" 注意，Unicode和ISO 10646（见[UNICODE]和[ISO10646]）是等效的代码 在 CSS 2.2 中，反斜杠（\\）字符可以表示三种类型的转义之一。在 CSS 注释内部，反斜杠代表自己，如果样式表的末尾后面紧跟反斜杠，它也代表自己（即，DELIM token）。 首先，在字符串内部，将忽略换行符后跟的反斜杠（即，该字符串被视为不包含反斜杠或换行符）。在字符串之外，反斜杠后跟换行符代表自己（即，DELIM 后跟换行符）。 其次，它取消了 CSS 特殊字符的含义。任何字符（除十六进制数字，换行符，回车符或分页符以外）都可以使用反斜杠进行转义，以消除其特殊含义。比如，\"\\\"\" 是一个由双引号组成的字符串，样式表预处理器不能从样式表中删除这些反斜杠，因为这会改变样式表的含义。 然后，反斜杠转义能使作者引用文档的特殊字符。在这种情况下，反斜杠后跟最多六个十六进制数字（0..9A..F），它代表 ISO 10646（[ISO 10646]）中对应数字的 字符，这个数字一定是非零的（如果样式表确实包含 Unicode 码位值为零的字符会发生什么，CSS 2.2 没有定义）。如果在 [0-9a-fA-F] 范围内的字符跟随十六进制，则需要明确数字的结束位置，这里有两种办法： 用一个空格（或者其他空白字符）：\"\\26 B\" (\"&B\")，在这种情况下，用户代理应将 \"CR/LF\" (U+000D/U+000A) 视为单个空白字符。 提供刚好是 6 位十六进制数：\"\\000026B\" (\"&B\")。 实际上，这两种方法可以结合起来。在十六进制转义后，只会忽略一个空白字符。注意：这意味着转义序列后面的一个 “真正的” 空格必须双写。 如果该数字超出 Unicode 允许的范围（比如，\"\\110000\" 超出当前 Unicode 允许的最大 10FFFF），则 UA 可以用 “替换字符”(U+FFFD) 换掉这个转义。如果要显示该字符，则 UA 需要显示一个可见的符号，比如 “缺失字符” 的字形（见 15.2 小节第 5 点）。 注意：反斜杠转义符始终会被认为是标识符或字符串的一部分（即，\"\\7B\" 不是标点符号，即使 \"{\" 是这个；\"\\32\" 允许使用在类名开头，但 \"2\" 就不能）。\"te\\st\" 标识符和 \"test\" 一样。 4.1.4 语句 CSS 样式表适用于任何级别的 CSS，并且由一系列语句组成（参见上面的语法）。这里有两种声明语句：@规则 和 规则集。声明（语句）前后可能有空白字符。 4.1.5 @规则 @规则 以一个 @ 关键字开头，@ 字符后面紧跟着一个标识符（比如，@import，@page）。 一个规则包含下一个分号（；）或下一个分块的所有内容，以谁先出现为准。 CSS 2.2 用户代理必须忽略所有出现在块内部，或者在 @charset 或 @import 规则之外的任何无法忽略的语句之后出现的 @import 规则。 示例：CSS 2.2 解析器遇到此样式表： @import \"subs.css\"; h1 { color: blue } @import \"list.css\"; 根据 CSS 2.2，第二个 @import 不合法。 CSS 2.2 解析器就忽略了整个规则，样式表实际成了： @import \"subs.css\"; h1 { color: blue } 示例：第二个 @import 是不合法，因为它出现在 @media 块的内部。 @import \"subs.css\"; @media print { @import \"print-main.css\"; body { font-size: 10pt } } h1 {color: blue } 相反的，要实现只在媒体类型为 print 时引入样式表的效果，可以使用带媒体类型的@import 规则语法，比如： @import \"subs.css\"; @import \"print-main.css\" print; @media print { body { font-size: 10pt } } h1 {color: blue } 4.1.6 块 块以左大括号（{）开头，以右大括号（}）为结束。在它们之间可能有任何的 token，但括号（()），方括号（[]），大括号（{}）总是成对出现并且可以嵌套。单引号（'）和双引号（\"）也总是成对出现的，并且它们之间的字符被解析为字符串。参考上面的 Tokenization 定义。 块的示例：请注意，双引号之间的右括号与块的左括号不匹配，并且第二个单引号是转义字符，因此与第一个单引号不匹配 { causta: \"}\" + ({7} * '\\'') } 注意：CSS 2.2 中，上面规则不合法，但符合其定义。 4.1.7 规则集，声明块，选择器 规则集（也称为“规则”），由 选择器 后跟 声明块 组成。 声明块 以左大括号（{）开头，以匹配的右大括号（}）结束。在它们之间必须有零个或多个声明和规则的列表。声明必须以分号（;）结尾，除非它们是列表中的最后一个。 注意：CSS 级别 2 可能没有出现在规则集内的规则，但在未来的级别中可能出现。 选择器（见 选择器 部分）包含第一个左大括号（{）的所有内容（但不包含 左大括号）。选择器总是与声明块一起使用。当用户代理无法解析选择器时（即，不是合法的 CSS 2.2 选择器），它也必须忽略选择器和紧跟随的声明块（如果有的话）。 在选择器中，CSS 2.2 赋予了逗号（,）特殊的含义。但是，由于不知道 逗号 会在将来的 CSS 中是否有其它含义，因此，如果在选择器中有任何位置出现错误，则忽略整个语句，即使选择器的其余部分看起来合理。 示例：由于 “＆” 不是 CSS 2.2 选择器中的有效标记，因此 CSS 2.2 用户代理必须忽略整个第二行，而不是将 H3 的颜色设置为红色： h1, h2 {color: green } h3, h4 & h5 {color: red } h6 {color: black } 更复杂的示例：前两对花括号位于一个字符串内，但没标记选择器的结束，这是一个合法的 CSS 2.2 规则： p[example=\"public class foo\\ {\\ private int x;\\ \\ foo(int x) {\\ this.x = x;\\ }\\ \\ }\"] { color: red } 4.1.8 声明和属性 声明要么为 空，要么由一个后面跟冒号（:）和选择器 的属性名组成。（它们）之间可以有空白字符。 由于选择器的工作方式，同一选择器的多个声明可以组织成使用分号（;）分隔的组。 因此，以下规则： h1 { font-weight: bold } h1 { font-size: 12px } h1 { line-height: 14px } h1 { font-family: Helvetica } h1 { font-variant: normal } h1 { font-style: normal } 等价于 h1 { font-weight: bold; font-size: 12px; line-height: 14px; font-family: Helvetica; font-variant: normal; font-style: normal } 属性名是一个标识符。属性值可能会出现任何的 token。圆括号(( ))，方括号([ ])，大括号({ })，单引号(')和双引号(\")必须成对出现，并且非字符串形式的分号必须转义。圆括号，方括号和大括号可以嵌套。在引号里，字符解析为字符串。 （属性）值的语法为每个属性单独指定的，任何情况下，值都是由 标识符，字符串，数字，长度，百分比，URI，颜色等构建的。 用户代理必须忽略含有无效属性名称或无效值的声明。每个 CSS 属性对其接受的值都有自己的语法或语义限制。 示例：CSS 2.2 解析如下规则： h1 { color: red; font-style: 12pt } /* Invalid value: 12pt */ p { color: blue; font-vendor: any; /* Invalid prop.: font-vendor */ font-variant: small-caps } em em { font-style: normal } 第一行的第二个声明有无效值 '12pt'。第二行的第二个声明包含一个未定义的属性 font-vendor。CSS 2.2 解析器将忽略这些声明，样式表解析为： h1 { color: red; } p { color: blue; font-variant: small-caps } em em { font-style: normal } 4.1.9 注释 注释以字符 /* 开头，以字符 */ 结尾。它们可能出现在其他 token 之外的任何地方，其内容对渲染没有影响。注释可能不会嵌套。 CSS 也允许在语法定义的某些位置使用 SGML 注释分隔符（ 和 -->），但不会分隔 CSS 注释。它们让出现在 HTML 源文档（STYLE 元素）中的样式规则可以在用户代理中隐藏起来。更多信息请查看 HTML 4 规范（[HTML4]）。 4.2 处理解析错误的规则 在某些情况下，用户代理必须忽略不合法样式表的某一部分。本规范定义忽略是意味着用户代理要解析非法部分（为了找到起止位置），但还要表现得像这部分不存在一样。CSS 2.2 保留了 CSS 所有的属性未来的更新：值组合和不含以斜线和下划线开头的标识符的@关键字。实现必须忽略这样的组合（除了那些在将来 CSS 更新中介绍的）。 为了保证将来可以添在现有的属性上添加新属性和新值，用户代理遇到下列场景时需要遵循下列规则： 未知属性：用户代理必须忽略未知属性的声明。比如，样式表如下： h1 { color: red; rotation: 70minutes } // 解析为 h1 { color: red } 不合法值：用户代理必须忽略不合法值的声明。比如，样式表如下： img { float: left } /* correct CSS 2.2 */ img { float: left here } /* \"here\" is not a value of 'float' */ img { background: \"red\" } /* keywords cannot be quoted */ img { border-width: 3 } /* a unit must be specified for length values */ // 解析为 img { float: left } img { } img { } img { } 格式错误的声明：用户代理必须处理解析声明期间遇到的异常 token，一直读到声明结束，从()，[]，{}，\"\"和'' 对中寻找对应的规则，并正确处理转义。比如，格式错误的声明可能会缺少属性名称，冒号(:)或者属性值。 当 UA 从 声明或 @规则 的开始遇到异常 token，则该 token 被认为是格式错误声明的第一个 token。即，在这种情况下，应使用格式错误的声明而不是使用格式错误的语句来忽略那些 token。 p { color:green } p { @foo { bar: baz } color:green } /* unknown at-rule */ p { color:green; color } /* malformed declaration missing ':', value */ p { color:red; color; color:green } /* same with expected recovery */ p { color:green; color: } /* malformed declaration missing value */ p { color:red; color:; color:green } /* same with expected recovery */ p { color:green; color{;color:maroon} } /* unexpected tokens { } */ p { color:red; color{;color:maroon}; color:green } /* same with recovery */ 格式错误的语句：用户代理必须处理解析语句期间遇到的异常 token，一直读到语句结束，从()，[]，{}，\"\"和'' 对中寻找对应的规则，并正确处理转义。比如，格式错误的语句可能会异常的大括号或 @关键字。以下规则被忽略： // markdown 需要反斜杠转义 双大括号 p @here {color: red} // ruleset with unexpected at-keyword \"@here\" @foo @bar; // at-rule with unexpected at-keyword \"@bar\" \\}\\} \\{\\{ - \\}\\} // ruleset with unexpected right brace ) ( {} ) p {color: red } // ruleset with unexpected right parenthesis @规则有未知关键字：@规则有未知关键字。用户代理必须忽略不合法的关键字及其后面跟着的任何东西，直到遇到 不合法@关键字的块结束，或分号，或下一个块。 @three-dee { @background-lighting { azimuth: 30deg; elevation: 190deg; } h1 { color: red } } h1 { color: blue } @three-dee 不是 CSS 2.2 的一部分，因此忽略整个规则，解析为： h1 { color: blue } 样式表异常结束：用户代理必须让样式表成对闭合（比如，块，小括号，方括号，规则，字符串和注释），如： @media screen { p:before { content: 'Hello 解析为： @media screen { p:before { content: 'Hello'; } } 字符串异常结束：用户代理必须闭合行尾的字符串（即，在未转义的换行，回车，换页符之前），但要删除包含该字符串的声明或规则，如： p { color: green; font-family: 'Courier New Times color: red; color: green; } 因为第二条声明 （从 font-family 到 color: red;）是不合法的，则解析为： p { color: green; color: green; } 声明块的规则：见 4.1.7-规则集，声明块，选择器 小节。 4.3 值 4.3.1 整数和实数 某些值类型可能是整数值（用 表示）或实数值（用 表示）。实数和整数都只是用十进制的表示。 由一个或多个 \"0\" 到 \"9\" 的数字组成， 既可以是一个 ，也可以是 0 个或多个数字，后面跟着一个小数点和一个或多个数字。整数和实数之前都可以有 \"-\" 或者 \"+\" 表示符号。-0 等价于 0，不是负数， 注意：很多允许整数或者实数作为值的属性实际上限制了值的范围，通常是一个非负值 4.3.2 长度 长度是指距离测量。 长度值的格式是一个 后面紧跟着一个单位标识符（比如，px，em）。0 长度后面的单位标识符可选。 一些属性允许负长度值，但这可能使格式化模型复杂了，并且存在特定的限制。若不支持，则会转换为可支持的近似值。 如果负长度值不允许使用，则忽略该声明。 如果设置的长度不支持，则设置其近似支持值。 有两种类型的长度单位：相对和绝对。相对长度单位指定相对于另一个长度属性的长度。使用相对单位的样式表可以更容易地从一个输出环境扩展到另一个输出环境。 相对单位有： em：相关字体的 font-size ex：相关字体的 x-height h1 { margin: 0.5em } /* em */ h1 { margin: 1ex } /* ex */ em 单位等于 使用该规则的元素的 font-size 属性的计算值。有一种例外情况是，当 em 用于其它属性时，在这种情况下它使用父元素的 font-size。 ex 单位由元素的第一个可用字体定义。有一种例外情况是，ex 用于 font-size 属性的值时，在这种情况下它使用父元素的 ex。 之所以称为 x-height，是因为它通常等于小写 “x” 的高度。但是，即使对于不包含 “x” 的字体，也会定义 “ex”。 可以通过不同的方式获得 x-height。有些字体会包含 x-height 的精确指标。如果字体的精确指标无法获得，则 UA 可以从小写字形的高度来确定 x-height。一种可能的方式是看小写 \"o\" 的字形延伸到基线下方多远，并减去其边界的 top 值。如果实在没法确定 x-height，就使用 0.5em。 如下规则： h1 { line-height: 1.2em } 表示 h1 元素的行高比 h1 元素的字体大小大 20%，另一种情况： h1 { font-size: 1.2em } 表示 h1 元素的行高比 h1 元素继承的字体大小大 20% 当文档树的根（比如，HTML 中的 \"HTML\"）指定为 相对单位时，em 和 ex 相对该属性的初始值。 子元素不继承父元素指定的相对值，它们继承的是计算值。 如下规则，如果 h1 是 body 元素的子级，则 h1 元素的 text-indent 为 36 px，而不是 45 px： body { font-size: 12px; text-indent: 3em; /* i.e., 36px */ } h1 { font-size: 15px } 绝对长度单位相对于彼此固定。它们主要用于在已知当前环境的情况下。绝对单位由物理单位（in，cm，mm，pt，pc）和 px 单位组成： in：英寸，1in === 2.54cm cm：厘米 mm：毫米 pt：点（原：points），CSS 中的 1pt === 1in 的 1/72 pc：派卡（原：picas），1px == 12pt px：像素单位，1px === 0.75pt 对于 CSS 设备，这些尺寸要么参照（i）物理测量相关的物理单元，要么参照（ii）参考像素 相关的像素单元。对于打印介质和类似的高分辨率设备，参照单位应该是标准物理单位之一（英寸，厘米等）。对于低分辨率设备和具有特殊观看距离的设备，建议将参照单位作为像素单元。对于这种设备，建议像素单元参考最接近参考像素的整数设备像素。 注意：如果参照单位是像素单位，则物理单位可能与其物理测量值不匹配。或者，如果参照单位是物理单位，则像素单位不能映射到整数个设备像素。 注意：这里像素单位和物理单位的定义在 CSS 之前的版本定义不同。特别地，在 CSS 之前的版本中，像素单位与物理单位没有 固定比例 的关系：物理单位总是与物理测量的相关，而像素单位会变得接近参考像素。（这种变化出现是因为太多现有内容依赖96 dpi 的假设，而破坏这个假设就会破坏这些内容）。 而 参考像素 是 像素密度为 96 dpi 的设备上一个像素与 人的臂长和屏幕之间 的距离长度 的视角。对于标准臂长为 28in 来说，视角约为 0.0213 角度。为了在臂长位置上阅读，所以 1px 约等于 0.26 mm（1/96 in）。 下图描述了视距对参考像素大小的影响：在 71 cm（28 in）的阅读距离下 一个参考像素是 0.26 mm，而在 3.5 m 的阅读距离下 一个参考像素是 1.3 mm。 此图长描述 下图描述了设备分辨率对像素单位的影响：1px * 1px 的区域被在低分辨率设备（如通用计算机屏幕）上的 1 个点覆盖，而同一个区域在高分辨率设备（如打印机）被 16 个点覆盖。 此图长描述 h1 { margin: 0.5in } /* inches */ h2 { line-height: 3cm } /* centimeters */ h3 { word-spacing: 4mm } /* millimeters */ h4 { font-size: 12pt } /* points */ h4 { font-size: 1pc } /* picas */ p { font-size: 12px } /* px */ 4.3.3 百分比 百分比值的格式（本规范适用 表示）是 后紧跟 %。 百分比值始终相对于另一个值，比如 长度。每个属性如果允许百分比的值的话，定义也会给出所参考的值。该值可以是同一个元素的另一个属性的值，祖先元素的属性或格式化上下文的值（比如，包含块的宽度）。当给 根元素 的属性上设置百分比值，并且 百分比参考某些属性的继承值时，结果值是 百分比乘该属性的初始值。 由于子元素（通常）继承其父元素的计算值，因此下列示例中，P 元素的子级将继承为 line-height: 12px 的值，而不是百分比值（120%）： p { font-size: 10px } p { line-height: 120% } /* 120% of 'font-size' */ 4.3.4 URL 和 URI 本规范中的 URI 值（统一资源标识符，见 RFC3986，包含 URL、URN 等等），用 表示。用于属性值使用 URI 的功能，用 url()，如： body { background: url(\"http://www.example.com/pinkish.png\") } 一个 URI 值的格式是 url(后跟可选空白字符，后跟可选的单|双引号，后跟 URI 本身，后跟可选的单|双引号)，后跟)。两个前后引号字符必须相同。 没有引号的示例： li { list-style: url(http://www.example.com/redball.png) disc } 出现在不带引号的 URI 中的某些字符（如括号，空格字符，单引号（'）和双引号（\"））必须使用反斜杠进行转义，以便生成的 URI 值为 URI 标记：'('，')'）。 根据 URI 的类型，也可能将将上述字符写为 (\" = %28, \")``= %29 等等，如 RFC3986。 注意：注释的 token 不会出现在其它 token 中：因此，url(/*x*/pic.png) 表示为 /*x*/pic.png，而不是 pic.png。 为了创建不依赖于资源绝对位置的模块化样式表，作者可以使用相对 URI。相对 URI（如 RFC3986 定义）会根据基础 URI 解析为完整的 URI。RFC 3986 的第 5 节定义了解析的算法过程。对于 CSS 样式表而言，基础 URI 是相对于该样式表（所在的 URL），而不是源文档。 比如，以下规则： body { background: url(\"yellow\") } URI 的样式表地址：http://www.example.org/style/basic.css，则源文档的背景图片的地址为 http://www.example.org/style/yellow。 用户代理在如何处理非合法法 URI 或者 URI 指向的不可用或不适用资源上（的处理方式）可能有差异。 4.3.5 计数器 计数器由大小写敏感的标识符表示（见 “计数器增量”和 “计数器重置” 属性）。为了使用计数器的值，使用符号 counter() 或 counter(，)，并使用可选的空格分隔标记。默认样式为 “十进制”。 要使用一系列相同名称的嵌套计数器，表示法是 counters(，)或 counters(，，) 可选的空白字符分隔这些 token。 关于用户代理如何确认计数器值的细节见 生成内容 章节。要想了解计数器值如何转换为字符串，参考 content 属性的定义。 在 CSS 2.2 中，只能从 content 属性引用计数器的值。注意，none 有可能是 ：counter(x, none) 生成一个空字符串。 示例：一个样式表相对每章 h1 的 段落 p 进行计数。段落使用罗马数字计数，后面跟一个句号和一个空格： p {counter-increment: par-num} h1 {counter-reset: par-num} p:before {content: counter(par-num, upper-roman) \". \"} 4.3.6 颜色 要么是一个关键字，要么就是合法的 RGB 数值。 颜色列表的关键字：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, 和 yellow。这 17 种颜色的值如下： 除了这些颜色关键字之外，在用户环境中，用户还可以指定对应的用于某些对象的颜色关键字。更多信息请查看 系统颜色 章节。 body {color: black; background: white } h1 { color: maroon } h2 { color: olive } RGB 颜色模型用于数字颜色规范。这些示例都指定了相同的颜色： em { color: #f00 } /* #rgb */ em { color: #ff0000 } /* #rrggbb */ em { color: rgb(255,0,0) } em { color: rgb(100%, 0%, 0%) } 十六进制表示法的 RGB 值格式为：# 后跟三个或六个 十六进制字符。三位 RGB 表示法（#rgb）通过复制数字而不是通过添加零来转换为六位数形式（#rrggbb）。比如，#fb0 转为 #ffbb00。这也可以确保白色用（#fff）来指定（#ffffff），且去掉了对显示器颜色深度的依赖。 函数表示法的 RGB 值格式为：rgb('后面由逗号分割的3个数值，数值可以为整数或百分比')。整数值 255 对应于 100%，即 rgb(255,255,255) = rgb(100%, 100%, 100%) = #fff。数值周围可使用 空白字符。 所有 RGB 颜色都在 sRGB 颜色空间中指定（参见[SRGB]）。用户代理在它们表示这些颜色的保真度方面可能有所不同，但是使用 sRGB 提供的颜色是明确可测量的，这与国际标准由关（参见[COLORIMETRY]）。 （与本规范保持一致的）用户代理可能会进行伽马校正，限制其颜色的显示。sRGB 指定在特定观察环境下动态灰度（原：display gamma）为 2.2。用户代理会调整 CSS 给出的颜色，这样结合输出设备的 “自然” 动态灰度，一个有效的 2.2 动态灰度就产生了。注意，只有在 CSS 中指定的颜色才会有影响，比如，图片就被认为携带了自己的颜色信息。 在设备色域以外的值理应被裁切或映射到已知色域中：red、green 和 blue 应该被转为设置支持的范围内。用户代理可能会进行 从一个（低）色域到高色域的颜色映射。对于典型的 RCT 显示器，其色域值和 RGB 相同，则下面四条规则是一样的： em { color: rgb(255,0,0) } /* integer range 0 - 255 */ em { color: rgb(300,0,0) } /* clipped to rgb(255,0,0) */ em { color: rgb(255,-10,0) } /* clipped to rgb(255,0,0) */ em { color: rgb(110%, 0%, 0%) } /* clipped to rgb(100%,0%,0%) */ 其它设备，如打印机，其色域与 sRGB 不同，（在设备色域内）某些 0...255 sRGB 之外的颜色也是可以表示的，而那些在 0...255 sRGB 之内的颜色可能因为不在 设备色域 内而被映射。 注意：色值的映射或裁切应该在 设备色域已知（可能比 0...255 大或小） 时进行。 4.3.7 字符串 字符串可以使用双引号或单引号编写。除非转义，双引号内不能出现双引号。单引号同理。 \"this is a 'string'\" \"this is a \\\"string\\\"\" 'this is a \"string\"' 'this is a \\'string\\'' 字符串不能直接包含换行符。（如果）要在字符串内使用换行符，则需要使用 ISO-10646 (U+000A)中换行符的转义符，比如 \\A 或 \\00000a。这个字符在 CSS 中表示 “换行”。示例见 content 属性。 出于美观或其它原因，字符串有可能分成几行，这种情况下，换行符自身要使用反斜杠（\\）转义。下面两个选择器等价： a[title=\"a not s\\ o very long title\"] {/*...*/} a[title=\"a not so very long title\"] {/*...*/} 4.3.8 不支持的值 如果 UA 不支持某个特殊值，则在样式表解析的时应忽略该值，好像该值不合法一样。比如： h3 { display: inline; display: run-in; } 支持 display: run-in 的 UA 会接受第一个 display 声明，然后使用第二个 display 覆盖。不支持的话，将处理第一个 display 声明且忽略掉第二个声明。 4.4 CSS 样式表的展示 CSS 样式表是通用字符集中的一系列字符（参见[ISO10646]）。为了传输和存储，这些字符必须根据 US-ASCII 中可用字符集的字符编码（比如，UTF-8，ISO 8859-x，SHIFT JIS等）编码。有关字符集和字符编码的详细介绍，请参阅 HTML 4 规范（[HTML4]，第5章）。另请参阅 XML 1.1 规范（[XML11]，第 2.2 和 4.3.3 节以及附录 E）。 当样式表嵌入在另一个文档中时，比如在 HTML 的 STYLE 元素或 “style” 属性中，样式表共享整个文档的字符编码。 样式表位于单独的文件中时，用户代理在确定样式表的字符编码时（从最高优先级到最低优先级）必须遵循以下优先级： “Content-Type” 字段中的 HTTP “charset” 参数（或其他协议中的类似参数） BOM 和/或 @charset（见下方） 或来自其它链接的元数据（如果有的话） 要引入样式表或文档的字符集（如果有的话） 假设为 UTF-8 @charset 规则应该放在样式表的开头，需用引号指定字符编码，必须写成字面量形式（即，@charset（小写、不含反斜杠转义）+ 编码名 + ;）如： @charset \"ISO-8859-1\"; 编码名必须是 IANA 注册库 中的字符集名。完整列表见 [CHARSETS]。含有 MIME 的字符集名应优先使用。 用户代理至少必须支持 UTF-8 编码。 如果上面的规则 1 （HTTP “charset” 参数 或类似参数）生成的字符编码且是 UTF-8、UTF-16、UTF-32 三者之一，则文件开头的 BOM （如果有）会覆盖字符编码，如下： 如果规则 1 生成的字符编码是 UTF-16BE、UTF-16LE、UTF-32BE、UTF-32LE 之一，则如今以 BOM 开头会报错。CSS UA 则需要忽略指定的编码切使用上表来恢复。 用户代理必须忽略任何不在样式表开头的 @charset 规则。 当用户代理使用 BOM 和/或@charset 规则检测字符编码时，它们应遵循以下规则： 除了这里指定的规则外，所有 @charset 规则都会忽略。 编码通过样式表开头的字节流来检测。下表给出了初始字节序列的一组可能写法（以十六进制编写）。与样式表开头匹配的第一行根据 BOM 和/或 @charset 规则提供编码检测结果。如果没有匹配的行，则无法根据 BOM 和/或 @charset 规则检测编码。符号(...)* 指的是匹配部分可能会重复匹配几次。标记为 “XX” 的字节是用于确定编码名称的，通过按给定的顺序将它们视为 ASCII 字符序列。标记为 “YY” 的字节类似，但需要根据提示转码为 ASCII。如果用户代理不支持与条目相关的任何编码，则可以忽略表中的条目： 如果编码是根据上面的被标记为 “与指定值相同” 的某一项检测出来的，但根据选定的@charset 解码字符流开头部分无法被解析成一个合适的@charset规则的话，用户代理应该忽略该样式表。 @charset 规则只在样式表的编码中生效 字节顺序标记只在支持字节顺序标记的编码中被忽略，并且 编码名不能含有换行符 用户代理必须忽略未知编码的样式表。 4.4.1 涉及当前字符集之外的字符 样式表可能不得不引入那些在当前字符编码中无法显示的字符。这些字符必须被写成转义的 ISO 10646 字符。这些转义的目的都是把数字字符引入 HTML 或者 XML 文档中（参见[HTML4]，第5章和25章）。 字符转义机制应该只被用在一些必须以这种方式显示的字符上。如果样式表中的大部分内容都需要转义，作者应该用一种更合适的编码来对它进行编码（比如，如果样式表含有大量的希腊文字，作者应该用 \"ISO-8859-7\" 或者 \"UTF-8\"） 使用不同的字符编码的中间处理器可以把这些转义的序列翻译成相应编码的字节序列。另一方面，中间处理器不能改变转义序列取消ASCII字符的特殊含义。 （与本规范）一致的用户代理必须能够正确地把 ISO-10646 的所有字符映射成它们可识别的字符编码（或者它们必须表现得至少看起来是正确的）。 比如，一份以 ISO-8859-1(Latin-1) 传输的样式表不能直接包含希腊字母：\"κουρος\"（希腊语：\"kouros\"(青年)）必须写作 \"\\3BA\\3BF\\3C5\\3C1\\3BF\\3C2\"。 注意：在 HTML 4 中，数字字符引用被解释为 \"style\" 属性的值，而不是 STYLE 元素的内容，我们建议作者对 \"style\" 属性和 STYLE 元素都使用 CSS 字符转义机制而不是数字字符引用，比如，我们推荐： ... 而不是： ... Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-11-18 16:15:20 "},"docs/CSS/CSS2.2/5 选择器.html":{"url":"docs/CSS/CSS2.2/5 选择器.html","title":"5 选择器","keywords":"","body":"5 选择器 5.1 模式匹配 在 CSS 中，模式匹配规则决定哪些样式规则适用于文档树中的元素。这些模式就叫选择器，范围可以从简单的元素名称到丰富的上下文模式。如果模式中所有的所有条件对于某个元素都为真，则选择器匹配该元素。 在选择器中，文档语言元素名称的大小写取决于文档语言。比如，在 HTML 中元素名称不区分大小写，但在 XML 中，它们区分大小写。 下表总结了 CSS2.2 选择器语法： 模式 含义 描述 * 匹配所有元素 Universal selector（通用选择器） E 匹配所有 E 元素（比如元素的类型为 E） Type selectors（类型选择器） E F 匹配所有作为 E 元素后代的 F 元素 Descendant selectors（后代选择器） E > F 匹配所有作为 E 元素直接子元素的 F 元素 Child selectors（子选择器） E:first-child 当 E 元素是其父元素的第一个子元素时匹配 E 元素 The :first-child pseudo-class（:first-child 伪类） E:link E:visited 如果 E 元素尚未访问（:link）或已访问（:visited），则匹配 E 元素 The link pseudo-classes（link 伪类） E:active E:hover E:focus 在用户某些操作的时候匹配 E The dynamic pseudo-classes（动态伪类） E:lang(c) 如果语言为 c （文档语言会指定怎样确定语言），则匹配 E 元素 The :lang() pseudo-class（:lang() 伪类） E + F 匹配所有前面紧跟着 E 元素的 F 元素 Adjacent selectors（相邻选择器） E[foo] 匹配所有具有 foo 属性集（无论值是什么）的 E 元素 Attribute selectors（属性选择器） E[foo=\"warning\"] 匹配所有 foo 属性完全等于 warning 的 E 元素 Attribute selectors（属性选择器） E[foo~=\"warning\"] 匹配所有 foo 属性值是空格分隔值列表，其中一个值是 warning Attribute selectors（属性选择器） 匹配所有 lang 属性值以 en 开头（从左到右）用连字符分隔值 的 E 元素 Attribute selectors（属性选择器） DIV.warning 语言指定的（与 DIV[class~=\"warning”] 一样） Class selectors（类选择器） E#myid 匹配所有 ID 为 myid 的 E 元素 ID selectors（ID 选择器） 5.2 选择器语法 简单选择器可以是 类型选择器 或 后面紧跟 0 个或多个以任意顺序排列的属性选择器，ID 选择器，伪类 的通用选择器。简单选择器需要其所有部分都匹配成功才算匹配成功。 选择器是一串用连接符分隔的一个或多个简单选择器。连接符有：空白字符、>、+。空白字符可以出现在连接符和它前后的简单选择器之间。 与选择器匹配的文档树元素称为选择器的对象。由单个简单选择器组成的选择器匹配所有可以满足其需求的元素。给一串（选择器）前面加上一个简单选择器和连接符就会增加额外的匹配约束，所以一个选择器的对象总是最后一个简单选择器匹配的元素的子集。 一个伪元素可以被添加在一串选择器中最后一个选择器后面，此时样式信息会被适用在每个匹配上的元素的子内容上。 5.2.1 分组 当多个选择器共享相同的声明时，它们分组成以逗号分隔的列表里。 本例中，我们把三条有相同声明的规则压缩成一条，因此 h1 { font-family: sans-serif } h2 { font-family: sans-serif } h3 { font-family: sans-serif } // 等同于 h1, h2, h3 { font-family: sans-serif } CSS 也提供了其它简写机制，包括（一次）声明多条（规则）和 属性简写。 5.3 通配选择器 通配选择器写作 *，匹配所有元素类型的名称。匹配文档树中的任意单个元素。 如果通配选择器不是简单选择器的唯一组成部分（即选择器不为 ），* 可以省略，比如： *[lang=fr] 等价于 [lang=fr] *.warning 等价于 .warning *#myid 等价于 #myid 5.4 类型选择器 类型选择器匹配 文档语言 元素类型名称。一个类型选择器会匹配文档树中所有该元素类型的实例。 下列规则匹配文档树中的所有 H1 元素： h1 { font-family: sans-serif } 5.5 后代选择器 有时，作者可能希望选择器匹配一个 在文档树中 作为另一个元素后代的 元素（比如，匹配 元素包含的那些 元素）。后代选择器用模式表达这种关系。后代选择器由 两个或多个 由 空白字符（white space）分隔的选择器组成。形如 A B 的后代选择器匹配一个元素 B，只要它是祖先元素 A 的任意后代。 比如，考虑下面的规则： h1 { color: red } em { color: red } 尽管这些规则的目的是通过改变颜色来给文本添加强调，但效果会在该情况下消失： This headline is very important 对于这种情况，我们通过 用一条设置文本颜色为蓝色的规则来补充之前的规则 解决，无论 出现在 内的哪个位置： h1 { color: red } em { color: red } h1 em { color: blue } 第三条规则将会匹配下列片段中的 ： This headline is very important 下列选择器： div * p 匹配作为 元素的 孙子或后来的 后代的 元素。注意，* 的前后的空白字符不是通配选择器的一部分，空白字符是一种连接符，表明 div 元素必须是某个元素的祖先，并且该元素是 的祖先。 下列规则中结合了 后代选择器和属性选择器 的选择器，匹配 具有 [href] 属性集且本身位于 元素内部的 元素的内部 的任意元素。 div p *[href] 5.6 子级选择器 子级选择器匹配一个 作为某个元素的 子级元素时。子级选择器由 两个或多个 被 > 分隔的选择器组成。 下面的规则设置了所有作为 子级元素的 元素的样式： body > P { line-height: 1.3 } 下面的示例结合了后代选择器和子级选择器： div ol>li p 它匹配一个作为 元素的后代的 元素，这个 元素必须是 元素的子级元素， 元素必须是 元素的后代。注意：连接符 > 前后可选的空白字符被删掉了。 关于选择元素的第一个子级元素的更多信息查看下面的 :fist-child 伪类小节。 5.7 相邻兄弟选择器 相邻兄弟选择器语法如下：E1 + E2，其中 E2 是选择器的对象。如果 E1 和 E2 在文档树中拥有相同的父级且 E1 紧挨着 E2 前面，忽略非元素节点（如文本节点和注释），则选择器成功匹配 E2。 因此，下列规则指出，当一个 元素紧跟着一个 元素后面时，它不应该缩减： math + p { text-indent: 0 } 下一个示例减少了紧挨着的 和 之间的垂直边距： h1 + h2 { margin-top: -5mm } 下面的规则与之前的示例相似，只是它添加了一个类选择器，因此，特殊的格式化只在 上有 class=\"opener\" 时才出现： h1.opener + h2 { margin-top: -5mm } 5.8 属性选择器 CSS 2.2 允许作者指定规则来匹配在源文档中定义了某些属性的元素。 5.8.1 匹配属性和属性值 属性选择器可以通过四种方式匹配： [att]：当元素设置了 att 属性时匹配，无论该属性的值是什么 [att=val]：当元素的 att 属性是 val 时匹配 [att~=val]：表示元素具有 att 属性，该属性值是以 空白字符 分隔的单词列表，其中一个正好是 val。如果 val 包含 空白字符，则它永远不会表示任何内容（因为单词由空格分隔）。如果 val 是空字符串，也不会代表任何东西。 [att|=val]：表示元素具有 att 属性，该属性值要么正好是 val 要么以 val 开头，后跟 -（U+002D）。这主要是为了允许 语言子码 按照 BCP47 或后续版本进行匹配（比如， 元素下的 hreflang 属性）。关于 lang（或 xml:lang）语言子码匹配，请看 :lang 伪类 小节 属性值必须是 标识符 或 字符串，选择器中属性名和值的大小写敏感取决于文档语言。 比如，下列属性选择器匹配所有指定 title 属性的元素，无论值是什么： h1[title] { color: blue; } 下例中，选择器匹配所有 class 属性值恰好是 example 的 元素： span[class=example] { color: blue; } 多个属性选择器可以用来引用同一个元素的几个属性，或者甚至把同一个属性引用多次 下面的选择器匹配所有 hello 属性值恰好是 Cleveland、goodbye 属性值恰好是 Columbus 的 元素： span[hello=\"Cleveland\"][goodbye=\"Columbus\"] { color: blue; } 下列选择器描述了 = 和 ~= 的区别，第一个选择器将匹配，例如，rel 属性值为 copyright copyleft copyeditor（的元素）。第二个只匹配 href 属性值为 http://www.w3.org/（的元素）。 a[rel~=\"copyright\"] a[href=\"http://www.w3.org/\"] 下面的规则隐藏了所有 lang 属性值为 fr（即语言是法语）的元素： *[lang=fr] { display : none } 下面的规则将匹配 lang 属性值以 en 开头，包括 en，en-US 和 en-cockney： *[lang|=\"en\"] { color : red } 同样，以下听觉样式表规则允许每个角色以 不同的声音 大声朗读 文本： DIALOGUE[character=romeo] { voice-family: \"Laurence Olivier\", charles, male } DIALOGUE[character=juliet] { voice-family: \"Vivien Leigh\", victoria, female } 5.8.2 DTD 中的默认属性值 省略，原因：HTML5 不需要引用 DTD 5.8.3 类选择器 编写 HTML 时，在表示 class 属性时，作者可以使用黑点 . 替代 ～=。因此，对于 HTML 来说，div.value 等同于 div[class~=value]。属性值必须紧跟黑点 . 后面。UA 可以在 XML 文档中把黑点 . 符号用于选择器，如果 UA 有特定命名空间信息允许它决定各个命名空间下哪个属性是 class 属性。这种特定命名空间信息的示例在针对特殊命名空间的规范（比如，SVG 1.1 [SVG11]描述了 SVG class 属性以及 UA 应该怎样解释它，类似的，MathML 3.0 [MATH30]描述了 MathML class 属性）中有。 比如，我们将样式信息分配给所有 具有 class~=\"pastoral\" 的元素： *.pastoral { color: green } /* all elements with class~=pastoral */ 或者直接 .pastoral { color: green } /* all elements with class~=pastoral */ 下面只给具有 class~=\"pastoral\" 的 元素设置样式： h1.pastoral { color: green } /* h1 elements with class~=pastoral */ 根据给出的这些规则，下面第一个 实例将不会有绿色文本，而第二个会： Not green Very green 为了匹配 class 的值的一个子集，每个值前面必须有一个 .。 比如，下列规则匹配所有 class 属性被赋值为一列空格分隔的含有 \"pastoral\" 和 \"marine\" 的值： p.marine.pastoral { color: green } 该规则匹配 class=\"pastoral blue aqua marine\" 但不匹配 class=\"pastoral blue\"。 注意：CSS 赋予了 class 属性非常多的能力，作者可以在与表现无关的元素（比如，HTML 中的 和 ）上设计他们自己的 \"文档语言\"，并通过 class 属性来设置样式信息。作者应该避免这种实践，因为文档语言的结构化元素通常具有可识别和可接受的含义，而作者定义的 class 没有。 注意：如果一个元素拥有多个 class 属性，在搜索 class 之前，它们的值必须以 空白字符连接起来。目前，工作组对这种情况能被达成的方式并不明确，所以本规范中，这种行为显然是非规范的。 5.9 ID 选择器 文档语言可能包含声明为 ID 类型的属性。ID 类型属性的特殊之处是没有两个这样的属性可以有相同的值。无论在什么文档语言中，一个 ID 属性都可以被用作其元素的唯一标识。在 HTML 中，ID 属性都被命名为 \"id\"，XML 可能以不用方式命名 ID 属性，但会受到同样的限制。 文档语言的 ID 属性允许做者给文档树中的一个元素实例设置一个标识符。CSS ID 选择器根据它的标识符匹配一个元素实例。一个 CSS ID 选择器包含\"#\"和后面紧跟着的ID值，该值必须是一个标识符。 下列 ID 选择器匹配 ID 属性值为 \"chapter1\" 的 H1 元素： Match P *#z98y { letter-spacing: 0.3em } Wide text 下一个示例中，样式规则将只匹配一个 ID 值为 \"z98y\" 的 H1 元素，该规则不会匹配本例中的 P 元素： Match H1 only h1#z98y { letter-spacing: 0.5em } Wide text ID 选择器比属性选择器的特殊性更高。比如，在 HTML 中，根据层叠，选择器 #p123 比[id=p123] 更具体。 如果一个元素有多个 ID 属性，鉴于 ID 选择器的目的，它们必须全部都被当作这个元素的 ID。这种情况可以通过使用 id[XMLID]、DOM3 Core [DOM-LEVEL-3-CORE]、XML DTDs [XML10]和特定命名空间信息的混合来实现。 5.10 伪元素和伪类 在 CSS 2.2 中，样式通常根据元素在 文档树 中的位置添加的。这种简单模型在大多数情况下就足够了，但在有些常见的排版场景下可能无法根据文档树中的结构（添加样式）。比如，HTML4 中，没有元素对应 一个段落的第一行，因此 CSS 中没有简单的选择器可以引用它。 为了允许基于文档树之外的信息进行格式化，CSS 引入了 伪元素 和 伪类 的概念。 伪元素建立了 对超出文档语言指定的文档树 的抽象。比如，文档语言不提供访问元素内容的 第一个字母或第一行的机制。CSS 伪元素允许样式表设计者引用通过其它方式无法访问的信息。伪元素也给样式表提供了一种方式，给源文档中不存在的内容分配样式（比如，:before 和 :after 伪元素提供了对生成的内容的访问） 伪类根据元素的特征分类，而不是名字、属性、内容。原则上这些特征无法通过文档树推断得出。伪类可能是动态的，用于与文档交互时，元素可能获取或丢失一个伪类。:first-child 是一个特例，可以根据文档树推断出来，:lang() 某些情况下也能根据文档树推断出来。 伪元素和伪类都不会出现在文档源或文档树中。 伪类允许出现在任何选择器的后面，而一个伪元素只能紧跟在选择器的最后一个简单选择器的后面。 伪元素和伪类名称不区分大小写。 有些伪类是互斥的，而其它伪类可以同时应用于同一个元素。如果规则冲突了，则结果由正常的层叠顺序决定。 5.11 伪类 5.11.1 :first-child 伪类 :first-child 伪类匹配一个元素，该元素是某个元素的第一个子级元素。 下例中，选择器匹配所有 作为 元素的第一个子级元素 的 元素。该规则禁止 中的第一个段落缩进： div > p:first-child { text-indent: 0 } 该选择器匹配下面片段中 里的 ： The last P before the note. The first P inside the note. 但不会匹配下面片段中 里的 ： The last P before the note. Note The first P inside the note. 下面的规则匹配所有 作为第一个子级元素 的 元素 的后代中的 元素： p:first-child em { font-weight : bold } 注意：因为 匿名盒子 不是文档树中的一部分，在计算 第一个子级（元素）不会对它们进行计数。 比如， 在 abc default 中是 的第一个子级元素 下列两个选择器等价： * > a:first-child /* A is first child of any element */ a:first-child /* Same */ 5.11.2 link 伪类：:link 和 :visited 用户代理通常把 未访问过的链接 和 已访问过的链接 区分显示。CSS 提供了伪类 :link 和 :visited 来区分它们： :link 伪类用于 未访问过的链接 :visited 伪类用于 已访问过的链接 UA 可能在某个时刻将 已访问过的链接 回到 未访问过的链接。 这两种状态是互斥的。 文档语言决定了哪些元素是超链接源锚点。比如，在 HTML4 中，link 伪类只适用于具有 href 属性的 元素。因此，在 CSS 2.2 中，下面声明具有相似的效果： a:link { color: red } :link { color: red } 如果下面的链接： external link 已经被访问过了，这条规则 a.external:visited { color: blue } 将让它变蓝。 注意：作者可能写样式表的时候滥用 :link 或 :visited 伪类，来确定用户已经曾访问过的的站点而不经过用户同意。 因此，UA 可以将所有链接都当作 未访问过的链接，或者在分别渲染 已访问过的链接和未访问过的链接时，采取其它措施来保护用户的隐私。 5.11.3 动态伪类：:hover、:active、:focus 交互式的用户代理有时会改变渲染（效果）以响应用户动作。CSS 针对常见情况提供了三个伪类： :hover 伪类应用于当用于指定了一个元素（用一些指针设备），但没有激活它时。比如当光标（鼠标指针）悬停在元素生成的盒子上时，可视化用户代理适用该伪类。不支持交互式媒体的用户代理不必支持该元素。某些支持交互式媒体的用户代理可能也不支持该伪类（比如，笔交互设备）。 :active 伪类应用于当一个元素被用户激活时。比如，当用户按下鼠标并释放时。 :focus 伪类应用于当一个元素拥有焦点（接受键盘事件或文本输入的其它形式）时。 一个元素可以同时匹配多个伪类。 CSS 没有定义哪些元素可以处于上述状态，以及这些状态怎样进入和离开。脚本可以改变 元素是否对用户事件做出响应，并且不同的设备和 UA 指向和激活 元素的方式可能也不相同。 CSS 2.2 没有定义 :active 或者 :hover 的父元素是不是也处于这种状态。 用户代理不必因为伪类转变而重排当前显示的文档。比如，一个样式表可以指定 :active 链接的 font-size 比非激活状态的链接的字体大，但因此这可能会导致字母在读者选中链接时改变位置，UA 可以忽略相应的样式规则。 a:link { color: red } /* unvisited links */ a:visited { color: blue } /* visited links */ a:hover { color: yellow } /* user hovers */ a:active { color: lime } /* active links */ 注意：a:hover 的规则必须放在 a:link 和 visited 的后面，否则 层叠规则 将会隐藏 a:hover 规则中的 color 属性。类似的，a:active 必须放在 a:hover 的后面，用户激活并悬停在 元素上时，将会使用 :active 激活状态下的颜色。 结合了 动态伪类 的例子： a:focus { background: yellow } a:focus:hover { background: white } 最后一个选择器匹配处于伪类 :focus和 伪类 :hover（状态）的 元素。 有关焦点轮廓的显示的信息，请查看 动态轮廓焦点 章节部分。 注意：在 CSS1 中，:active 伪类与 :link 和 :visited 是互斥的，而现在情况不一样了。一个元素可以同时处于 :visited和 :active（或者 :link和 :active），由常规层叠规则决定适用哪个样式声明。 注意：在 CSS1 中，:active 伪类只会应用于链接。 5.11.4 语言伪类：:lang 如果文档语言指定了怎样定义一个元素的人类语言（种类），就有可能用 CSS 写出选择器根据元素的语言来匹配一个元素。比如，HTML[HTML4] 中，语言是由 lang 属性， 元素以及可能的来自协议的信息（比如，HTTP 头）结合起来决定的。XML 用一个叫xml:lang 的属性和可能的其它文档特定语言的方法来确定语言。 伪类 :lang(C) 匹配语言为 C 的元素。是否存在匹配，仅由 标识符 C 是否等于元素的语言值 或者 连字符分隔元素的语言值的子字符串 来确定。同样的，就像 |= 操作符一样。对 于 ASCII 范围内的字符，C 与元素语言值的匹配过程是大小写不敏感的。标识符 C 不一定是一个合法的语言名称。 C 必须不能为空。 下列规则给一个加拿大法语或德语 HTML 文档设置引号： html:lang(fr-ca) { quotes: '« ' ' »' } html:lang(de) { quotes: '»' '«' '\\2039' '\\203A' } :lang(fr) > Q { quotes: '« ' ' »' } :lang(de) > Q { quotes: '»' '«' '\\2039' '\\203A' } 第二对规则实际上给 Q 元素根据其父级的语言设置了 quotes 属性。能这样做是因为引号是根据引号周围元素的语言选择的，而不是引号本身：比如这段英语文本中的法语 “à l'improviste” 用的是英文引号。 注意：[lang|=xx]和 :lang(xx) 的区别。在下面 HTML 示例中，只有 匹配[lang|=fr]（因为它有 lang 属性），但 和 都匹配 :lang(fr)（因为都是法语） Je suis Français. 5.12 伪元素 在 CSS 中，伪元素的行为就和真实元素的一样。但 下面描述的 以及 其它的（指的是 before-after-content 章节）例外。 注意：下面的小节没有严格定义 对 :first-line 和 :first-letter 的渲染，将来的CSS 版本可能会精确地定义它们。 5.12.1 :first-line 伪元素 :first-line 伪元素对 段落内容的第一个格式化行 适用特殊样式。比如： p:first-line { text-transform: uppercase } 上面的规则表示 \"把每个段落的第一个行的字母变成大写\"。然而，选择器 p:first-line 是不会匹配任何的真实的 HTML 元素。它匹配一个伪元素，该元素符合用户代理的话，将会在每个段落的开头插入。 注意：第一行的长度取决于许多因素，包括 页面宽度、字体大小 等。因此，一个段落原始可能是这样子： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. 其中可能有几行变成这样： THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. :first-line 可能会被用户代理重写成 含有虚拟标签序列的形式，这种虚拟标签序列有利于展示属性的继承方式： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. 如果伪元素把一个真实元素给拆开了，想要的效果是由 虚拟标签序列 闭合再重新打开该元素。因此如果我们用一个 元素标记之前的段落： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. 在给 :first-line 插入 虚拟标签序列 时，用户代理会为 模拟开始和结束标签： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. :first-line 伪元素只适用于 块容器元素。 元素的 \"第一个格式化行\" 可能 出现在 相同流（原因：the same flow）中的一个块级后代（即一个没有被定位且不浮动的块级后代）里面。比如，This line...中 的第一行是 的第一行（假设 和 都是块级的）。 表格单元格或行内块元素的第一行不能作为祖先元素的第一个格式化行。因此，在 HelloGoodbye etcetera 中， 的第一个格式化行不是 \"Hello\"， 注意：First... 中 的第一行不包含任何字母（假设是HTML4中 默认样式表）。单词 \"First\" 不在第一个格式行内。 UA 应该表现的就像 :first-line 伪元素的虚拟开始标签嵌套 在 最内层的闭合块级元素 中（因为 CSS1 和 CSS2 都没有说明这种情况，作者不应该依赖这种行为），比如： First paragraph Second paragraph 对应的虚拟标签序列为： First paragraph Second paragraph :first-line 伪元素 与 行内级元素 类似，但有一些限制。下列属性适用于 :first-line 伪元素：font、color、background、word-spacing、letter-spacing、text-decoration、text-transform、line-height。UA 还可能应用其它属性。 5.12.2 :first-letter 伪元素 :first-letter 伪元素必须选择一个块的第一行的第一个字母，如果这一行中在它前面没有跟着任何其它内容（比如，图片或者 inline table）的话。:first-letter 伪元素可以用于 \"首字母大写（initial caps）\" 和 \"首字母下沉（drop caps）\" 之类的常见排版效果。此类首字母与 float 属性为 none 的 行内级元素类似，否则就与 浮动元素 类似。 适用于 :first-letter 伪元素的属性有：font、text-decoration、text-transform、letter-spacing、word-spacing（在适当的时候），line-height、float、vertical-align（仅当 float 为 none 时），margin、padding、border、color、background。 UA 还可能会应用其它规则。为了让UA 正确渲染 首字母下沉 或者 首字母大写 排版，UA 可以根据字母的形状选择行高、宽度和高度，这与 常规元素（normal elements）不同。预期 CSS3 会有适用于首字母的具体属性。 下例展示了首字母大写渲染，注意，:first-letter 伪元素继承的 line-height 是 1.1，但例子中 UA 特别计算了首字母的高度，因此它不会导致前两行之间有任何不必要的空隙。还要注意，首字母的虚拟开始标签在 里面，因此首字母的字重是正常的，而不是和 一样的粗体： p { line-height: 1.1 } p:first-letter { font-size: 3em; font-weight: normal } span { font-weight: bold } ... Het hemelsche gerecht heeft zich ten lange lesten Erbarremt over my en mijn benaeuwde vesten En arme burgery, en op mijn volcx gebed En dagelix geschrey de bange stad ontzet. 下列 CSS2.2（规则）将会让首字母下沉大约两行： Drop cap initial letter p { font-size: 12pt; line-height: 1.2 } p:first-letter { font-size: 200%; font-style: italic; font-weight: bold; float: left } span { text-transform: uppercase } The first few words of an article in The Economist. 可能被格式化成这样： 虚拟标签序列为： T he first few words of an article in the Economist. 注意：:first-letter 伪元素（虚拟）标签挨着内容（content）（即首字母），而 :first-line 伪元素的开始标签紧跟在 块元素开始标签之后。 为了达到传统首字母下沉的格式化效果，用户代理可以用近似字体大小，比如为了对齐基线。另外，在格式化时，还可能会把字形轮廓考虑在内 （:first-letter 伪元素）应该包括紧跟在首字母前后的标点符号（即用 Unicode 定义的 \"open\" (Ps)、\"close\" (Pe)、\"initial\" (Pi)、\"final\" (Pf)和 \"other\" (Po)标点类字符），比如： 如果首字母是数字的话，:first-letter 伪元素也同样适用，例如，\"67 million dollars is a lot of money.\" 中的 \"6\"。 :first-letter 伪元素适用于块容器元素。 :first-letter 伪元素可以用于所有含有文本的元素或者相同流（the same flow）中有含有文本的后代（元素）。UA 应该表现得像 :first-letter 伪元素的虚拟开始标签恰好在该元素的第一块文本内容之前，即使第一块文本内容位于后代元素中。 比如，此 HTML 片段： The first text. 对应的的虚构标记序列： The first text. 表格单元格或行内块元素的首字母不能作为祖先元素的首字母。因此，在 HelloGoodbye etcetera 中， 的首字母不是字母 \"H\"，实际上，该 没有首字母。 首字母必须出现在 第一个格式化行 中，比如，片段 First... 中，第一行没有任何字母，那么 :first-letter 伪元素 不会匹配任何东西（假设是 HTML4 中 的默认样式）。这种情况下，它也不会匹配 \"First\" 的 \"F\"。 如果一个元素是列表项（display: list-item），则 :first-letter 伪元素将应用于标记后的 主盒子（principal box）中的第一个字母。UA 可能忽略具有 list-style-position: inside 的列表项上的 :first-letter 的规则。如果一个元素 具有 :before 或者 :after 内容，:first-letter 伪元素应用于包含该内容的元素的第一个字母。 比如，声明 p:before {content: \"Note: \"} 规则后，选择器 p:first-letter 会匹配 \"Note\" 的 \"N\"。 有些语言可能有 关于怎样对待特定字母组合 的具体规则，在荷兰，比如，如果字母组合 \"ij\" 出现在单词开头，这两个字母应该都属于 :first-letter 伪元素。 如果将要作为第一个字母的字母不在同一个元素中，例如 'T...中的 \"'T\"，UA 可能会从中取一个元素创建 :first-letter 伪元素，或者都给创建伪元素，或者干脆不创建伪元素。 类似的，如果块的首字母不在行的开头（比如，由于双向重排序（bidirectional reordering）），那么 UA 不需要创建该伪元素。 下例描述了伪元素互相重叠的情况。 元素的首字母将是绿色的，字体大小为 '24pt'。第一个格式化行的其余部分将是 'blue'，而段落的其它部分将是 'red'： p { color: red; font-size: 12pt } p:first-letter { color: green; font-size: 200% } p:first-line { color: blue } Some text that ends up on two lines 假设一个 行结束符 将出现在单词 \"ends\" 之前，该片段的虚拟标签序列可能是： S ome text that ends up on two lines 注意：:first-letter 伪元素在 :first-line 伪元素里面。设置在 :first-line 上的属性被 :first-letter 继承了，而且如果设置的是 :first-letter 的相同属性，则会被重写。 5.12.3 :before 和 :after 伪元素 :before 和 :after 伪元素可以用来在 一个元素的内容 之前或之后插入 生成的内容，在 生成文本 章节中有解释。 h1:before {content: counter(chapno, upper-roman) \". \"} 当 :first-letter 和 :first-line 伪元素被应用在一个具有使用 :before 和 :after 生成内容 的元素，它们适用于元素 包括生成的内容在内 的首字母或首行： p.special:before {content: \"Special! \"} p.special:first-letter {color: #ffd800} 将会把 \"Special!\" 的 \"S\" 渲染成金色。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-11-18 16:19:49 "},"docs/CSS/CSS2.2/6 分配属性值、层叠、继承.html":{"url":"docs/CSS/CSS2.2/6 分配属性值、层叠、继承.html","title":"6 分配属性值、层叠、继承","keywords":"","body":"6 分配属性值、层叠、继承 6.1 指定值、计算值、实际值（Specified, computed, and actual values） 一旦用户代理解析了文档并构建了文档树，它就必须为树中的每个元素分配一个值，该值应用于每个属性，这些属性都适用于目标媒体类型。 属性的最终值（final value）是四步计算的结果： 开始，该值通过规范指定，此时为 指定值（specified value） 然后，解析用于继承的值，此时为 计算值（computed value） 然后，转换成绝对值（如果有必要），此时为 应用值（used value） 最后，根据本地的环境进行变换得到的值，此时为 实际值（actual value） 6.1.1 指定值（Specified values） 用户代理必须首先根据一下机制为每个属性属性分配指定的值（按优先顺序排列）： 如果层叠产生了值，就使用它 否则，如果属性是继承的并且该元素不是文档树的根元素，使用其父元素的计算值 否则使用属性的初始值。每个属性的初始值在属性的定义中指出了。 6.1.2 计算值（Computed values） 指定值通过层叠被计算成了计算值，比如 URL 被解析成绝对的，em 和 ex 单位被计算为像素或者绝对长度。计算一个值永远不需要用户代理呈现文档。 UA 无法处理为绝对 URI 的话，该 URI 的计算值就是指定值。 一个属性的计算值由属性定义中 \"Computed Value\" 行决定。当指定值为 inherit 时，计算值的定义见继承小节。 即使属性不适用（当前元素），其计算值也存在，定义在 \"Applies To\" 行。然而，有些属性可能根据属性是否适用于该元素来定义元素属性的计算值。 6.1.3 应用值（Used values） 在不格式化文档的情况下尽可能地处理计算值。但是，有些值只能在文档布局完成时确定。比如，如果一个元素的宽度是其包含块的特定百分比，在包含块的宽度确定之前无法确定这个宽度。应用值是获取计算值，并将其剩余的依赖（值）都处理成绝对值后的结果。 6.1.4 实际值（Actual values） 原则上，应用值应该用于渲染，但用户代理可能无法在给定的环境中使用该值。比如，用户代理可能只能使用整数像素宽度渲染边框，因此不得不对宽度的计算值做近似处理，或者用户代理被迫只能用黑白色调而不是全彩色。实际值是经过近似处理后的应用值。 6.2 继承（Inheritance） 如上所述，某些值由文档树中元素的子元素继承。 每个属性都定义了它是否可继承的。 假设 H1 元素里有个强调元素(EM)： The headline is important! 如果没有给 EM 元素赋值颜色，强调的 \"is\" 将从其父元素继承颜色，所以如果 H1 是蓝色的，EM 元素同样也将是蓝色的。 发生继承时，元素继承计算值。来自父元素的计算值同时作为指定值和其子元素的计算值。 比如，给出如下样式表： body { font-size: 10pt } h1 { font-size: 130% } 和文档片段： A large heading H1 元素的 font-size 属性将获得计算值 \"13pt\"（130% 乘以父元素的值 10pt）。因为 font-size 的计算值是继承的，EM 元素也将获得计算值 \"13pt\"。如果用户代理没有可用的 13pt 字体，H1 和 EM 的 font-size 的实际值可能是，比如，\"12pt\"。 注意：继承遵循文档树并且不会被匿名盒子截断 6.2.1 inherit 值 每个属性也可能有一个 inherit 层叠值，这意味着，对于一个给定的元素，属性采用与其父元素属性相同的指定值。inherit 值可以用来实现值的继承，并且它也可以用在那些一般不是继承的属性上。 如果 inherit 值设置在根元素上，该属性会被赋值为其初始值。 下例中，color 和 background 属性被设置在 BODY 元素上。对于其它所有元素，color 值都将被继承并且背景将是透明的。如果这些规则是用户样式表的一部分，整个文档都将是白色背景上的黑色文本。 body { color: black !important; background: white !important; } * { color: inherit !important; background: transparent !important; } 6.3 @import 规则 @import 规则允许用户从其他样式表导入样式规则。在 CSS 2.2 中，任何 @import 规则必须在其他规则之前（除了 @charset，如果有的话）。关于用户代理什么情况下必须忽略 @import 规则，见 解析 章节。@import 关键字后面必须跟着想要引入的样式表的 URI。字符串也可以接受，也可以是 url(...) 形式。 下面这几行在意义上是等价的，都描述了 @import 语法（一个有 url(...)，另一个是字符串）： @import \"mystyle.css\"; @import url(\"mystyle.css\"); 为了让用户代理能够避免为不支持的媒体类型检索资源，作者可以指定带媒体依赖的 @import 规则。这种条件引入在 URI 后面指定了逗号分隔的媒体类型。 下列规则描述了 @import 规则怎样带媒体依赖的： @import url(\"fineprint.css\") print; @import url(\"bluish.css\") projection, tv; 在没有任何媒体类型的情况下，引入是无条件的，与把媒体指定为 all 效果一样。仅当目标媒体与媒体列表匹配时，导入才会生效。 如果媒体列表中有一项是目标媒体或者 all时，目标媒体匹配媒体列表。 注意：媒体查询[MEDIAQ]扩展了媒体列表的语法和匹配的定义。 引入相同样式表或者在多处链接同一文档时，用户代理必须处理（或者表现得像那样）每一个链接，就像链接都指向一个单独的样式表一样。 6.4 层叠（The cascade） 样式表可能有三个不同的来源：作者（author）、用户（user）和用户代理（user agent）。 作者：作者根据文档语言的约定编写源文档的样式表。比如，样式表可以包含在文档中或外部链接。 用户：用户可能会为特定的文档指定样式信息。用户可以指定包含样式表的文件，或者用户代理可以提供生成 用户样式表 的界面（或者表现得像这样做了一样）。 用户代理：用户代理必须应用 默认样式表（或者表现像用了一样）。用户代理的默认样式表应该以满足文档语言所期望的一般展现方式去 呈现 文档语言的元素（比如，对于可视浏览器， 应该以斜体呈现）。有关 HTML 文档的默认样式表的建议，请参阅 HTML 的示例样式表。 注意：用户可以修改系统设置（比如，系统颜色）以此来影响默认样式表。但是某些用户代理实现使得无法更改默认样式表的值。 三个来源的样式表将在一定范围内进行重叠，并且根据 层叠 进行交互。 CSS 层叠为每个样式规则都分配了权重。当适用多个规则时，权重最大的规则优先。 默认情况下，作者样式表的规则比用户样式表的规则更重要。然而，对于 !important 规则，优先顺序是相反的。所有用户和作者的规则都比 UA 默认样式表中的规则更重要。 6.4.1 层叠顺序（Cascading order） 要找出 元素/属性 组合的值，用户代理必须使用以下顺序排序： 查找出 适用于目标媒体类型的相关元素和属性 所有声明。如果 关联的选择器 与 相关元素匹配，且 目标媒体 与 包含声明的所有 @media 规则上的媒体列表 以及 样式表上路径的所有链接 匹配，则声明适用。 根据 重要性(normal or important) 和 来源（作者、用户、用户代理）进行排序。在层叠中的优先级顺序，按升序排列： 用户代理声明（原：user agent declarations） 用户常规声明（原：user normal declarations） 作者常规声明（原：author normal declarations） 作者重要声明（原：author important declarations） 用户重要声明（原：user important declarations） 通过 选择器的特殊性 对具有 相同重要性和来源 进行排序的规则： 更具体（注：可理解为特殊）的规则将覆盖更一般的选择器 伪元素 和 伪类 分别都计算为 常规元素 和 类。 最后，按指定的顺序进行排序： 如果两个声明具有相同的权重、来源和特殊性，则后者指定的获胜。 引入样式表（指：@import）中的声明被认为是在样式表本身中的任何声明之前。 除了给个别声明的 !important 外，比起用户样式表，这种策略给了作者样式表更多的权重。用户代理必须给予用户 去除特定作者样式表影响 的能力。 6.4.2 !important 规则 CSS 尝试在 作者 和 用户 之间建立权力平衡。默认情况下，作者样式表中的规则会覆盖用户样式表中的规则（见 层叠规则3）。 但是，为了平衡，!important 声明（分隔符 ! 和关键字 important遵循声明）优先于 常规声明。作者和用户样式表都可能包含 !important 声明，而 用户 !important 规则会覆盖作者 !important 规则。此 CSS 特性能通过满足用户的特殊要求（大字体，颜色组合等）来控制演示，从而提高了文档的访问性。 声明 一个简写属性（如 background） 为 !important 等同于将所有子属性声明为 !important。 下例中用户样式表的第一条规则含有一个 !important 声明，重写了作者样式表中的相关声明。第二条声明也将生效，因为被标记为 !important 了。然而，用户样式表中的第三条规则不是 !important，因此被作者样式表（恰好在简写属性上设置了）中的第二条规则重写了。而且，第三条作者规则将被第二条作者规则重写，因为第二条规则是 !important。这说明 !important 声明在作者样式表中也有效 /* From the user's style sheet */ p { text-indent: 1em ! important } p { font-style: italic ! important } p { font-size: 18pt } /* From the author's style sheet */ p { text-indent: 1.5em !important } p { font: normal 12pt sans-serif !important } p { font-size: 24pt } 6.4.3 计算选择器的特殊性 选择器的特殊性由以下规则计算： 如果声明是来自 style 属性（原：attribute）而不是一个带选择器的规则，则为 1，否则就为 0（=a）（在 HTML 中，元素 style 属性（原：attribute）的值是样式表规则，这些规则没有选择器，所以 a=1,b=0,c=0,d=0） 计算选择器中 ID 属性（原：attribute）的数量（=b）。 计算选择器中 其它属性和伪类 的数量（=c）。 计算选择器中 元素名称和伪元素 的数量 (=d)。 特殊性只根据选择器的形式来决定。特殊地，一个 \"[id=p33]\" 形式的选择器被计算为一个属性选择器(a=0,b=0,c=1,d=0)，即使 id 属性在源文档的 DTD 中被定义为 \"ID\"。 4 个数字连起来 a-b-c-d（在一个基数很大的数字系统中）表示其特殊性。 一些示例： * {} /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */ li {} /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */ li:first-line {} /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */ ul li {} /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */ ul ol+li {} /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */ h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */ ul ol li.red {} /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */ li.red.level {} /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */ #x34y {} /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */ style=\"\" /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */ #x97z { color: red } 上面的示例中，P 元素的颜色将是绿色，\"style\" 属性中的声明将重写 STYLE 元素中的，因为层叠规则3，它的特殊性更高。 6.4.4 非 CSS 表现型提示的样式优先级 UA 可能选择尊重 HTML 源文档中的表现型属性。如果是这样，这些属性将会被转换为 CSS 规则的特殊性为 0，并被当作是在 作者样式表 的开头插入它们。因此，它们可能会被后续的样式表规则所重写。在过渡阶段，这种策略让表现型属性更容易与样式表共存。 对于 HTML，不应将以下列表中的任何属性视为表现型属性：abbr, accept-charset, accept, accesskey, action, alt, archive, axis, charset, checked, cite, class, classid, code, codebase, codetype, colspan, coords, data, datetime, declare, defer, dir, disabled, enctype, for, headers, href, hreflang, http-equiv, id, ismap, label, lang, language, longdesc, maxlength, media, method, multiple, name, nohref, object, onblur, onchange, onclick, ondblclick, onfocus, onkeydown, onkeypress, onkeyup, onload, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup, onreset, onselect, onsubmit, onunload, onunload, profile, prompt, readonly, rel, rev, rowspan, scheme, scope, selected, shape, span, src, standby, start, style, summary, title, type (except on LI, OL and UL elements), usemap, value, valuetype, version。 对于其它语言，所有基于文档语言的样式必须被转换为相应的CSS，并且要么在用户代理的层叠中，要么与 HTML 表现型提示一起被当作特殊性为 0 的作者级别规则放在作者样式表开头 下列用户样式表将会重写所有文档中 b 元素的字重，以及 XML 文档中具有 color 属性的 font 元素的颜色。它将不会影响 HTML 文档中任何具有 color 属性的 font 元素的颜色(译注：实际上，在 HTML 里这个样式对有 color 属性的 font元素 也是有效的。但一致性章节有声明 “示例和注意事项是非规范的”，这里是示例)： b { font-weight: normal; } font[color] { color: orange; } 然而，下面的（样式表）将会重写所有文档中 font 元素的颜色： font[color] { color: orange ! important; } Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/7 媒体类型.html":{"url":"docs/CSS/CSS2.2/7 媒体类型.html","title":"7 媒体类型","keywords":"","body":"7 媒体类型 7.1 媒体类型简介 样式表最重要的特征之一是它们指定文档在不同媒体的呈现方式：屏幕上，纸上，语音合成设备，盲文设备等。 某些 CSS 属性仅针对特定媒体设计（比如，page-break-before 属性仅适用于 paged media）。但是有时候，不同媒体类型的样式表可能共享一个属性，但需要该属性的不同值。比如，font-size 对于 屏幕媒体 和 打印媒体 就都有用。两种媒体类型的不同要求共同属性使用不同的值，文档在计算机屏幕上通常要比在纸上的字体更大。因此有必要使用样式表或样式表的一部分适用于某些媒体类型。 7.2 指定与媒体相关的样式表 目前有两种方式可以为样式表指定媒体依赖关系： 使用 @media 或 @import 的规则从样式表中指定目标媒介 @import url(\"fancyfonts.css\") screen; @media print { /* style sheet for print goes here */ } 在文档语言中指定目标媒体 Link to a target medium The body... @import 规则在 层叠 章节中定义。 7.2.1 @media 规则 @media 规则指定 一组语句（由花括号分隔）的目标媒体类型（以逗号分隔）。非法语句会被忽略调。@media 允许在同一样式表中指定各种媒体的样式表规则： @media print { body { font-size: 10pt } } @media screen { body { font-size: 13px } } @media screen, print { body { line-height: 1.2 } } @media 规则之外的样式规则 适用于 样式表适用的所有媒体类型。 7.3 认可的媒体类型（Recognized media types） 给 CSS 媒体类型选择的名称反映了 相关属性有意义的 目标设备。在以下 CSS 媒体类型列表中，媒体类型的名称是规范的，但描述信息是信息性的。同样，每个属性的描述中的 media 字段是提供信息的。 all：适用于所有设备 braille：适用于盲人触觉反馈设备 embossed：适用于分页盲文打印机 handheld：适用于手持设备（通常为小屏幕，有限带宽） print：适用于 分页材料 和在打印预览模式下在屏幕上查看的文档。有关 分页媒体 的部分 请参考 分页媒体 章节 projection：适用于投影展示，比如投影机。有关 分页媒体 的部分 请参考 分页媒体 章节 screen：适用于彩色电脑屏幕 speech：适用于语音合成器。注意：CSS 2.2 有一个媒体类型叫 aural tty：适用于固定间距字符网格的媒体类型（比如电视、终端、具有有限显示功能的便携式设备） tv：适用于电视类设备（低分辨率，彩色，有限滚动屏幕，可用声音） 媒体类型不区分大小写。 用户代理在渲染文档时支持一种媒体类型时，此时媒体类型之间是互斥的。但是用户代理可以在不同的画布上使用不同的媒体类型。比如，文档可以（同时）在一个画布上以 screen 模式显示，在另一个画布上以 print 模式显示。 注意：多模式媒体类型仍然只是一种媒体类型。比如，tv 媒体类型是一种多模式媒体类型，在单个画布上可以在 视觉上 和 听觉上 呈现单个。 带有未知媒体类型的 @media 和 @import 规则（仍然是有效标识符）被视为不存在未知媒体类型。如果 @medida 和 @import 规则包含格式错误的媒体类型（不是标识符），则该语句失效。 注意：CSS 在未来更新中可能会引入新的媒体类型。 7.3.1 媒体集（Media groups） 本节内容不具有规范性。 每个 CSS 属性定义 都会指定 属性适用的媒体类型。由于属性通常适用于多种媒体类型，因此每个属性定义的 适用媒体（Applies to media） 会列出媒体集而不是单个媒体类型。每个属性都适用于其定义的 媒体集 里的所有媒体类型。 CSS 2.2 定义了以下媒体集： 连续或分页（原：continuous or paged） 视觉、听觉、语音、触觉（原：visual, audio, speech, or tactile） 网格（用于网格字符设备）或位图（原：grid (for character grid devices), or bitmap） 互动式（用于允许用户交互的设备）或静态（用于不允许用户交互的设备）（原：interactive (for devices that allow user interaction), or static (for those that do not)） 全部（包含所有媒体类型）（原：all (includes all media types)） 下面表格表示了媒体集和媒体类型之间的关系： Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/8 盒子模型.html":{"url":"docs/CSS/CSS2.2/8 盒子模型.html","title":"8 盒子模型","keywords":"","body":"8 盒子模型 CSS 盒子模型描述了一个 为文档树中的元素生成的 矩形盒子，该盒子并根据视觉格式化模型布局。 8.1 盒子尺寸 每个盒子具有 内容区域（原：content area）（比如文本、图像等）和周围可选的 填充区域（原：padding area）、边框区域（原：border area）、外边距区域（原：margin area）），每块区域的大小由下面定义的属性指定。下图显示了这些区域怎么关联的和以及用于引用 外边距、边框、填充的术语： 外边距、边框、填充可以分为 top、right、bottom、left 区段（比如 LM 代表左外边距、RP 代表右填充、TB 代表上边框）。 四块区域（content、padding、border、margin）中的每一块的界限称为 边缘（原：edge），因此每个盒子有四条边缘： 内容边缘或内边缘（原：content edge or inner edge） 内容边缘环绕着由 盒子的宽度（原：width）和 高度（原：height）给出的矩形，这通常取决于元素呈现的内容。四个 内容边缘 定义了盒子的 内容盒子（原：content box）。 填充边缘（原：padding edge） 填充边缘 围绕着 盒子的填充（区域）。如果填充的宽度为 0，则填充边缘与内容边缘相同。四个 填充边缘 定义了盒子的 填充盒子（原：padding box）。 边框边缘（原：border edge） 边框边缘 围绕着 盒子的边框（区域）。如果边框的宽度为 0，则边框边缘与填充边缘相同。四个边框边缘 定义了盒子的 边框盒子（原：border box）。 外边距边缘或外边缘（原：margin edge or outer edge） 外边距边缘 围绕着 盒子的外边距（区域）。如果外边距的宽度为 0，则外边距边缘与边框边缘相同。四个外边距边缘 定义了盒子的 外边距盒子（原：margin box）。 每个（围绕着的）边缘都可以被细分为 top、right、bottom、left。 一个盒子的 内容区域 的尺寸 - 内容宽度（原：content width）和内容高度（原：content height）- 取决于几个因素： 生成该盒子的元素是否设置了 width 或 height 属性 该盒子是否包含 文本 或 其它盒子 盒子是否是 table ... 盒子的宽度和高度在 视觉格式化模型细节 中有详细讲解。 盒子的 内容区域、填充区域、边框区域 的背景样式 由生成（该盒子）的元素的 background 属性指定。外边距区域 的背景总是 透明的（transparent）。 8.2 案例：外边距、填充、边框 本例描述了 外边距、填充、边框 之间的相互影响。案例分析： Examples of margins, padding, and borders ul { background: yellow; margin: 12px 12px 12px 12px; padding: 3px 3px 3px 3px; /* No borders set */ } li { color: white; /* text color is white */ background: blue; /* Content, padding will be blue */ margin: 12px 12px 12px 12px; padding: 12px 0px 12px 12px; /* Note 0px padding right */ list-style: none /* no glyphs before a list item */ /* No borders set */ } li.withborder { border-style: dashed; border-width: medium; /* sets border width on all sides */ border-color: lime; } First element of list Second element of list is a bit longer to illustrate wrapping. 结果是产生了一个拥有 2 个 孩子的 元素的文档树（文档树中还有其它关系）。 第一幅图中描述本例产生的结果。第二幅图描述了 元素的 外边距、填充、边框 和它的 元素的这些属性之间的关系（图像不是按比例给出）。 注意： 每个 盒子的 content width 是自顶向下计算的，每个 盒子的包含块由 元素建立的。 每个 盒子的 外边距盒子 的高度取决于其 content height、以及上下的填充、上下的边框、上下的外边距。 盒子之间的 垂直外边距 合并了。 每个 盒子的右填充区域被设置为 0 宽度（padding 属性）。第二幅图中效果就很明显。 每个 盒子的 margin 是透明的—外边距总是透明的。因此， 盒子的填充和内容区域的背景色（yellow）透出来了。 第二个 盒子指定了虚线边框（border-style 属性）。 8.3 外边距属性：margin-top、margin-right、margin-bottom、margin-left、margin 外边距属性指定了一个盒子的 外边距区域 的宽度。margin 这个简写属性可以设置 外边距的四边，而其它外边距属性只能设置一边。 这些属性适用于所有元素，但对 行内非替换元素 的垂直外边距不会产生任何效果。 本节定义的属性参考 的值类型，可以采用以下值之一： ：指定一个固定的宽度。 ：百分比是根据 生成的盒子的包含块的 宽度 计算的。请注意，对于 margin-top 和 margin-bottom 也是如此。如果包含块的宽度取决于该元素，则产生的布局在 CSS 2.2 中没有定义。 auto：请查阅 10.3 允许外边距为负值，但可能存在具体实现限制。 关键信息摘要： 属性名称：margin-top, margin-bottom 值： | inherit 初始值：0 适用元素：all elements except elements with table display types other than table-caption, table and inline-table（除 display 类型为 table 系列中除了 table-caption、table和 inline-table 以外的所有元素（译注：也就是说，table 系列 display 值中，margin-* 只适用于 table-caption、table、inline-table，其余的都不适用，但 margin-* 对 非table 系列都适用）） 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：指定的百分比或者绝对长度 注意：这些属性对 行内非替换元素 没有影响。 关键信息摘要： 属性名称：margin-right, margin-left 值： | inherit 初始值：0 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：指定的百分比或者绝对长度 关键信息摘要： 属性名称：margin 值：{1,4} | inherit 初始值：see individual properties 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：见单独的各个属性 margin 属性是 margin-top、margin-right、margin-bottom、margin-left 的简写属性。 只有一个值时，则应用于四个属性 只有两个值时，则 margin-top 和 margin-bottom 为第一个值，margin-left 和 margin-right 为第二个值 只有三个值时，则 margin-top 为第一个值，margin-left 和 margin-right 为第二个值，margin-bottom 为第三个值 只有四个值时，则 margin-top 为第一个值，margin-right 为第二个值，margin-bottom 为第三个值，margin-left 为第四个值 8.3.1 合并外边距（Collapsing margins） 在 CSS 中，两个或多个盒子（可能是兄弟也可能不是兄弟）的相邻的 margin 会被结合成一个 margin。外边距按这种方式结合叫做合并（collapse），产生的结合的外边距叫做折叠外边距（collapsed margin 译注：这里译作折叠表示结果，与合并的动作区分开）。 相邻的垂直外边距会合并，除了： 根元素盒子的 margin 不合并。 如果一个带有间隙（clearance 译注：是指 clear 属性导致元素位置移动形成的间隙）的元素的上外边距与下外边距相邻，它的外边距会和紧挨着的兄弟（元素）的相邻外边距合并，但合并后不会再和父级块的下外边距合并。 水平外边距永不合并。 两个 margin 是相邻的，当且仅当： 都属于 流内（in-flow）的块级盒子，处于同一个 块格式化上下文（BFC）。 没有行盒子、没有间隙（clearance）、没有填充、没有边框把它们隔开（注意：为此目的，忽略某些零高度盒子）。 都属于垂直相邻盒子边缘，即形成下列某一对： 盒子的上外边距与其第一个流内 孩子 的外边距 盒子的下外边距与下一个流内 紧挨着的兄弟 的上外边距 最后一个流内 孩子的下外边距与其 height 计算值为 auto 的父元素的下外边距 盒子的上外边距和下外边距，要求该盒子没有建立新的块格式化上下文，并且 min-height 计算值为 0，height计算值为 0 或 auto，还没有流内孩子。 折叠外边距也能与另一个外边距相邻，只要其外边距的任意一部分与那个外边距相邻就算。 注意： 相邻外边距也可以由不具有 兄弟或祖先 元素的关系 的元素生成。 注意，上面的规则说明： 浮动盒子与其它任意盒子的 margin 不会合并（甚至一个浮动盒子与它的 流内子元素 之间也不会）。 建立了新的 块格式化上下文 的元素（比如，浮动盒子与 overflow 不为 visible 的元素）的 margin 不会与它们的 流内子元素 合并。 绝对定位盒子的 margin 不会合并（甚至与它们的 流内子元素 也不会）。 inline-block 盒子的 margin 不会合并（甚至与它们的 流内子元素 也不会）。 流内 块级元素的 margin-bottom 总会与 它的 下一个流内块级兄弟的 margin-top 合并。除非该兄弟元素具有 间隙（clearance）。 流内 块级元素的 margin-top 总会与 它的 第一个流内块级子元素的 margin-top 合并，条件是该元素没有 border-top、没有 padding-top、且其孩子（the child）没有 间隙。 一个 height 为 auto 且 min-height 为 0 的 流内块级盒的 margin-bottom 会与它的 最后一个流内块级子（盒子） 的 margin-bottom 合并，条件是该盒子没有 border-bottom、没有 padding-bottom、且其孩子的 margin-bottom 没有与 具有 间隙 的 margin-top 合并。 盒子自身的外边距也会合并，条件是 min-height 属性值为 0、既没有 padding-top || padding-bottom 也没有 border-top || border-bottom、height 属性值为 0 或 auto，且没有 行盒子，那么其所有流内 孩子 的外边距（若存在）都会合并。 当两个或更多的 margin 合并时，产生的 margin 的宽度为 被合并的 外边距宽度 的最大值。对于 负 margin，就从 (正相邻 margin 的最大值) 减去 (负相邻 margin 绝对值 的最大值)。如果没有 正 margin，就用 0 减去 相邻 margin 的绝对值 的最大值。 如果盒子的上下外边距相邻，那么外边距合并可能会穿过它。这种情况下，该元素的位置取决于 它 与 其它外边距被合并了的元素 的关系。 如果该元素的外边距（margin）与其父元素的上外边距（margin-top）合并了，盒子的 上边框边缘 被定义为与其父元素的相同。 否则，要么该元素的父元素没参与 外边距合并，要么只涉及其父元素的下外边距（margin-bottom）。该元素 上边框边缘 的位置与元素下边框 非 0 时的位置相同。 注意：被折叠外边距穿过的元素 的位置 不影响 其它外边距正要被合并 的元素的位置，其 上边框边缘的位置 仅用于布局 这些元素的后代元素。 8.4 填充属性：padding-top、padding-right、padding-bottom、padding-left、padding 填充属性指定了一个盒子的 填充区域 的宽度。padding 这个简写属性可以设置 填充区域的四边，而其它填充属性只能设置一边。 本节定义的属性参考 的值类型，可以采用以下值之一： ：指定一个固定的宽度。 ：百分比是根据生成的盒子的 包含块的宽度 计算的。请注意，对于 padding-top 和 padding-bottom 也是如此。如果包含块的宽度取决于该元素，则产生的布局在 CSS 2.2 中没有定义。 不允许 padding 为负值。 关键信息摘要： 属性名称：padding-top, padding-right, padding-bottom, padding-left 值： | inherit 初始值：0 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：指定的百分比或者绝对长度 关键信息摘要： 属性名称：padding 值：{1,4} | inherit 初始值：see individual properties 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：见单独的各个属性 padding 属性是 padding-top、padding-right、padding-bottom、padding-left 的简写属性。 只有一个值时，则应用于四个属性 只有两个值时，则 padding-top 和 padding-bottom 为第一个值，padding-left 和 padding-right 为第二个值 只有三个值时，则 padding-top 为第一个值，padding-left 和 padding-right 为第二个值，padding-bottom 为第三个值 只有四个值时，则 padding-top 为第一个值，padding-right 为第二个值，padding-bottom 为第三个值，padding-left 为第四个值 填充区域的 表面颜色或图像 通过 background 属性指定： h1 { background: white; padding: 1em 2em; } 上例指定了 '1em' 的垂直填充区域（padding-top 和 padding-bottom）和 '2em' 的水平填充区域（padding-right 和 padding-left）。em 单位与当前元素的字体大小有关：'1em' 等于当前所用字体的大小。 8.5 边框属性（Border properties） 边框属性指定了一个盒子的 边框区域 的宽度。border 这个简写属性可以设置 边框区域 的四边，而其它边框属性只能设置一边。 注意：对于 HTML，用户代理可能为某些用户界面元素渲染边框区域，不同于 \"普通\" 的元素。 8.5.1 边框宽度：border-top-width、border-right-width、border-bottom-width、border-left-width、border-width 边框宽度 属性指定了一个盒子的 边框区域 的宽度。该属性定义了 的值类型，可取下列值之一： thin：细边框 medium：中等边框 thick：粗边框 ：边框的粗细有固定值且不能为负 前三个值的解释由用户代理定义，但必须保持以下关系：'thin' 。 关键信息摘要： 属性名称：border-top-width、border-right-width、border-bottom-width、border-left-width 值： | inherit 初始值：medium 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：绝对长度；'0'，如果 border-style 为 none 或 hidden 关键信息摘要： 属性名称：border-width 值：{1,4} | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border-width 属性是 border-top-width、border-right-width、border-bottom-width、border-left-width 的简写属性。 只有一个值时，则应用于四个属性 只有两个值时，则 border-top-width 和 border-bottom-width 为第一个值，border-right-width 和 border-left-width 为第二个值 只有三个值时，则 border-top-width 为第一个值，border-left-width 和 border-right-width 为第二个值，border-bottom-width 为第三个值 只有四个值时，则 border-top-width 为第一个值，border-right-width 为第二个值，border-bottom-width 为第三个值，border-left-width 为第四个值 8.5.2 边框颜色：border-top-color、border-right-color、border-bottom-color、border-left-color、border-color 边框颜色 属性指定了一个盒子的 边框（区域）的颜色。 关键信息摘要： 属性名称：border-top-color、border-right-color、border-bottom-color、border-left-color 值： | transparent | inherit 初始值：color 属性的值 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：当从 color 属性取值的话，取 color 的计算值。否则，就和指定值一样。 关键信息摘要： 属性名称：border-width 值：[ | transparent ]{1,4} | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border-color 可以一次性设置 4 条边框的颜色。值含义如下： ：指定一个颜色值 transparent：边框是透明的（尽管可能具有宽度） border-color 属性也有 1 到 4 个值，并且值可以用来设置不同方向的颜色，同 border-width。 如果一个元素没有用 border 属性指定 border-color，用户代理则必须把该元素的 color 属性作为 border-color 的计算值。 下例中，border 将是黑色： p { color: black; background: white; border: solid; } 8.5.3 边框风格：border-top-style、border-right-style、border-bottom-style、border-left-style、border-style 边框风格 属性指定了一个盒子的 边框（区域）的线条风格（实线、双实线、虚线等等）。 该属性定义了 的值类型，可取下列值之一： none：无边框，边框的宽度计算为 0 hidden：同 none，除了在 表格元素 的 边框冲突处理 时 dotted：边框是一系列点 dashed：边框是一系列短线段 solid：边框是一条单独的线段 double：边框是两条实线。两条实线及它们之间的距离等于 border-width 的值 groove：边框看起来好像刻在画布上（3D 凹槽效果） ridge：边框看起来好像要从画布上出来（3D 凹槽效果） inset：边框让盒子看起来像是嵌进画布上（无 3D 效果） outset：边框让盒子看起来像要从画布上出来（无 3D 效果） 所有的边框都是在 盒子的背景（原：background）上绘制的。border 属性值为 groove、ridge、inset 和 outset 的边框颜色取决于元素的 border-color 属性，但 UA 可能会选用它们自己的算法来计算要应用的实际颜色。 关键信息摘要： 属性名称：border-top-style、border-right-style、border-bottom-style、border-left-style 值： | inherit 初始值：color 属性的值 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 关键信息摘要： 属性名称：border-style 值：{1,4} | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border-style 可以一次性设置 4 条边框的线条风格。也有 1 到 4 个值，并且值可以用来设置不同方向的线条风格，同 border-width。 下例中，水平边框将是 solid，垂直边框将是 dotted： #xy34 { border-style: solid dotted } 由于边框风格的初始值为 none，因此除非设置了 border-style，否则不会有 可见的边框。 8.5.4 边框简写属性：border-top、border-right、border-bottom、border-left、border 关键信息摘要： 属性名称：border-top、border-right、border-bottom、border-left 值：[ || || ] | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 这些都是简写属性，用来设置盒子的 上、右、下、左 的边框的宽度、风格和颜色 h1 { border-bottom: thick solid red } 上面的规则将设置 元素下方的边框宽度、样式和颜色。省略的值会被设置为其初始值。因为下面的规则没有指定 border-color，边框将获得 color 属性指定的颜色： h1 { border-bottom: thick solid } 关键信息摘要： 属性名称：border 值：[ || || ] | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border 也是简写属性，用来设置盒子的 4 条边框设置相同的宽度、样式和颜色。与 margin 和 padding 不同，border 属性不能对 4 条边框设置不同的值。因此，只能使用其它的边框属性。 下例，第一条规则等价于它后面的 4 条规则集： p { border: solid red } p { border-top: solid red; border-right: solid red; border-bottom: solid red; border-left: solid red } 由于在某种程度上，属性功能有所重叠，（样式）的规则的声明顺序很重要 看下例： blockquote { border: solid red; border-left: double; color: black; } 上例中，左边框的颜色是黑色，其余边框是红色。这是因为 border-left 同时设置了宽度、风格、颜色。因为颜色值没有从 border-left 属性给出，则将从 color 属性获取。color 属性虽然是在 border-left 属性之后设置的，但这并没影响。 8.6 双向上下文中行内元素的盒子模型 对于每个 行盒子（原：line box），UA 必须为每个元素生成 行内盒子 并且按照可视顺序（原：visual order）（不是逻辑顺序（原：logical order））呈现外边距（区域）、边框（区域）、填充（区域）。 当元素的 direction 属性为 ltr 时，元素出现的 第一个行盒子 里的 最左边生成的盒子 拥有 左外边距（区域）、左边框（区域）、左填充（区域），并且 元素出现的 最后一个行盒子 里的 最右边生成的盒子 拥有 右外边距（区域）、右边框（区域）、右填充（区域）。 当元素的 direction 属性为 rtl 时，元素出现的 第一个行盒子 里的 最右边生成的盒子 拥有 右外边距（区域）、右边框（区域）、右填充（区域），并且 元素出现的 最后一个行盒子 里的 最左边生成的盒子 拥有 左外边距（区域）、左边框（区域）、左填充（区域）。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/9 视觉格式化模型.html":{"url":"docs/CSS/CSS2.2/9 视觉格式化模型.html","title":"9 视觉格式化模型","keywords":"","body":"9 视觉格式化模型 9.1 视觉格式化模型的介绍 本章与下一章描述了视觉格式化模型：客户端如何处理在可视化媒体下的文档树。 在视觉格式化模型下，在文档树中每个元素会按照盒子模型生成 0 个或多个盒子。盒子的布局会受到以下因素控制： 盒子尺寸和类型 定位方案：普通流，浮动定位，绝对定位 文档树中元素之间的关系 外部因素（如：视口大小，图片的固有尺寸等等） 本篇和下一篇文章定义的属性适用于连续媒体和分页媒体。但是用于分页媒体中，margin 属性的含义可能会不同。 视觉格式化模型没有指定格式化的所有方面，比如字母间距的算法。对于本规范未涵盖的格式问题，（与 CSS 规范一致的）用户代理的表现可能有所不同。 9.1.1 视口 用于连续媒体的用户代理通常会为用户提供其查阅文档的视口（屏幕上的一个窗口或视图区域）。 用户代理在调整视口（见 初始包含块 小节）时，可能会改变文档的布局。 当视口小于渲染文档的画布区域时，用户代理应该提供滚动机制。一个画布最多只能有一个视口，但用户代理可能会渲染到多个画布上（即，提供同一文档的不同视图）。 9.1.2 包含块 在 CSS 2.2 中，盒子的位置和大小是相对于 称为包含块的矩形框 的边缘计算的。通常来说，生成的盒子可以作为后代盒子的包含块。我们说一个盒子为其后代 \"创建\" 了包含块。一个盒子的包含块 意思是 盒子所在的包含块，而不是它生成的那个（包含块）。 每个盒子都有一个相对于其包含块的位置，但它不受这个包含块的限制，它可能溢出（原：overflow）。 有关如何计算包含块的尺寸的详细信息将在下一章介绍。 9.2 控制盒子的生成 以下小节描述了在 CSS 2.2 中生成的盒子类型。盒子的类型部分影响在视觉格式化模型中的行为。下面描述的 display 属性指定了一个盒子的类型。 display 属性的某些值会导致源文档的元素生成一个主盒子（原：a principal box），这个主盒子包含后代盒子和生成的内容，同时这个主盒子也是所有的定位方案中所提及的盒子。 除了主盒子之外，某些元素可能会生成其它盒子：list-item 元素。这些附加盒子会相对于主盒的位置。 9.2.1 块级元素和块盒子 块级元素（原：block-level elements）：源文档的这些元素会被显示格式成块，并且是生成块级主盒子（原：block-level principal box）的元素。构成 块级元素 的 display 属性值：block、list-item、table。块级盒子（原：block-level boxes）是参与 块格式化上下文 的盒子。 在 CSS 2.2 中，块级盒子也就是块容器盒子，除非它是 表格盒子 或 替换元素的主盒子。块容器盒子要么只包含块级盒子，要么就创建 行内格式化上下文并只包含行内元素。元素的主盒子是块容器盒子，则该元素是块容器元素。display 属性的值为 block、list-item、inline-block 时可以使非替换元素生成块容器（盒子）。不是所有的块容器盒子都是块级盒子：非替换行内块、非替换表格单元是块容器但不是块级。块级盒子也叫块容器盒子的时候，称为块盒子。 三个术语块级盒子（原：block-level box）、块容器盒子（原：block container box）、块盒子（原：block box）在没有歧义的时候就简称为 块 block。 9.2.1.1 匿名块盒子（Anonymous block boxes） 在文档里像这样的（片段）： some text more text 假设：DIV 和 P 都是 display: block，DIV 同时具有 行内内容（原：inline content） 和 块元素（原：block element）。为了更容易定义 格式化，我们假设 some text 周围有一个 匿名块盒子。 图中显示了三个盒子，其中一个是 匿名盒子。 换句话说：如果一个块容器盒子（如上面的 DIV）里面有一个 块级盒子，然后我们强制让它里面只有块级盒子。 当一个 行内盒子 包含一个 流内块级盒子 时，这个行内盒子（及其在同一个行盒子里的行内祖先）会被周围的块级盒子打破（以及 任何连续的或只被可合并的 空白字符 和/或 流外元素隔开的块级兄弟盒子）？？？，会把行内盒子分成两个盒子（即使有一边是空的），分别位于块级盒子的两边。隔开前和隔开后的行内盒子都被包含在匿名块盒子中，并且该块级盒子会变成这些匿名块盒子的兄弟。当这样的行内盒子受到 相对定位 （而产生的偏移）的影响时，任何结果转换都会影响 行内盒子中所包含的块级盒子。 此模型会用于下例，如果下列规则： p { display: inline } span {display: block} 用在如下文档： This is anonymous text before the span This is the content of span. This is anonymous text after the span 分析：P 元素包含一个 匿名文本 的 chunk(c1)，后面紧跟 块级元素，再后面紧跟 另一个匿名文本 的 chunk(c2)。结果，盒子将会产生一个代表 BODY 的块盒子，包含一个 围绕 c1 的匿名块盒子，SPAN 块盒子，一个 围绕 c2 的匿名块盒子。 匿名块盒子的属性继承于非匿名盒子（比如第一个例子的 DIV 的盒子）。非继承属性具有初始值。比如匿名盒子的字体来源于 DIV，但是 margin 就为 0。 在生成匿名块盒子的元素上设置属性仍适用于该元素的盒子和内容。比如若在 P 元素上设置了边框，边框绘制 在 c1 结尾出打开，和在 c2 开头处打开。 一些用户代理已经以其它方式在包含块的行内上实现了边框，比如，通过把这种 嵌套块 包裹给在 \"匿名行盒子\" 内，从而使得这些盒子周围绘制 行内边框。CSS 1 和 CSS 2 没有定义该行为，因此仅 CSS 1 和 CSS 2 用户代理可以实现此替代模型，并且仍声明符合 CSS 2.2 这一部分。这不适用于此规范发布后的开发的 UA。 在 解析 百分比值 的时候，匿名块盒子会被忽略：使用最近的非匿名祖先盒子。比如如果上面 DIV 的匿名块盒子的子级需要知道其包含块的高度以解析百分比高度，那么将使用 DIV 所形成的包含块的高度，而不是匿名块盒子的高度。 9.2.2 行内级元素和行内盒子 行内级元素（原：inline-level elements）是源文档中不形成新内容块的元素。内容以行分布（比如强调段落中的一部分文本，行内图片等）。display 属性值为 inline、inline-table、inline-block 可以使元素成为 行内级元素。行内级元素生成行内级盒子，这些盒子会参与 行内格式化上下文。 行内盒子 是行内级盒子的一种，其内容参与所包含的行内格式化上下文。display 为 inline 的非替换元素会生成行内盒子。不是行内盒子（如行内级替换元素、行内块元素、行内表格元素）的行内级盒子称为原子行内级盒子，因为它们作为单一的不透明盒子参与其行内格式化上下文。 9.2.2.1 匿名行内盒子 任何直接包含在块容器元素里（不是在行内元素里）的文本都必须被视为匿名行内元素。 有一个如下 HTML 片段： Some emphasized text P 元素生成一个 块盒子，里面有几个行内盒子。emphasized 文本的行内盒子由行内元素 EM 生成，但是 Some 和 text 的行内盒子由块级元素 P 生成。后者叫 匿名行内盒子，因为它们没有相关联的 行内级元素。 此类匿名行内盒子可以从其父级块盒子继承可继承的属性。非继承属性取其初始值。比如匿名行内盒子的 color 是继承的，background 就是透明的。 根据 white-space 属性，合并掉的空白字符内容不会生成任何匿名行内盒子。 如果从上下文可以清楚看到是哪种匿名类型的盒子，则匿名行内盒子和匿名块盒子在本规范中简称为匿名盒子。 在格式化表格时会出现很多的匿名盒子类型，开不开心。 9.2.3 Run-in 盒子 display: run-in 将在 CSS3 中定义，见 CSS3 盒子 9.2.4 display 属性 关键信息摘要： 属性名称：display 值：inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit 初始值：inline 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：all 计算值：见下文 此属性的值具有以下含义： block：该值使元素生成 一个主块盒子 inline-block：该值使元素生成 主行内级块容器盒子。（inline-block 的内部会被格式化成一个块级盒子，元素本身会被格式化成为原子行内级盒子） inline：该值使元素生成 一个或多个行内盒子 list-item：该值使元素（如 ）生成 主块级盒子和标记盒子。 none：该值使元素不出现在格式化结构中（在视觉媒体中，元素不生成盒子且不影响布局）。后代元素也不会生成任何盒子。元素及其内容完全从格式化结构中删除。即使在后代上设置 display 值，也无法覆盖该行为。 注意：display: none 不会生成一个看不见的盒子，它根本就不会创造任何盒子。CSS 有一些机制能够使元素在格式化结构中产生影响，但本身不可见的盒子。详细信息请见 11-可见性 小节。 table, inline-table, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, and table-caption：这些值使其元素的行为像表格，见 17-表格 章节。 除了定位元素、浮动元素、根元素之外，（display 属性的）计算值与特定值相同。对于根元素，计算值 将按照 9.7 小节内容 'display'，'position'与'float' 之间的关系 描述的计算 注意：虽然 display 的初始值为 inline，但在客户端中的默认样式表中的规则可能会覆盖该值。见附录中的 HTML4 的样例样式表。 下面有 display 属性的例子： p { display: block } em { display: inline } li { display: list-item } img { display: none } /* Do not display images */ 9.3 定位方案 在 CSS 2.2 中，一个盒子可能根据三种定位方案进行布局： 普通流（原：Normal flow）：在 CSS 2.2 中，在普通流情况下包括 块级盒子的块格式化、行内级盒子的行内格式化、块级盒子和行内级盒子的相对定位。 浮动（原：Floats）：在浮动模型中，一个盒子首先在普通流情况下进行布局，然后在流中脱离并尽可能向左或向右移动。其它内容可能沿着浮动（盒子）的一侧排列。 绝对定位（原：Absolute positioning）：在绝对定位模型中，一个盒子完全从普通流中移除（对后面的 siblings 没有影响），并且相对于包含块指定了一个位置。 如果一个元素浮动、或绝对定位、或是根元素，则称该元素流外（原：out of flow）。如果元素没有流外，则称该元素流内（原：in-flow）。元素 A 的流由 A 和所有流内元素组成的集合，且最近可以流外的祖先为 A。 注意：CSS 2.2 的定位方案帮助作者的文档可读性更好，让他们避免那些用来实现布局效果的标记技巧（比如，不可见的图片）。 9.3.1 选择定位方案：position 属性 position 属性和 float 属性决定使用哪种 CSS 2.2 中的定位算法来计算盒子的位置。 关键信息摘要： 属性名称：position 值：static | relative | absolute | fixed | inherit 初始值：static 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 此属性的值具有以下含义： static：该盒子是一个普通盒子，根据普通流进行布局。top，right，bottom，left 属性不适用。 relative：盒子的位置根据普通流进行计算，这称之为在普通流中的位置，然后该盒子在相对于其正常位置进行偏移。当盒子 B 相对定位时，下一个盒子的位置计算就好像盒子 B 没有进行偏移一样。position: relative 对 table-row-group, table-header-group, table-footer-group, table-row, table-column-group, table-column, table-cell, table-caption 的元素的效果未定义。 absolute：盒子的位置（及可能的大小）由 top，right，bottom，left 属性进行指定。这些属性相对于该盒子的包含块的偏移。绝对定位的盒子脱离普通流，这意味着它们对后来的 siblings 的布局没有影响。此外，尽管绝对定位的盒子有 margin，但不会与任何其它的边距合并。 fixed：盒子的位置是根据 \"绝对\" 模型计算的，除此之外，盒子相对于某个参照物是固定的。和绝对模型一样，盒子的外边距不会与任何其它的外边距发生合并。 对于手持、投影、屏幕、tty、tv 媒体类型，该盒子是相对于其视口进行定位的，滚动时不会移动 在 打印 媒体类型上，即使通过视口看到页面，每个页面的该盒子都相对于页面盒子时固定的 对于其它媒体类型的效果未定义。 作者可能希望以媒体依赖的方式指定 fixed。比如，一个作者可能希望盒子保留在屏幕上视口的顶部，但不出现在每一个打印页的顶部。可以使用 @media 规则把它们分开，比如： @media screen { h1#first { position: fixed } } @media print { h1#first { position: static } } UA 不能对 fixed 的盒子的内容进行分页。注意：UA 可能以其它方式打印不可见的内容，见 13 章节 - 页面盒子外的内容。 用户代理可以把根元素的 position 属性视为 static。 9.3.2 盒子偏移：top right bottom left 如果元素的 position 是除 static 之外的值，则称该元素被定位（或称该元素为定位元素）。定位元素生成定位盒子，根据四个属性进行布局 top 属性 关键信息摘要： 属性名称：top 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的高度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 该属性指定了 绝对定位盒子的上外边距边缘 对于 该盒子的包含块的上边缘下方 的偏移量。对于相对定位的盒子，偏移量是相对于盒子自身的顶部边缘（即，盒子在普通流中指定了一个位置，然后根据这些属性从原位置偏移）。 right 属性 关键信息摘要： 属性名称：right 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 与 top 类似，但指定的 盒子的右边距边缘 对于 该盒子的包含块的右边缘的左边 的偏移量。对于相对定位的盒子，偏移量是相对于盒子自身的右边缘。 bottom 属性 关键信息摘要： 属性名称：bottom 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的高度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 与 top 类似，但指定 盒子的底部边距边缘 对于 该盒子的包含块的底部边缘的上方 的偏移量。对于相对定位的盒子，偏移量是相对于盒子自身的底部边缘。 left 属性 关键信息摘要： 属性名称：left 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 与 top 类似，但指定 盒子的左边距边缘 对于 该盒子的包含块的左边缘的右边 的偏移量。对于相对定位的盒子，偏移量是相对于盒子本身的左边缘。 此属性的值具有以下含义： ：偏移量是距离边缘的固定距离。允许负值 ：偏移量是包含块的宽度（对于 left 或 right）或高度（对于 top 或 bottom）的百分比。允许负值 ：对于非替换元素，此值的影响取决于哪个相关属性的值为 auto。非替换元素的详细情况，见 9.6 小节。对于替换元素，此值的影响取决于替换内容的固有尺寸。详细情况，也见 9.6 小节。 9.4 普通流（Normal flow） 在普通流中盒子属于格式化上下文，这个格式化上下文可以是表格、块、行内。在 CSS 的未来中，将会引入其它类型的格式化上下文（比如，FFC 和 GFC）。 块级盒子参与 块格式化上下文。 行内级盒子参与 行内格式化上下文。 表格格式化上下文会在表格章节中描述。 【理解：上下文其实是一个环境】 9.4.1 块格式化上下文（Block formatting contexts） 浮动（元素）、绝对定位元素、不是块盒子的块容器（元素）（比如 行内块（原：inline-blocks）、表格单元（原：table-cells）、表格标题（原：table-captions）），以及 overflow 不是 visible 的块盒子（除了 该值传播到视口 以外）会为其内容建立了新的块格式化上下文。 在 块格式化上下文 中，盒子从包含块的顶部开始一个接一个的垂直布局。两个兄弟盒子之间的垂直距离由 margin 属性决定。块级盒子的垂直外边距在块格式化上下文中会进行合并。 在块格式化上下文中，每个盒子的左外边缘触及包含块的左边缘（对于从右到左的格式化，右边缘触及）。即使存在浮动也如此（尽管盒子的行盒子可能会因为浮动而缩小），这也成立。除非该盒子建立了一个新的块格式化上下文（在这种情况下，盒子可能会因为浮动而缩小）。 关于分页媒体中分页相关的信息，请查看 13.3.3 合法的分页符 小节。 9.4.2 行内格式化上下文（Inline formatting contexts） 行内格式化上下文由 不包含块级盒子的 块容器盒子建立。在行内格式化上下文中，盒子从包含块的顶部一个接着一个水平布局。在这些盒子中，水平外边距（margin-left、margin-right）、边框(border)、填充（padding）都有效。盒子可能会以不同的方式垂直对齐：以它们的底部或顶部对齐，或以它们的文本的基线对齐。包含的这些盒子形成一行的矩形区域称之为行盒子。 行盒子的宽度由包含块和浮动情况决定。行盒子的高度由 10.8 行高的计算 的规则决定。 行盒子总是足够高，能够容纳它包含的所有盒子。然而，它可能比它包含的最高的盒子的高还要高（比如，如何盒子是以基线对齐的）。当盒子 B 的高度小于 包含它的行盒子的高度时，在行盒子内 B 的垂直对齐 由 vertical-align 属性决定。当多个行内级盒子不能在一个行盒子里水平放置时，它们就被分在两个或多个垂直堆叠的行盒子里。因此，段落就是一个垂直堆叠的行盒子集。行盒子垂直堆叠时没有垂直间隔（除非另有说明），它们从不重叠。 通常来说，行盒子的左边缘紧挨其包含块的左边缘，右边缘紧挨其包含块的右边缘。但是，浮动盒子可能在包含块边缘和行盒子边缘之间。因此，尽管在同一行内格式化上下文中行盒子通常具有相同的宽度（即，包含块的宽度），但是如果由于浮动而减少了可用的水平空间，则它们的宽度可用变化。在同一格式化上下文中行盒子一般高度各不相同（比如，一行可能有高图片，而其它只有文本）。 当一行上的行内级盒子的总宽度小于包含它们的行盒子的宽度时，它们在行盒子里的水平分布由 text-align 属性决定。如果属性的值为 justify，则用户代理可能会在行内盒子（除了 inline-table 和 inline-block 盒子 的以外）里拉伸空格和字符。 当行内盒子超出行盒子的宽度时，它会被分割成多个盒子，并且这些盒子分布在多个行盒子里。如果一个行内盒子无法被拆（比如，如果行内盒子包含单个字符或者特定语言的分词规则不允许在行内盒子里出现中断，又或者行内盒子受到 nowrap 或 pre 的空白字符的影响），那么该行内盒子会从行盒子溢出。 当一个行内盒子被分割后，外边距、边框、填充在发生分割的地方（或者，在任何分割的地方，有多个的时候）没有视觉效果。 由于双向文本的处理行内盒子也可以在同一个行盒子里里被分割称几个盒子。 行盒子根据需要被创建，以确保在行内格式化上下文里保存行内级内容。（这时候），该行盒子不包含文本，不包含保留空白字符，不包含非 0 外边距的行内元素，填充，边框，以及其它流内内容（比如，图片，行内块或行内表格），并且不以保留换行符结束的（行盒子）在确定其内部元素的位置时必须被当作 0 高度行盒子，出于其它目的时，必须当它不存在。 有个行内盒子构造的示例，下面的段落（由 HTML 块级元素 P 创建的）有匿名文本，散布在 EM 和 STRONG 元素间： Several emphasized words appear in this sentence, dear. P 元素生成了一个含有 5 个行内盒子的块盒子，其中有 3 个是匿名的： Anonymous: \"Several\" EM: \"emphasized words\" Anonymous: \"appear\" STRONG: \"in this\" Anonymous: \"sentence, dear.\" 为了格式化该段落，用户代理会把这 5 个盒子流到 行盒子里。本例中，P 元素生成的盒子为行盒子创建了包含块。如果该包含块足够宽，所有行内盒子都能放进一个行盒子里： 如果不行，行内盒子会被分割并分布在几个行盒子里。之前的段落可能如下： 或者像这样： 在之前的示例中，EM 盒子被分成了两个 EM 盒子（叫它们 split1 和 split2）。外边距，边框，填充或文本装饰不会在 split1 后面和 split2 前面产生可见的效果。 考虑下例： Example of inline flow on several lines em { padding: 2px; margin: 1em; border-width: medium; border-style: dashed; line-height: 2.4em; } Several emphasized words appear here. 由 P 的宽度决定，各个盒子的分布可能如下： 外边距插在 \"emphasized\" 前面和 \"words\" 后面 填充插在 \"emphasized\" 的前面，上面和下面，以及 \"words\" 的后面，上面和下面，虚线边框也出现在这 3 个方向 9.4.3 相对定位（Relative positioning） 一旦盒子按照普通流或浮动布局，它就有可能相对于该位置移动，这就称之为 相对定位。用这种方式偏移盒子（B1）不影响随后的盒子（B2）：B2 被给予了一个位置，就好像 B1 没有偏移并且在对 B1 偏移后，B2 没有重新定位。这就意味着相对定位可能导致盒子重叠。但是，如果相对定位导致 overflow: auto 或 overflow: scroll 的盒子溢出，则 UA 必须让用户能够访问这部分内容（在其偏移位置），这时候，滚动条的创建可能会影响布局。 相对定位的盒子保持其在普通流的大小，包括换行和空格都会原样保留。包含块 这一小节会解释相对定位盒子什么时候创建包含块。 对于相对定位元素，left 和 right 水平移动盒子，不会改变其大小。left 将盒子移动到右侧，right 将盒子移动到左侧。由于 left 或 right 的结果并不会导致盒子分割或拉伸，因此应用值应始终为：left = -right。 如果 left 和 right 都为 auto（初始值），则应用值为 0（即，盒子就呆在原地）。 如果 left 为 auto，则 left 的应用值为 负的 right 值（即，盒子像左移动 right 值）。 如果 right 为 auto，则 right 的应用值为 负的 left 值。 如果 left 和 right 都不为 auto，则位置过度约束，其中一个会被忽略。如果包含块的 direction 属性为 ltr，则 left 有效，right 变为 -left。如果包含块的 direction 属性为 rtl，则 right 有效，left 变为 -right。 示例，下列三条规则时一样的： div.a8 { position: relative; direction: ltr; left: -1em; right: auto } div.a8 { position: relative; direction: ltr; left: auto; right: 1em } div.a8 { position: relative; direction: ltr; left: -1em; right: 5em } top 和 bottom 属性向上或向下移动相对定位的元素而不改变其大小。top 向下移动盒子，bottom 向上移动盒子。由于 top 或 bottom 的结果并不会导致盒子分割或拉伸，因此应用值应始终为：top = -bottom。如果两者都为 auto，则它们的应用值都为 0。如果其中一个为 auto，则其中一个会变为另一个的负值。如果都不为 auto，则忽略 bottom（即，bottom 的应用值为 top 的负值）。 注意：在脚本环境中，相对定位盒子的动态移动会产生动画效果（见 visibility 属性）。尽管相对定位可用作上标或下标的形式，但行高不会因为定位而自动调整。相关信息，可以参考 见 行高计算 的描述。 9.8 小节-普通流、浮动与绝对定位之间的比较 提供了相对定位的例子。 9.5 浮动 浮动是一个在当前行上向左或向右移动的盒子。浮动盒子最有意思的特征是内容可能延其侧面流动（可以通过 clear 属性禁止这样做）。内容沿左浮动盒子的右侧向下流动，沿右浮动盒子的左侧向下流动。下面是浮动定位和内容流的介绍，控制浮动行为的详细规则由 float 属性中说明。 一个浮动盒子向左或向右移动，直到其外边缘挨到包含块的边缘或另一个浮动盒子的外边缘。如果有行盒子，则浮动盒子的外顶部与当前行盒子的顶部对齐。 如果对于浮动（盒子）没有足够的水平空间，那么它会向下移动直至它合适或不再出现浮动。 由于浮动盒子不在（普通）流中，因此在浮动盒子之前或之后创建的非定位块盒子会垂直排列，就好像浮动不存在一样。然而，会根据需要缩短挨着（浮动盒子）创建的当前和后续的行盒子，以便为浮动（盒子）的外边距腾出空间。 行盒子挨着浮动（盒子）的条件是，存在一个垂直位置，满足四个条件：（a）在行盒子顶部或顶部下面，（b）在行盒子底部或底部上面，（c）在浮动（盒子）上外边距边缘的下面，（d）在浮动（盒子）下外边距边缘的上面。 注意：这意味着 0 外高度（原：zero outer height）或负外高度（原：zero outer height）不会缩短行盒子。 如果缩短的行盒子太小而无法包含任何内容，则行盒子向下移动（并重新计算宽度），直到某些内容合适或不再出现浮动。在当前行里浮动盒子之前的任何内容都会在浮动的另一侧的同一行中重排。换句话说，如果行内级盒子被放置在同一行中左浮动（盒子）之前，并且在剩余的行盒子空间合适，则左浮动（盒子）就放置在该行，与行盒子的顶部对齐，然后，已经在该行的行内级盒子相应的移动到该浮动（盒子）的右侧（右侧是 左浮动（盒子）的另一侧），反之亦然，用于 rtl 和右浮动（盒子）。 表格的边框盒子（状态的元素）、块级替换元素、在普通流中创建新 BFC 的元素（比如 overflow 不为 visible 的元素）不得与元素自身处于同一块格式化上下文中的任何浮动（盒子）的外边距重叠。如果有必要的话，实现应该通过将所诉元素放在所有之前出现的浮动（盒子）的下方，以清除（原：clear）该元素（受到的浮动影响），但如果空间足够的话，可以将其放置在这些浮动（盒子）的附近。它们甚至可能会使所诉元素的边框比 第 10.3.3 节所定义的更窄。CSS 2 没有定义 UA 什么情况下可以把该元素放在浮动（盒子）旁边或者所诉元素可能变得更窄。 示例，在下面文档片段中，包含块太窄而不能包含浮动（盒子）旁边的内容，因此内容移动到浮动（盒子）下方，在行盒子中按照 text-align 属性对齐的位置放置 p { width: 10em; border: solid aqua; } span { float: left; width: 5em; height: 5em; border: solid blue; } Supercalifragilisticexpialidocious 效果可能如下： 几个浮动（盒子）可能相邻，该模型也适用于在同一行中的相邻浮动（盒子）。 下列规则让所有 class=\"icon\" 的 IMG 盒子左浮动（且 margin-left: 0）： img.icon { float: left; margin-left: 0; } 看下面的 HTML 源码和样式表： Float example IMG { float: left } BODY, P, IMG { margin: 2em } Some sample text that has no other... IMG 盒子左浮动。后面紧跟着的内容就被格式化到了浮动（盒子）的右侧，从浮动（盒子）的同一行开始。由于浮动的存在，浮动右侧的行盒子缩短，但在浮动之后恢复其 \"正常\" 宽度（P 元素所建立的包含块宽度）。本文档可能会格式化为： 如果文档是下面这样，则格式化效果一样： Some sample text that has no other... 因为浮动（盒子）左侧的内容被浮动（盒子）替代了，（内容）会沿着浮动（盒子）的右侧重排。 如 8.3.1 小节所述，浮动（盒子）的外边距不会与相邻盒子的外边距合并。因此，之前的示例中，P 盒子与浮动的 IMG 盒子之间的垂直外边距不会合并。 浮动（盒子）里的内容会堆叠起来，就好像浮动生成了新的堆叠上下文一样，除了定位元素和实际创建了新堆叠上下文的元素，都参与浮动（盒子）的父级堆叠上下文。在普通流中，浮动盒子会与其它盒子重叠（比如，浮动（盒子）旁边的普通流下的盒子有负的外边距时），出现这种情况时，浮动盒子会呈现在非定位流内的块（盒子）之前，但在流内的行内（盒子）之后。 另一幅图展示当浮动（盒子）与在普通流里的元素的边框重叠时会发生什么： 以下示例说明使用 clear 属性来阻止内容在浮动盒子旁边流动。 假设规则像这样： p { clear: left } 可能会格式化成这样： 两边段落都设置了 clear: left，这就导致第二段被 \"推下到了\" 浮动盒子的下方以实现此目的，间隙（原：clearance）被插入到其上外边距的上面。 9.5.1 定位浮动：float 属性 关键信息摘要： 属性名称：float 值：left | right | none | inherit 初始值：none 适用元素：所有（元素），除了 9.7 小节描述的 继承：no 百分比：N/A 适用媒体：visual 计算值：与指定值相同 此属性指定了盒子向左浮动还是向右浮动，或者不浮动。它可以为任何元素设置该属性，但仅适用于生成非绝对定位的盒子的元素。 此属性的值具有以下含义： left ：该元素生成浮动到左侧的一个块盒子。内容从该盒子的右侧流动，从顶部开始（取决于 clear 属性）。 right ：类似于 left，盒子向右浮动，内容从该盒子的左侧流动，从顶部开始。 none：该盒子不浮动。 用户代理可以把根元素的 float 属性作为 none。 以下是控制浮动行为的精确规则，类似的左浮动元素规则适用于右浮动元素： 左浮动盒子的左外侧边缘可能不位于其包含块的左边缘的左侧。 如果当前盒子是左浮动，并且在源文档中还有元素先生成左浮动的盒子，则对于每个之前此类盒子，当前盒子的左外侧边缘要么位于此类盒子的右外侧边缘的右边，或其顶部必须低于前一个此类盒子的底部。 左浮动盒子的右外边缘可能不位于其旁边的右浮动盒子的左外侧边缘的右边。 浮动盒子的外顶部可能不高于其包含块的顶部。当浮动发生在两个边距合并之间时，浮动的位置就好像它有一个匿名的块父级参与流。这种父级的位置由外边距合并的章节中的规则定义。 浮动盒子的外顶部可能不高于在源文档中还有元素先生成的块（盒子）或浮动盒子 的外顶部。 元素的浮动盒子的外顶部可能不高于在源文档中还有元素 先 生成的盒子的行盒子的顶部。 左浮动盒子左侧还有另一个左浮动盒子，其（指：另一个左浮动盒子）右侧外边缘可能没有位于其包含块的右侧边缘。（宽松的规则：左浮动可能不会超出右边缘，除非它尽可能地向左浮动） 浮动盒子必须尽可能地往高放。 左浮动盒子必须尽可能向左浮动，右浮动盒子必须尽可能向右浮动。较高的位置优于向左/右的位置。 但是在 CSS 2.2 中，在块格式化上下文中，有一个流内的父垂直外边距，使得浮动的位置高于它所处的位置，那么所有这些负边距都设置为 0，浮动的位置没有定义。 这些规则里涉及的其它元素仅仅只是指与浮动盒子处于同一个块格式化上下文的其它元素。 这段 HTML 片段 使 b 右浮动： ab 如果 P 元素足够宽，a 和 b 会在两侧，可能就像这样： 9.5.2 控制浮动旁边的流：clear 属性 关键信息摘要： 属性名称：clear 值：none | left | right | both | inherit 初始值：none 适用元素：块级元素 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 此属性说明元素盒子的哪一侧不与先浮动的盒子相邻。clear 属性不考虑元素自身的（浮动）或其它 BFC 的浮动。 适用在非浮动块级盒子上有以下含义： left：要求该盒子的上边框边缘位于在源文档中在此之前的元素所生成的左浮动盒子的下外边缘的下方 right：要求该盒子的上边框边缘位于在源文档中在此之前的元素所生成的右浮动盒子的下外边缘的下方 both：要求该盒子的上边框边缘位于在源文档中在此之前的元素所生成的左浮动盒子和右浮动盒子的下外边缘的下方 none：盒子相对浮动（盒子）的位置没有约束 值不为 none 就意味着要引入 空隙（原：clearance）。空隙会抑制外边距合并，并作为 margin-top 上方的空间。用于在垂直方向上把元素推离浮动（元素）。 通过首先确定元素的上边框边缘的假定位置来计算含有 clear 属性的元素的位置。如果元素的 clear 属性为 none，则该位置是其上边框边缘实际所在的位置。 如果元素的上边框边缘的假定位置没有越过有关的浮动盒子，那么空隙就会引入，且外边距会根据 8.3.1 小节进行合并。 然后，空隙的高度（原：amount）设置为下面两者的最大值： 将块（盒子）的边框边缘放置在最低的即将被清除（原：clear）的浮动（盒子）的下外边缘，所必须要的高度。 将块（盒子）的上边框边缘放在某个假定位置（clear 为 none 的假定位置），所必须要的高度。 或者，空隙（的高度）可以设置为将块（盒子）的边框边缘放置在最低的即将被清除的浮动（盒子）的下外边缘，所必须要的高度。 注意： 两种行为都允许现有的 Web 内容评估的兼容性。未来的 CSS 规范会选择其一 空隙可以为负或0 示例1：简单起见，假设，我们只有三个盒子，依次顺序：块 B1 有下外边距 M1（B1 没有子级，没有填充，没有边框），浮动块（高度为 H），块 B2 有上外边距 M2（B2 没有子级，没有填充，没有边框）。B2 的 clear 为 both。同样，假设 B2 为空。 如果不考虑 B2 的 clear 属性，我们会看到下图情况。B1 和 B2 的外边距（垂直）合并了。假设 B1 的下边界边缘为 y=0，则 F 的顶部为 y=M1，B2 的上边界边缘为 y=max(M1, M2)，F 的底部为 y=M1+H。 我们假设 B2 不在 F 下方（垂直方向上），即这就是规范所说的需要添加额外空隙的，意味着： max(M1,M2) 我们需要计算两次空隙 C：C1 和 C2，取较大值：C = max(C1,C2)。 第一种方法是将 B2 的顶部与 F 的底部齐平，即在 y=M1+H 处。这意味着，外边距由于有空隙不再合并： bottom of F = top border edge of B2 ⇔ M1 + H = M1 + C1 + M2 ⇔ C1 = M1 + H - M1 - M2 = H - M2 第二种计算保持 B2 的顶部（位置）不变，即 y=max(M1, M2)，意味着： max(M1,M2) = M1 + C2 + M2 ⇔ C2 = max(M1,M2) - M1 - M2 我们假设 max(M1,M2) C2 = max(M1,M2) - M1 - M2 同时，因为 C1 = H - M2，所以： C2 所以： C = max(C1,C2) = C1 示例2：这是负空隙的情况，为 -1em，（假设元素没有边框或填充） First paragraph. Floating paragraph. Last paragraph. 解释：如果没有 clear，则第一段和第三段的外边距将会合并，最后一段的上边框边缘将会与浮动段落的顶部齐平。但是 clear 要求上边框边缘低于浮动盒子，即为 2em。这就意味着要引入空隙。这样一来，外边距不再合并，空隙的高度应满足 clearance + margin-top = 2em，即，clearance = 2em - margin-top = 2em - 3em = -1em。 当属性设置在浮动元素上，会导致修改浮动定位的规则，添加了一个额外的约束（#10）： 浮动盒子的上外边框边缘必须低于所有早期左浮动盒子的下外边缘（在 clear: left 的情况下），或者所有早期右浮动盒子的下外边缘（在 clear: right 的情况下），或者两者（在 clear: both 的情况下）。 注意：该属性适用于 CSS 1 中的所有元素，实现可能已经在所有元素上支持该属性了。CSS 2 和 CSS 2.2 中，clear 属性只适用于块级元素。因此，作者应该只把该属性用在块级元素上。如果需要实现支持行内元素上的 clear，而不像上面解释的那样设置一个空隙，实现应该是强制中断（原：break）并有效地插入一个或多个空 行盒子（或者按 9.5节 中描述的那样向下移动新的行盒子），以便将有 clear 的行内元素的行盒子的顶端移到对应的浮动盒子下方。 9.6 绝对定位（Absolute positioning） 在绝对定位模型中，一个盒子相对于其包含块明确偏移。完全从普通流中移除，对后来的兄弟（盒子）没有影响。绝对定位的盒子，为其盒子里在普通流里的子级和绝对定位（不是 fixed）创建了一个新的包含块。然而，绝对定位元素的内容不会围绕其它任何盒子流动。它们可能会遮挡另一个盒子的内容（或自身被遮挡），具体取决于重叠盒子的层叠级别。 本说明里的绝对定位元素意味着 元素的 position 属性为 absolute 或 fixed。 9.6.1 固定定位（Fixed positioning） 固定定位是绝对定位的一种。唯一的区别是，对于固定定位的盒子，包含块由 视口 创建。 对于连续的媒体，文档滚动时固定盒子不会移动，类似于固定的背景图像。 对于分页媒体，每页都会重复具有固定位置的盒子。这对于在每个页面的底部放置签名很有用。 作者可能想通过使用固定定位来创建类似演示文稿： A frame document with CSS body { height: 8.5in } /* Required for percentage heights below */ #header { position: fixed; width: 100%; height: 15%; top: 0; right: 0; bottom: auto; left: 0; } #sidebar { position: fixed; width: 10em; height: auto; top: 15%; right: auto; bottom: 100px; left: 0; } #main { position: fixed; width: auto; height: auto; top: 15%; right: 0; bottom: 100px; left: 10em; } #footer { position: fixed; width: 100%; height: 100px; top: auto; right: 0; bottom: 0; left: 0; } ... ... ... ... 9.7 display、position、float 之间的关系 影响盒子生成和布局的三个属性：display、position、float，遵循以下规则： 如果 display 的值为 none，则 position、float 无效。在这种情况下，元素不生成盒子。 否则，如果 position 的值为 absolute 或 fixed，则该盒子为绝对定位，float 的计算值为 none，并根据下表设置 display 属性。盒子的位置将由 top、right、bottom、left 和该盒子的包含块决定。 否则，如果 float 的值不为 none，则该盒子浮动，并根据下表设置 display 属性。 否则，如果元素为 根元素，则根据下表设置 display 属性。在 CSS2.2 中，指定值为 list-item 是否变为 block 或 list-item，这种情况未定义。 否则，其余的 display 属性按照指定值使用。 指定值（Specified value） 计算值（ Computed value） inline-table table inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block block others 和指定值一样 9.8 普通流、浮动、绝对定位之间的比较 为了说明 普通流，相对定位，浮动和绝对定位之间的差异，基于以下 HTML 提供了一些示例： Comparison of positioning schemes Beginning of body contents. Start of outer contents. Inner contents. End of outer contents. End of body contents. body { display: block; font-size:12px; line-height: 200%; width: 400px; height: 400px } p { display: block } span { display: inline } 由 #outer 和 #inter 元素生成的盒子的最终位置在每个示例中都不一样。每幅图中左边的数字表明了在普通流里双倍行距的位置。 注意：本节的图并不是按比例绘制，只是来说明各定位方案之间的差异。 9.8.1 普通流 考虑以下 CSS 声明，不会改变盒子的（默认）定位方案：普通流 #outer { color: red } #inner { color: blue } P 元素包含所有行内内容：匿名行内文本和两个 SPAN 元素。因此，所有内容都将在 由 P 元素创建的包含块里的行内格式化上下文中进行布局，从而产生以下内容： 此图描述 9.8.2 相对定位 为了看 相对定位 效果，指定： #outer { position: relative; top: -12px; color: red } #inner { position: relative; top: 12px; color: blue } 文本正常排列，直到 #outer（盒子）。 #outer 文本保持其普通流下的位置和尺寸，位于第一行末尾。然后，含有文本（分布在三行里）的行内盒子作为一个整体移动了 \"-12px\"（向上）。 #inner 的内容，作为 #outer 的子级，正常的紧跟着 \"of outer contents\" 文本排列（在 1.5 行）。然而，#inner 的内容自身相对于 #outer 的内容偏移了 \"12px\"（向下），回到了在第 2 行的原位置。 注意：#outer 后面的内容不受 #outer 相对定位的影响。 此图描述 注意：#outer 的偏移若为 -24px，则 #outer 文本与正文重叠。 9.8.3 浮动盒子 现在来使 #inner 元素向右浮动： #outer { color: red } #inner { float: right; width: 130px; color: blue } 文本正常排列，直到 #inner（盒子），从普通流里脱离，并浮动到右外边距（其宽度已显示指定）。浮动（盒子）左侧的行盒子被缩短了，文档的其余文本就排列在里面： 此图描述 为了展示 clear 属性的效果，我们增加了 #sibling 元素： Comparison of positioning schemes II Beginning of body contents. Start of outer contents. Inner contents. Sibling contents. End of outer contents. End of body contents. #inner { float: right; width: 130px; color: blue } #sibling { color: red } #inner 盒子会向之前一样右浮动，文档的其余文本就排列在腾出的空间里： 此图描述 然而，如果 #sibling 元素上的 clear 属性为 right（即生成的 #sibling 盒子不会接受一个右侧有浮动盒子的位置），则 #sibling 内容从浮动盒子下面开始流动排列： #inner { float: right; width: 130px; color: blue } #sibling { clear: right; color: red } 此图描述 9.8.4 绝对定位 最后，我们来看绝对定位的效果： #outer { position: absolute; top: 200px; left: 200px; width: 200px; color: red; } #inner { color: blue } #outer 盒子的顶部会相对于其包含块定位。定位盒子的包含块由最近的定位祖先创建（若不存在，则用初始包含块，就和我们示例一样）。#outer 盒子的顶部距离包含块的顶部为 200px，左侧距离左侧的 200px。#outer 的子级盒子相对于其父级正常排列。 此图描述 下面示例显示了一个绝对定位的盒子，它是相对定位的盒子的子级。虽然父级 #outer 盒子没有发生偏移，且 position: relative，表示其生成的盒子可以作为定位后代的包含块。由于 #outer 是一个分成几行的行内盒子，第一个行内盒子的顶部（边缘）和左侧边缘（下图用粗虚线显示）作为 top 和 left 偏移的参考 #outer { position: relative; color: red } #inner { position: absolute; top: 200px; left: -100px; height: 130px; width: 130px; color: blue; } 结果如图： 此图描述 如果不定位 #outer 盒子： #outer { color: red } #inner { position: absolute; top: 200px; left: -100px; height: 130px; width: 130px; color: blue; } #inner 的包含块变成了初始包含块。下图显示了最终位置： 此图描述 相对定位和绝对定位可能会用来实现变更标记符，如下面片段所示： I used two red hyphens to serve as a change bar. They will \"float\" to the left of the line containing THIS -- word. 产生如下结果： 此图描述 首先，段落正常排列。然后从包含块的左边缘偏移了 10px（在预期偏移的情况下保留了 10px 的右外边距）。两个作为变更标记符的连字符脱离了流，并定位在当前行（因为 top: auto），-1em 是距离其包含块（由 P 元素的最终位置创建）的左边缘的长度。结果是变更标记符好像 \"浮动\" 到了当前行的左侧。 9.9 分层显示（Layered presentation） 9.9.1 指定层叠级别：z-index 属性 关键信息摘要： 属性名称：z-index 值：auto | | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：N/A 适用媒体：all 计算值：和指定值一样 对于定位盒子，z-index 属性指定： 在当前层叠上下文中盒子的层叠级别 盒子是否创建层叠上下文 此属性的值具有以下含义： ：此整数是生成的盒子在当前层叠上下文中层叠级别。该盒子还会创建新的层叠上下文。 auto：生成的盒子在当前层叠上下文中层叠级别为 0。如果盒子的 position 属性为 fixed 或者是 根元素，则还会创建新的层叠上下文。 在这部分里，在...之前意味着当用户面向屏幕时更接近用户。 在 CSS 2.2 里，每个盒子都有三维位置。除了它们的水平位置和垂直位置之外，盒子沿着 Z 轴放置，并且一个在另一个上面进行格式化。当盒子视觉上重叠时，这与 Z 轴的位置尤其相关。本节讨论如何沿 Z 轴定位盒子。 根据层叠上下文来描述渲染树在画布上的绘制顺序。层叠上下文可以包含更多的层叠上下文。从其父级层叠上下文的角度来看，层叠上下文是原子的。在其它层叠上下文的盒子不可能出现在其它盒子之间。 每个盒子都属于一个层叠上下文。每个定位盒子在给定的层叠上下文里都有着整数的层叠级别，这是在 Z 轴上相对于同一层叠上下文中的其它层叠级别的位置。具有更高层叠级别的盒子总是在具有较低层叠级别的盒子前面格式化。盒子可能具有负层叠级别。在层叠上下文中具有相同层叠级别的盒子根据文档树上的顺序进行从后向前的堆放。 根元素形成根层叠上下文。其它层叠上下文由 具有除 auto 值以外的 z-index 属性的任何定位元素（包括相对定位的元素）生成。层叠上下文不一定与包含块有关。 在未来的 CSS 级别中，其它属性可能会创建层叠上下文，比如 opacity。 在每个层叠上下文中，以下层按从前到后的顺序进行绘制： 形成层叠上下文的元素的 background 和 border 具有负值的层叠级别（负数中绝对值最大的）的子层叠上下文 流内的（原：in-flow）、非行内级的（原：non-inline-level）、非定位（原：non-positioned ）的后代 非定位的浮动（原：non-positioned） 流内的（原：in-flow）、行内级的（原：inline-level）、非定位（原：non-positioned ）的后代，包括 行内表格（原：inline-table）和行内块（原：inline-block） 层叠级别为 0 的子层叠上下文和层叠级别为 0 的已定位后代 具有正值的层叠级别（正数中绝对值最小的第一个）的子层叠上下文 在每个层叠上下文中，层叠级别为 0 的定位元素（第 6 层），非定位的浮动（第 4 层），行内块（第 5 层）和行内表格（第 5 层），被绘制为就好像这些元素本身生成了新的层叠上下文，除了它们 定位的后代 和 任何可能的子层叠上下文参与当前的层叠上下文。 此绘制顺序以递归形式应用于每个层叠上下文中。层叠上下文绘制顺序的在 附录 E 中有详细描述。 下例中，每个 id 盒子的层叠级别分别为：\"text2\"=0、\"image\"=1、\"text3\"=2、和 \"text1\"=3。\"text2\" 的层叠级别是从根盒子继承下来的，其它由 z-index 属性指定。 Z-order positioning .pile { position: absolute; left: 2in; top: 2in; width: 3in; height: 3in; } This text will overlay the butterfly image. This text will be beneath everything. This text will underlay text1, but overlay the butterfly image 例子中说明了透明度的概念。背景的默认行为是允许它后面的盒子可见。本例中，每个盒子都透明覆盖在其下面的盒子上面，这种可以通过 background 取控制可见性。 9.10 文本方向：direction 属性和 unicode-bidi 属性 ⌛️... Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-11-18 16:56:16 "},"docs/CSS/CSS2.2/10 视觉格式化模型细节.html":{"url":"docs/CSS/CSS2.2/10 视觉格式化模型细节.html","title":"10 视觉格式化模型细节","keywords":"","body":"10 视觉格式化模型细节 10.1 包含块的定义 元素（生成）的盒子的位置和大小有时是相对于某个矩形计算的，这个矩形就称之为元素的包含块。 元素的包含块定义如下： 根元素的包含块是一个叫 初始包含块（原：the initial containing block）的矩形。对于连续媒体，它具有视口的尺寸并固定定在画布开始处。对于分页媒体，它是页面区域。初始包含块的 direction 属性与根元素的 direction 属性相同。 对于其它元素，如果元素的 position 属性为 relative 或 static，则包含块由最近的祖先盒子的内容边缘（原：the content edge）创建，该祖先盒子是一个块容器盒子或者创建了格式化上下文。 如果元素的 position 属性为 fixed，则对于连续媒体来说 包含块由视口创建，对于分页媒体来说 包含块由页面区域创建。 如果元素的 position 属性为 absolute，则包含块由最近的 position 属性为 absolute、relative、fixed 的祖先盒子创建，按照方式如下： 如果祖先元素是行内元素，则包含块是围绕着 为该元素生成的第一个和最后一个行内盒子的 填充盒子 的边界盒子（原：the bounding box）。在 CSS 2.2 中，如果行内元素被分割成多行，这种情况下包含块没有定义。 否则，包含块由该祖先的填充边缘（原：the padding edge）形成。 如果没有这样的祖先盒子，则包含块为初始包含块。 在分页媒体中，绝对定位的元素相对于其包含块定位的，会忽略任何分页符（就像文档是连续的一样），随后元素可能被分成几页。 对于绝对定位的内容，如果被解析到页面上的位置不在正在布局的页面（即，当前页面）上，或解析到当前页面上已经渲染用于打印的位置，那么打印机可以把内容放置在： 在当前页面上的另一个位置 在后续页面上，或者 可以省略它 注意：被分割在多个页面上的块级元素在每个页面上可能有不同的宽度，并且还会受到特定设备的限制。 示例：如果没有定位，在下面的文档中的包含块（C.B.）的创建如下表格： Illustration of containing blocks This is text in the first paragraph... This is text in the second paragraph. 对于生成的盒子 包含块（C.B.）由谁创建 html 初始包含块(依赖于 UA) body html div1 body p1 div1 p2 div1 em1 p2 strong p2 如果我们定位 #div1： #div1 { position: absolute; left: 50px; top: 50px } 那么它的包含块不再是 #body，而是 初始包含块（因为没有其它定位的祖先盒子） 如果我们再同时定位 #em1 #div1 { position: absolute; left: 50px; top: 50px } #em1 { position: absolute; left: 100px; top: 100px } 包含块变成如下： | 对于生成的盒子 | 包含块由谁创建 | | --- | --- | | html | 初始包含块(依赖于 UA) | | body | html | | div1 | 初始包含块 | | p1 | div1 | | p2 | div1 | | em1 | div1 | | strong | em1 | 通过定位了 #em1，它的包含块就变为最近定位的祖先盒子（即，由 #div1 生成的盒子） 10.2 内容宽度：width 属性 关键信息摘要： 属性名称：width 值： | | auto | inherit 初始值：auto 适用元素：除了行内非替换元素，表格行，行组以外的所有元素 继承：no 百分比：相对包含块的宽度 适用媒体：visual 计算值：百分比，或 与指定值一样的 auto ，或绝对长度 该属性指定的是盒子的内容宽度（原：content width）。 该属性不适用于 行内非替换元素（原：non-replaced inline elements）。行内非替换元素的内容宽度是 渲染内容 的内容宽度（在任何子级的相对偏移之前）。回想一下，行内盒子流入行盒子。行盒子的宽度由其包含块给出，但可能会因为浮动的存在而缩短。 此属性的值具有以下含义： ：使用长度单位指定内容区域的宽度 ：指定百分比宽度。百分比是根据生成的盒子的包含块宽度计算的。对于那些包含块是基于块容器元素的绝对定位元素，百分比是相对于该元素的填充盒子的宽度计算的。CSS 1：百分比宽度始终相对于父元素的内容盒子计算 auto：宽度由其它属性的值决定。 width 属性不能为负数。 示例：下列规则指定段落的内容宽度为 100 像素： p { width: 100px } 10.3 计算宽度和外边距 译注：本小节的外边距指的是左右外边距。 用于布局的元素的 width、margin-left、margin-right、left、right 属性的值由生成的盒子类型和彼此之间决定的。用于布局的值称之为 应用值（原：the used value），原则上，应用值和计算值相同，auto 是替换为某个合适的值，百分比基于包含块计算，但是有例外。需要区分以下情况： 行内非替换元素（原：inline, non-replaced elements） 行内替换元素（原：inline, replaced elements） 普通流块级非替换元素（原：block-level, non-replaced elements in normal flow） 普通流块级替换元素（原：block-level, replaced elements in normal flow） 浮动非替换元素（原：floating, non-replaced elements） 浮动替换元素（原：floating, replaced elements） 绝对定位非替换元素（原：absolutely positioned, non-replaced elements） 绝对定位替换元素（原：absolutely positioned, replaced elements） 普通流行内块非替换元素（原：'inline-block', non-replaced elements in normal flow） 普通流行内块替换元素（原：'inline-block', replaced elements in normal flow） 对于 1-6 和 9-10，在有相对定位元素的情况下 left 和 right 的值，见 9.4.3 小节的规则。 注意：下面计算的 width 的应用值是暂定值，可能需要多次计算，具体取决于 min-width 和 max-width，见下面 最小和最大宽度 部分。 10.3.1 行内非替换元素 width 属性不适用。 如果 margin-left 和 margin-right 的计算值为 auto，则应用值为 0。 10.3.2 行内替换元素 如果 margin-left 和 margin-right 的计算值为 auto，则应用值为 0。 如果 height 和 width 的计算值都为 auto ，且元素也有固定宽度，那么 width 的应用值是该固定宽度。 如果 height 和 width 的计算值都为 auto 且元素没有固定宽度但却有固定高度和固有比率，或者 如果 width 的计算值为 auto 且 height 的计算值为其它值 且 该元素具有固有比率，那么 width 的应用值：(used height) * (intrinsic ratio)。 如果 height 和 width 的计算值都为 auto 且元素具有固有比率但没有固有的高度或宽度，则在 CSS 2.2 中 width 没有定义，但是有人建议，如果包含块的宽度自身并不取决于 替换元素的宽度，则 width 的应用值是在普通流中块级非替换元素的约束方程计算的。 否则，如果 width 的计算值为 auto，且元素都具有固定宽度，则 width 的应用值为该固定宽度。 否则，如果 width 的计算值为 auto，但没有满足以上条件，则 width 的应用值为 300px。如果 300px 太宽以至于无法适应设备，则客户端应使用比率为 2:1 的最大矩形的宽度，而不是适应设备。 10.3.3 普通流块级非替换元素 译注：只有 width 、margin 属性才有 auto 值，padding 属性没有。 其它属性的应用值受到以下规则约束： 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' = 包含块的宽度 如果 width（属性值）不为 auto，且 border-left-width + padding-left + width + padding-right + border-right-width（加上所有不为 auto 的 margin-left 或 margin-right）大于 包含块的宽度，则 margin-left 或 margin-right 的 auto 值在下面规则中都作为 0。 如果以上属性的计算值都不为 auto，这些值被 “过度约束” 了，则以上属性就会有一个应用值和计算值不同（译注：margin-right 会优先不同）。如果包含块的 direction 属性值为 ltr，则忽略 margin-right 的指定值且计算该值以使 等式 成立。如果包含块的 direction 属性值为 rtl，则忽略 margin-left 的指定值，目的一样。 如果只有一个属性的值指定为 auto，则应用值取决于等式。 如果 width 设置为 auto，则其它的 auto 值都会变为 0 且 width 的值取决于等式。 如果 margin-left 和 margin-right 的值都为 auto，则该两个属性的应用值相等，并且元素将会相对于 包含块的边缘 水平居中。 10.3.4 普通流块级替换元素 width 的应用值由 行内替换元素 决定。然后使用 块级非替换元素 的规则来决定 margin。 10.3.5 浮动非替换元素 如果 margin-left 或 margin-right 的计算值为 auto ，则它们的应用值为 0。 如果 width 的计算值为 auto，则应用值遵循 shrink-to-fit 规则。 shrink-to-fit 的计算类似于自动表格布局算法计算表格单元格的宽度。大致计算过程： 通过格式化不包含显示换行符的行的内容来计算 首选宽度。并且计算首选最小宽度（比如尝试所有可能的换行符）。 CSS 2.2 没有定义精确的算法 找到可用宽度：在这种情况下，就使用 包含块的宽度 - （margin-left + border-left-width + padding-left + padding-right 的应用值）- (任何相关滚动条的宽度) 然后，shrink-to-fit 的宽度为：min(max(首选最小宽度, 可用宽度), 首选宽度)。 10.3.6 浮动替换元素 如果 margin-left 或 margin-right 的计算值为 auto ，则它们的应用值为 0。 width 的应用值由 行内替换元素 决定。 10.3.7 绝对定位非替换元素 出于本节和下一节的目的，（元素的）静态位置（static position）这一术语粗略指的是元素在普通流中的位置。 更确切的说： 静态位置包含块是 假想盒子 的包含块。如果（元素的） position 的指定值为 static 且 float 的指定值为 none，则该元素将成为元素的第一个盒子。（注意，由于 9.7 节的规则，这个假想计算可能还会为 display 假定一个不同的计算值） left 的静态位置是指 包含块的左（外边距）边缘 到 假想盒子的左外边距边缘 的距离，如果其 position 属性值为 static 且 float 为 none，则该假想盒子称为元素的第一个盒子。如果假想盒子在其包含块的左侧，则该值为负。 right 的静态位置是指 包含块的右（外边距）边缘 到 假想盒子的右外边距边缘 的距离。如果假想盒子在其包含块的左侧，则该值为正。 但是，不用实际计算假想盒子的尺寸，用户代理会随意的猜测它可能的位置。 为了能计算静态位置，固定定位元素的包含块为初始包含块而不是视口，并且所有可滚动盒子都假设能滚动到其开始位置。 决定这些元素的应用值的约束规则是： 'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' = 包含块的宽度 如果 left、width、right 的值都为 auto：首先将 margin-left 和 margin-right 的 auto 值设置为 0。然后，如果创建静态位置包含块的元素的 direction 属性的值为 ltr，则将 left 设置为静态位置并应用下列规则 3。反之，将 right 设置为静态位置并应用下列规则 1。 如果这三个的值都不为 auto：如果 margin-left 和 margin-right 的值都为 auto，则在（左右）两边外边距相等的条件下求解方程，除非这会让它们为负值。在这种情况下，当包含块的 direction 的值为 ltr（rtl）时，margin-left（margin-right）的值设置为 0 并求解 margin-right（margin-left）。如果 margin-left 或 margin-right 中一个值为 auto，则求解该值的等式。如果值被 “过度约束” 了，则忽略 left 的值（如果包含块的 direction 的值为 rtl）或 right 的值（如果包含块的 direction 的值为 ltr），再求出该值。 否则，把值为 auto 的 margin-left 和 margin-right 设置为 0，然后选择下面 6 条规则的中的一条应用： 如果 left 和 width 的值为 auto 而 right 的值不为 auto，那么宽度就 shrink-to-fit。然后求解 left。 如果 left 和 right 的值为 auto 而 width 的值不为 auto，那么如果创建静态位置包含块的元素的 direction 属性的值为 ltr，则将 left 设置为静态位置，否则将 right 设置为静态位置。然后求解 left（如果 direction 的值为 rtl）或 right（如果 direction 的值为 ltr）。 如果 width 和 right 的值为 auto 而 left 的值不为 auto，那么宽度就 shrink-to-fit。然后求解 right。 如果 left 的值为 auto 而 width 和 right 的值不为 auto，那么求解 left。 如果 width 的值为 auto 而 left 和 right 的值不为 auto，那么求解 width。 如果 right 的值为 auto 而 left 和 width 的值不为 auto，那么求解 right。 shrink-to-fit 的计算类似于自动表格布局算法计算表格单元格的宽度。大致计算过程： 通过格式化不包含显示换行符的行的内容来计算 首选宽度。并且计算首选最小宽度（比如尝试所有可能的换行符）。 CSS 2.2 没有定义精确的算法 找到可用宽度：将 left（上述规则中的 1）或 right（上述规则中的 3）的值设置为 0，来确定 width 然后，shrink-to-fit 的宽度为：min(max(首选最小宽度, 可用宽度), 首选宽度)。 10.3.8 绝对定位替换元素 在这种情况下，第 10.3.7 小节适用部分包含约束方程，但其余部分都改成下面规则： width 的应用值由 行内替换元素 决定。如果 margin-left 或 margin-right 的指定值为 auto，则其应用值由下面规则决定。 如果 left 和 right 的值都为 auto，则如果创建静态位置包含块的元素的 direction 属性的值为 ltr，则将 left 设置为静态位置。反之，将 right 设置为静态位置。 如果 left 或 right 的值为 auto，则所有值为 auto 的 margin-left 或 margin-right 设置为 0。 如果此时 margin-left 和 margin-right 的值仍为 auto，则在两边外边距必须相等的情况下求解方程，除非这会让它们为负值。在这种情况下，如果包含块 direction 的值为 ltr（rtl）时，margin-left（margin-right）的值设置为 0 并求解 margin-right（margin-left）。 如果此时 只剩下一个 auto 了，则求解方程得出这个值。 如果此时值被 “过度约束” 了，则忽略 left 的值（如果包含块的 direction 的值为 rtl）或 right 的值（如果包含块的 direction 的值为 ltr），再求出该值。 10.3.9 普通流行内块非替换元素 如果 width 的计算值为 auto，则其应用值遵循 浮动元素的 shrink-to-fit 的规则。 如果 margin-left 或 margin-right 的计算值为 auto ，则它们的应用值为 0。 10.3.10 普通流行内块替换元素 与 行内替换元素 一样 10.4 最小和最大宽度：min-width 和 max-width 关键信息摘要： 属性名称：min-width 值： | | inherit 初始值：0 适用元素：除了行内非替换元素，表格行，行组以外的所有元素 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：百分比与指定值一样，或绝对长度 关键信息摘要： 属性名称：max-width 值： | | none | inherit 初始值：none 适用元素：除了行内非替换元素，表格行，行组以外的所有元素 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：百分比与指定值一样，或绝对长度，或 none 这两个属性允许将内容宽度约束到特定范围。 值有以下含义： ：指定固定的最小或最大使用宽度 ：指定百分比来确定应用值。百分比是通过生成的盒子的包含块的高度计算的。如果包含块的高度取决于该元素的高度，则在 CSS 2.2 中这种情况未说明 none：（仅对于 max-width），盒子的宽度没有限制 min-width 和 max-width 的值不能为负数。 在 CSS 2.2 中，min-width 和 max-width 对 表格、行内表格、表格单元格、表格列、列组 的影响并没有定义。 下面的算法描述了这两个属性如何影响 width 属性的应用值： 暂时应用的宽度按照上面的 计算宽度和外边距 来计算（不考虑 min-width 和 max-width）。 如果暂时应用的宽度大于 max-width，则再次应用上述的规则，但这次应用 max-width 的计算值作为 width 的计算值。 如果最终宽度小于 min-width，则再次应用上述的规则，但这次应用 min-width 的值作为 width 的计算值。 注意：这些步骤不会影响上述属性实际计算值。 然而，对于有固有比率且 width 和 height 为 auto 的替换元素，算法如下： 从表格中对应的约束条件来解析高度和宽度值。取 max-width 和 max-height 作为 max(min, max) 使 min 的条件一直成立。在表格里，w 和 h 代表忽略 min-width，min-height、max-width、max-height 后计算的宽度和高度结果。通常，它们都是固定宽度和高度，但它们可能不属于是固有比率的替换元素。 注意：如果明确设置了宽或高而另一个尺寸为 auto，对 auto 的这一侧会应用一个最小或最大约束从而最终可能会导致过度约束。该规范明确定义了这种行为，但可能不是作者所希望的那样。CSS 3 的 object-fit 属性可以在这种情况下得到不同的结果。 然后使用上面小节的 “计算宽度和外边距” 的规则，就好像 width 的 计算值为该值一样。 10.5 内容高度：height 属性 关键信息摘要： 属性名称：height 值： | | auto | inherit 初始值：auto 适用元素：除了行内非替换元素，表格行，列组以外的所有元素 继承：no 百分比：见下文 适用媒体：visual 计算值：百分比，或 与指定值一样的 auto ，或绝对长度 该属性指定的是盒子的内容（原：content）高度。 该属性不适用于行内非替换元素。行内非替换元素的高度计算参考 “计算高度和外边距” 小节的部分。 此属性的值具有以下含义： ：使用长度单位指定内容区域的高度 ：指定百分比高度。百分比是根据生成的盒子的包含块高度计算的。如果包含块的高度没有明确指定（取决于内容高度），并且此元素不是绝对定位，则计算使用的高度就好像使用了 auto 一样。根元素的百分比高度相对于初始包含块。CSS 1：百分比高度始终相对于父元素的内容盒子计算 auto：高度由其它属性的值决定。 注意：绝对定位元素的包含块的高度与元素本身的大小无关，所以总是能够解析此类元素的百分比高度。然而，在处理完文档后面的元素之前可能都不知道高度。 height 的值不能为负数。 示例：下列规则集给段落的内容高度设置了 100 px： p { height: 100px } 根据 overflow 属性，当段落的内容高度 > height 时会溢出。 10.6 计算高度和外边距 译注：本小节的外边距指的是上下外边距。 要计算（元素的）top、margin-top、height、margin-bottom、bottom 的属性值，必须要区分各种类型的盒子： 行内非替换元素（原：inline, non-replaced elements） 行内替换元素（原：inline, replaced elements） 普通流块级非替换元素（原：block-level, non-replaced elements in normal flow） 普通流块级替换元素（原：block-level, replaced elements in normal flow） 浮动非替换元素（原：floating, non-replaced elements） 浮动替换元素（原：floating, replaced elements） 绝对定位非替换元素（原：absolutely positioned, non-replaced elements） 绝对定位替换元素（原：absolutely positioned, replaced elements） 普通流行内块非替换元素（原：'inline-block', non-replaced elements in normal flow） 普通流行内块替换元素（原：'inline-block', replaced elements in normal flow） 对于 1-6 和 9-10，在有相对定位元素的情况下 top 和 bottom 的值，见 9.4.3 小节的规则。 注意：下面计算的 height 的应用值是暂时的值，可能需要多次计算，具体取决于 min-height 和 max-height，见下面 最小和最大高度 部分。 10.6.1 行内非替换元素 height 属性不适用。 内容区域的高度应基于字体，但该规范并未定义。 比如，UA 可以使用 em-box 或者 字体的上行字符和下行字符。（后者能确保在 em-box 上方或下方的字形仍然能够落在内容区域内，但会导致不同字体有大小不同的盒子；前者能确保作者可以控制相对于 line-height 的背景样式，但会导致字形会绘制在内容区域之外。） 注意：CSS 3 可能会有一个属性，用于选择用于内容高度的字体的测量方法的属性。 行内非替换元素的垂直填充、垂直边框、垂直外边距是从 内容区域 的顶部和底部开始，与 line-height 无关。但在计算行盒子的高度时只使用 line-height。 如果使用了多种字体（不同种字体都有字形会发生这种情况），那么本规范并没定义内容区域的高度。但是，我们建议选择的内容区域高度应该足够高，以便容纳（1）em-boxes 或元素所有字体的上行字符和下行字符。注意，这可能比所涉及的任何字体大小都大，具体还取决于字体的基线对齐方式。 10.6.2 行内替换元素，普通流块级替换元素，普通流行内块替换元素，浮动替换元素 如果 margin-top 和 margin-bottom 的计算值为 auto，则应用值为 0。 如果 height 和 width 的计算值都为 auto ，且元素也有固定高度，那么 height 的应用值是该固定高度。 否则，如果 height 的计算值为 auto，且元素也有固有比率，那么 height 的应用值：(used width) * (intrinsic ratio)。 否则，如果 height 的计算值都为 auto ，且元素也有固定高度，那么 height 的应用值是该固定高度。 否则，如果 height 的计算值都为 auto ，但没有满足上述条件，那么 height 的应用值必须设置为比例为 2:1，高度不超过 150 px 且宽度不超过设备宽度的最大矩形的高度。 10.6.3 overflow 的计算值为 visible 的普通流块级非替换元素 本节也适用于普通流块级非替换元素，当 overflow 的计算值不为 visible 但已传播到 视口时。 如果 margin-top 和 margin-bottom 的计算值都为 auto ，那么它们的应用值为 0。如果 height 为 auto，那么高度取决于是否有任何块级子级以及是否有填充或边框： 元素的高度是从其内容的边缘顶部到下面第一个适用的（位置）的距离： 如果盒子为单行或多行创建了行内格式化上下文，那么（位置为）最后一个行盒子的边缘底部。 如果（元素）子级的外边距底部没有与元素的外边距底部合并的话，那么（位置为）最后一个流内子级外边距底部（可能合并了）的边缘底部。 如果（最后一个流内子级）的外边距顶部没有与元素的外边距底部合并的话，那么（位置为）最后一个流内子级的边框边缘底部。 否则，为 0。 只考虑普通流中的子级（即，会忽略浮动盒子和绝对定位的盒子，会考虑相对定位的盒子但不考虑其偏移）。注意，子级盒子可以是一个匿名块盒子。 10.6.4 绝对定位非替换元素 出于本节和下一节的目的，（元素的）静态位置（static position）这一术语粗略指的是元素在普通流中的位置。 更确切的说，top 的静态位置是指 包含块的顶部边缘 到 假想盒子的顶部外边距边缘 的距离，假想盒子为元素的第一个有 position: static; float: none; clear: none 盒子。（注意，由于 9.7 小节的规则，可能会为 display 假定一个（与指定值）不同的计算值）如果假想盒子在其包含块的上面，则 top 值为负。 但不用实际计算假象盒子的实际大小，用户代理可以自由猜测其可能的位置。 为了计算静态位置，固定定位元素的包含块是初始包含块而不是视口。 对于绝对定位元素，垂直方向大小的应用值必须受到以下约束： 'top' + 'margin-top' + 'border-top-width' + 'padding-top' + 'height' + 'padding-bottom' + 'border-bottom-width' + 'margin-bottom' + 'bottom' = 包含块的高度 如果 top、height、bottom 的值都为 auto：则将 top 设置为静态位置并应用下面规则 3。 如果这三个的值都不为 auto：如果 margin-top 和 margin-bottom 的值都为 auto，则在（上下）两边外边距相等的条件下求解方程。如果 margin-top 或 margin-bottom 中一个值为 auto，则求解（为 auto 的）这个值。如果这些值被 “过度约束” 了，则忽略 bottom 的值，再求解该值。 否则，就选择下面 6 条规则的中的一条应用： 如果 top 和 height 的值为 auto 而 bottom 的值不为 auto，那么高度取决于 10.6.7 小节的内容，将值为 auto 的 margin-top 和 margin-bottom 设置为 0，然后求解 top。 如果 top 和 bottom 的值为 auto 而 height 的值不为 auto，那么将 top 设置为静态位置，将值为 auto 的 margin-top 和 margin-bottom 设置为 0，然后求解 bottom。 如果 height 和 bottom 的值为 auto 而 top 的值不为 auto，那么高度取决于 10.6.7 小节的内容，将值为 auto 的 margin-top 和 margin-bottom 设置为 0，然后求解 bottom。 如果 top 的值为 auto 而 height 和 bottom 的值不为 auto，那么将值为 auto 的 margin-top 和 margin-bottom 设置为 0，然后求解 top。 如果 height 的值为 auto 而 top 和 bottom 的值不为 auto，那么将值为 auto 的 margin-top 和 margin-bottom 设置为 0，然后求解 height。 如果 bottom 的值为 auto 而 top 和 right 的值不为 auto，那么将值为 auto 的 margin-top 和 margin-bottom 设置为 0，然后求解 bottom。 10.6.5 绝对定位替换元素 这种情况与前一种情况类似，除了元素有固定高度以外。顺序替换为： height 的应用值取决于 行内替换元素。如果 margin-top 或 margin-bottom 的指定值为 auto，则其应用值由下面规则决定。 如果 top 和 bottom 的值都为 auto，则将 top 替换为元素的静态位置。 如果 bottom 的值为 auto，则所有值为 auto 的 margin-top 或 margin-bottom 设置为 0。 如果此时 margin-top 和 margin-bottom 的值仍为 auto，则在两边外边距必须相等的条件下求解方程。 如果此时只剩下 一个值为 auto 的了，则求解方程得出该值。 如果此时值被 “过度约束” 了，则忽略 bottom 的值再求解该值。 10.6.6 复杂情况 本小节适用于： overflow 的计算值不为 none 的普通流块级非替换元素（除非 overflow 属性已经传播到了 视口） 行内块非替换元素 浮动非替换元素 如果 margin-top 或 margin-bottom 的值为 auto，则其应用值为 0。如果 height 的值为 auto，则根据 10.6.7 高度取决于该元素的后代。 对于行内块元素，在计算行盒子的高度时，使用外边距盒子。 10.6.7 块格式化上下文的 auto 高度 在某些情况下（见，10.6.4 和 10.6.6 小节），创建块格式化上下文的高度计算如下： 如果它只有行内级子级，则高度为最高行盒子的顶部与最低行盒子的底部之间的距离。 如果它只有块级子级，则高度为最高的块级子级盒子的顶部外边距边缘与最低的块级子级盒子的底部外边距直接的距离。 绝对定位子级会被忽略，且相对定位盒子会不考虑其偏移。注意，子级盒子可能是一个匿名块级盒子。 另外，如果元素有浮动后代，其底部外边距边缘低于其元素的底部内容边缘，那么需要增加高度来包含这些边缘。只考虑参与该块格式化上下文的浮动，比如，不考虑绝对定位中的后代浮动或其它浮动。 10.7 最小和最大高度：min-height 和 max-height 关键信息摘要： 属性名称：min-height 值： | | inherit 初始值：0 适用元素：除了行内非替换元素，表格行，列组以外的所有元素 继承：no 百分比：见下文 适用媒体：visual 计算值：百分比与指定值一样，或绝对长度 关键信息摘要： 属性名称：max-width 值： | | none | inherit 初始值：none 适用元素：除了行内非替换元素，表格行，列组以外的所有元素 继承：no 百分比：见下文 适用媒体：visual 计算值：百分比与指定值一样，或绝对长度，或 none 这两个属性允许作者将盒子的高度约束到一个特定范围。 值有以下含义： ：指定固定的最小或最大计算高度。 ：指定百分比来确定使用值。百分比是通过生成的盒子的包含块的高度计算的。如果未明确指定包含块的高度（即取决于内容高度），并且该元素没用绝对定位，则百分比值将当作 0（对于 min-height 来说）或 none（对于 max-height）。 none：（仅对于 max-height），盒子的高度没有限制 min-height 和 max-height 的值不能为负数。 在 CSS 2.2 中，min-height 和 max-height 对 表格、行内表格、表格单元格、表格列、列组 的影响（这种情况）并没有定义。 下面的算法描述了这两个属性如何影响 height 属性的应用值： 暂时应用的高度按照上面的 “计算高度和外边距” 的规则来计算（不考虑 min-height 和 max-height）。 如果暂时应用的高度大于 max-height，则再次应用上述的规则，但这次应用 max-height 的计算值作为 height 的计算值。 如果得到的高度小于 min-height，则再次应用上述的规则，但这次应用 min-height 的值作为 height 的计算值。 注意：这些步骤不会影响 height 的实际计算值。所以，比如，它们不会影响外边距合并，这取决于计算值。 然而，对于 width 的计算值为 auto 和 height 的计算值为 auto 的替换元素，请使用上面最小最大查找算法来找到应用的宽度和高度。然后使用上面 “计算高度和外边距” 的计算规则，使用生成的宽度和高度，表现得就好像它们是计算值一样。 10.8 行高计算：line-height 属性和 vertical-align 属性 如行内格式化上下文小节所述，用户代理会将行内级盒子放到垂直堆栈的行盒子中。行盒子的高度如下： 计算行盒子中每个行内级盒子的高度。对于替换元素、行内块元素来说，就是它们外边距盒子的高度。对于行内盒子来说，就是它们的行高（原：line-height）。 行内级盒子根据它们的 vertical-align 属性垂直对齐。如果它们对齐的是 top 或 bottom，那么它们必须对齐以便行盒子高度最小化。如果这些盒子足够高，则有多个解，但 CSS 2.2 并没有定义行内盒子的基线的位置（即，strut 的位置，见下文）。 行盒子高度为最上面的盒子顶部与最下面的盒子底部之间的距离。（如下面 line-height 有解释的 strut）。 空行内元素生成空行内盒子，但这些盒子仍然有外边距、填充、边框和行高，因此影响这些计算就像元素有内容一样。 10.8.1 行距和半行距 CSS 假设每种字体都指定了基线上方的高度和下方的深度的字体规格。在本节中，我们使用 A （对于给定字体的大小）表示高度 和 D 表示深度。我们还定义 AD = A + D，即从顶部到底部的距离（译注：top 到 bottom）。（见下面的注释，了解如何查找 TrueType 和 OpenType 字体的 A 和 D）。请注意，这些是整个字体的度量规格，不需要与任何单个字形的上行和下行对应。 用户代理必须把行内非替换盒子中的字形按照相对基线对齐。然后，对于每个字形，确定 A 和 D。请注意，单个元素的字形可能来自不同的字体，因此不一定有相同的 A 和 D。如果行内盒子根本不包含字形，就认为包含一个 strut（即一个零宽度不可见的字形），其中包含元素第一个可用字体的 A 和 D。 然后对每个字形，确定要添加的行距 L，其中 L = line-height - AD。半行距加在 A 上方，另一半在 D 下方，这能使字形及其行距在基线上方的总高度为 A' = A + L/2，总深度为 D' = D + L/2。 注意：L 可能为负数。 行内盒子的高度包含所有字形和两侧的半行距，就刚好是 “行高”。子级元素的盒子不会影响这个高度（译注：这里指的是行高）。 虽然非替换元素的外边距、边框、填充不会算进 行盒子 的计算，但它们仍然围绕行内盒子渲染。这就意味着如果 line-height 指定的高度小于所包含的内容高度，那么填充和边框的背景和颜色会渗透到相邻的行盒子中。用户代理应该按照文档顺序渲染这些盒子。这将导致后续行上的边框在前一行的边框和文本上绘制。 注意：CSS 2.2 没有定义行内盒子的内容区域（见上面的 10.6.1），因此，不同的 UA 可以在不同的地方上绘制背景和边框。 注意：建议使用 OpenType 或 TrueType 字体的实现按照 OS/2 表中的 “sTypoAscender” 和 “sTypoDescender” 规格找出相应的 A 和 D（当前元素字体大小被缩放后）。如果没有这些规格，那么应该使用 HHEA 表中的 \"Ascent\" 和 \"Descent\" 规格。 关键信息摘要： 属性名称：line-height 值：normal | | | | inherit 初始值：normal 适用元素：所有元素 继承：yes 百分比：相对元素自身的字体大小 适用媒体：visual 计算值：对于 和 为绝对值。否则就和指定值一样 在内容由 行内级元素 组成的块容器元素上，line-height 指的是元素里行盒子的最小高度。这个最小高度包含了基线上方的最小高度和其下方的最小深度，就好像每个行盒子以 零宽度行内盒子 开始一样，其中包含了元素的字体和行高属性。我们称这个假象盒子为 “strut”。（名字灵感来源于 “TeX”）。 假设基线上方和下方的高度深度被包含在字体的规格中。（更多信息，见 CSS level 3）。 在行内非替换元素中，line-height 指定的高度是用来计算行盒子高度。 值有以下含义： normal：告诉用户代理根据元素字体设置为一个 “合理” 值。该值与 含义相同。我们推荐使用 normal 的值在 1.0 到 1.2 之间。计算值为 normal。 ：指定的长度用于计算行盒子高度。不能为负数。 ：属性的应用值是此数字乘以当前元素的字体大小。不能为负数。计算值和指定值一样。 ：属性的计算值是此百分比乘以当前元素的字体大小。不能为负数。 下面三条规则行高一样： div { line-height: 1.2; font-size: 10pt } /* number */ div { line-height: 1.2em; font-size: 10pt } /* length */ div { line-height: 120%; font-size: 10pt } /* percentage */ 当元素包含的文本以多种字体呈现时，用户代理可以根据最大的字体大小来确定 normal（状态下的）line-height 值。 注意：当一个块容器盒子里的所有行内盒子只有一个 line-height 的值 且 都是相同的字体（且没有替换元素、行内块元素等）时，这时候能确保连续行的基线之间刚好相隔 line-height。这一点在对于不同字体的文本列必须对齐时很重要，比如，在表格中。 关键信息摘要： 属性名称：vertical-align 值：baseline | sub | super | top | text-top | middle | bottom | text-bottom | | | inherit 初始值：baseline 适用元素：行内级元素和表格单元元素 继承：no 百分比：相对元素自身的 line-height 适用媒体：visual 计算值：对于 和 为绝对值。否则就和指定值一样 此属性会影响由行内级元素生成的盒子里的行盒子里的垂直位置。 注意：此属性的值在表格的上下文中有着不同的含义。有关详细信息，请参考 表格高度算法 小节。 以下值只对父级行内元素或父级块容器元素的 strut 有用。 在以下定义中，对于行内非替换元素来说，用于对齐的盒子是高度为 “行高” 的盒子（包含盒子的字形和两侧的半行距，见上文）。对于所有其它元素，用于对齐的盒子是外边距盒子。 baseline：将盒子的基线与父级盒子的基线对齐。如果盒子没有基线，就把底部外边距边缘与父级基线对齐。 middle：将盒子的垂直中点与父级盒子的基线加上父级盒子的 x-height 的一半对齐。 sub：将盒子的基线降低到合适的位置作为父级盒子的下标。（此值对元素文本的字体大小没有影响） super：将盒子的基线提升到合适的位置作为父级盒子的上标。（此值对元素文本的字体大小没有影响） text-top：将盒子的顶部与与父级内容区域对齐。（见 10.6.1） text-bottom：将盒子的底部与与父级内容区域对齐。（见 10.6.1） ：将盒子提升（正值）或降低（父值）这个距离（line-height 值的百分比）。值 0% 意味着与基线相同。 ：将盒子提升（正值）或降低（父值）这个距离。值 0cm 意味着与基线相同。 以下值将元素相对于行盒子对齐。由于元素有相对于它对齐的子级（同样地，也有可能有子级对齐的后代），所以这些值应用对齐子树的边界。行内元素的对齐子树包含该元素和所有子级行内元素的对齐子树，其 vertical-align 的计算值不为 top 或 bottom。对齐子树的顶部是子树中盒子顶部的最高处，底部是类似的。 top：将对齐子树的顶部与行盒子的顶部对齐。 bottom：将对齐子树的部底与行盒子的底部对齐。 inline-table 的基线是表格第一行的基线。 inline-block 的基线是在普通流中最后一个行盒子的基线，除非它没有流内行盒子或 overflow 属性的计算值不是 visible，无论在哪种情况下，基线就是底部外边距边缘。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-29 19:44:00 "},"docs/CSS/CSS2.2/11 视觉效果.html":{"url":"docs/CSS/CSS2.2/11 视觉效果.html","title":"11 视觉效果","keywords":"","body":"11 视觉效果 11.1 溢出和裁剪 通常来说，块盒子的内容（原：content）被限制在盒子的内容边缘里。在某些情况下，盒子可能会溢出，这就意味着它的内容可能有一部分或全部在盒子之外。 比如： 一行不能被破坏，导致行盒子比块盒子更宽。 块级盒子对于包含块来说太宽。当元素的 width 属性具有 使得 生成的块盒子 溢出 包含块的边的 值时，可能会发生这种情况。 元素的高度超过分配给包含块的显示高度（即，包含块的高度由 height 属性决定，而不是由内容高度决定的）。 后代盒子绝对定位，有一部分位于盒子外面。这些盒子并不总是会被祖先的 overflow 属性所裁剪。具体的说，它们不会被介于自身与包含块之间的祖先的 overflow 属性所裁剪。 后代盒子可能有负的外边距，导致有一部分位于盒子外面。 text-indent 属性导致行内盒子挂在块盒子的左边缘或右边缘。 每当溢出发生时，overflow 属性指定是否将盒子裁剪到其填充边缘里。如果是，则将提供滚动机制来访问任何裁剪掉的内容。 11.1.1 溢出：overflow 属性 关键信息摘要： 属性名称：overflow 值：visible | hidden | scroll | auto | inherit 初始值：visible 适用元素：（块容器和创建格式化上下文的盒子） 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 此属性指定块容器元素的内容在溢出元素盒子时是否被裁剪。它影响元素内容（content）的所有的裁剪除后代元素之外（及其各自的后代元素和内容），这个后代元素的包含块是 视口 或 元素的祖先。 属性值具有以下含义： visible：该值说明 内容（content）没有被裁剪，即可以在块盒子之外渲染。 hidden：该值说明 内容（content）被裁剪，且不应该提供滚动的用户界面（user interface）来访问裁剪区域的内容， scroll：该值说明 内容（content）已被裁剪，如果用户代理使用了屏幕上可见的滚动机制（例如滚动条或平移器），则无论对于一个盒子来说，无论是否有任何内容被裁剪，该滚动机制都应该显示。这个避免了滚动条在动态环境中出现或消失的任何问题。指定该值时并且目标媒介为 print 时，可能会打印溢出的内容。在使用表格盒子的时候，该值与 visible 效果一致。 auto：该值的行为取决于 用户代理，但应该为 溢出的盒子 提供滚动机制。在使用表格盒子的时候，该值与 visible 效果一致。 TODO 11.1.2 裁剪：clip 属性 裁剪区域定义了元素的 border box 的哪部分可见。默认情况下，元素不会被裁剪，但裁剪区域可以用 clip 属性明确设置。 关键信息摘要： 属性名称：clip 值： | auto | inherit 初始值：auto 适用元素：absolutely positioned elements 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：'auto' if specified as 'auto', otherwise a rectangle with four values, each of which is 'auto' if specified as 'auto' and the computed length otherwise clip 属性仅适用于绝对定位元素。 此属性的值具有以下含义： auto：该元素不会被裁剪 ： 在 CSS2.2 中，唯一有效的 值是：rect(, , , )，其中 和 指定的是 盒子顶部边框边缘的偏移量（the top border edge of the box）， 和 指定的是 盒子左侧边框边缘的偏移量。使用者应该使用 逗号 去分隔偏移值。用户代理必须支持逗号分隔，但也可以支持不使用逗号不分隔（但不能组合）。因为此规范的之前版本在这方面不明确。 , , , 可能具有 值或 auto。值为 auto 情况下表示裁剪区域的给定的边缘将和元素生成的盒子的 border box 的边缘相同（即 auto 表示 和 的值为 0， 的值为 border-top + padding-top + height + padding-bottom + border-bottom， 的值为 border-left + padding-left + width + padding-right + border-right，其实就是裁剪区域与元素的 border box 一致） 当坐标四舍五入为像素坐标时，应注意当 和 的值相同（或 和 ）时，没有像素保持可见。相反，当没有像素的元素的 border box里依旧是隐藏的。 元素的裁剪区域可以裁剪元素的一切（比如：content、children、background、borders、text decoration、outline，如果有可见的滚动机制照样剪）。已裁剪的内容不会导致溢出。 元素的祖先也可以裁剪其内容的一部分（比如 通过它们的 clip 属性 和|或 如果它们的 overflow 属性不是 visible），渲染的一部分就是交集。 如果裁剪区域超出 UA 文档窗口的边界，则内容可能被 本地操作环境 给裁剪到窗口。 案例分析： p {position: absolute;} p#one { clip: rect(5px, 40px, 45px, 5px); } p#two { clip: rect(5px, 55px, 45px, 5px); } 假设俩个 p 都为 50 * 55px，将分别创建由下图中虚线界定的矩形裁剪区域： 在 CSS2.2 中，所有的裁剪区域都是矩形。未来的扩展将允许非矩形裁剪。未来还可能基于边缘偏移形状而不是基于点偏移的语法。 11.2 可见性：visibility 属性 关键信息摘要： 属性名称：visibility 值：visible | hidden | collapse | inherit 初始值：visible 适用元素：所有元素 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified visibility 属性指定元素生成的盒子是否呈现（rendered）。不可见的盒子仍然会影响布局（layout）（display 属性设置为 none 是禁止生成盒子）。 此属性的值具有以下含义： visible：生成的盒子可见 hidden：生成的盒子不可见（完全透明、没有绘制任何内容），但仍会影响布局。此外，如果元素的 visibility 属性是可见的（visible），则后代都是可见的。 collapse：请参考表格章节有关动态行和列效果的部分。如果用在元素（除了 rows、row groups、columns、column groups 之外），则 collapse 与 hidden 一致。 这个属性可以与脚本使用创建动态效果。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-29 20:09:40 "},"docs/CSS/CSS2.2/12 生成内容，自动编号，列表.html":{"url":"docs/CSS/CSS2.2/12 生成内容，自动编号，列表.html","title":"12 生成内容，自动编号，列表","keywords":"","body":"12 生成内容，自动编号，列表（Generated content, automatic numbering, and lists） 某些情况下，作者可能想让 用户代理 渲染来自 文档树 之外的内容。一个熟悉的例子就是编号列表，作者不想显示地列出编号，他或她想让用户代理自动生成它们。类似的，作者可能想让用户代理在一幅图像的标题之前插入 \"图\" 这个字，或者在第七章标题之前插入 \"第七章\"。特别是对于音频或盲文，用户代理应该能够插入这些字符串。 在 CSS2.2 中，内容可以通过这两种机制生成： content 属性，与 :before 和 :after 伪元素一起使用。 display 属性的值为 list-item 的元素。 12.1 :before 伪元素和 :after 伪元素（The :before and :after pseudo-elements） 作者可以指定由 :before 和 :after 伪元素生成的内容 的样式和位置。如同它们的名字一样，:before 和 :after 伪元素指定了 元素文档树内容之前和之后 的内容位置。content 属性，与这些伪元素共同指定了插入的内容。 比如，下面规则在每个 class 属性值 含有 \"note\" 的 元素的内容之前插入了字符串 \"Note: \"： p.note:before { content: \"Note: \" } 由元素生成的格式化对象（比如，盒子）包括生成的内容。因此，把上面的样式表改为： p.note:before { content: \"Note: \" } p.note { border: solid green } 将让整个段落周围都呈现出绿色的边框，包括 起始处（插入的）字符串。 :before 和 :after 伪元素会从文档树中它们附着的元素上继承所有可继承的属性。 比如，下面规则在每个 元素前插入了一个左引号(')。引号的颜色将是红色的，但字体与 元素其余部分的字体相同： q:before { content: open-quote; color: red } 在 :before 或 :after 伪元素声明中，不可继承的属性的值为初始值 因此，比如，因为 display 属性的初始值为 inline，前一个示例中的引号会被当作一个 行内盒子 插入（即，与该元素的起始处文本内容在同一行）。下一个示例显式地把 display 属性设置为 \"block\" 了，以致于插入的文本变成了一个块： body:after { content: \"The End\"; display: block; margin-top: 2em; text-align: center; } :before 或 :after 伪元素会与其它盒子相互影响，就像它们是插在其相关元素里的真实元素一样 比如，以下文档片段和样式表： Text p:before { display: block; content: 'Some'; } 将与下列文档片段和样式表的渲染（方式）完全相同： Some Text span { display: block } 类似的，:after 同理。 12.2 content 属性（The 'content' property） 关键信息摘要： 属性名称：content 值：normal | none | [ | | | attr() | open-quote | close-quote | no-open-quote | no-close-quote ]+ | inherit 初始值：normal 适用元素：:before and :after pseudo-elements 继承：no 百分比：N/A 适用媒体：all 计算值：对于元素，计算值为 normal。对于 :before 和 :after，如果指定值为 normal，计算值就是 none。否则，对于 URI 值，（计算值）就是绝对 URI；对于 attr() 值，就是产生的字符串；对于其它关键字，就与指定值相同。 此属性与 :before 和 :after 伪元素一起使用。值具有以下含义： none：不生成伪元素 normal：:before 和 :after 伪元素的计算值为 none ：文本内容，见 字符串 小节 ：该值是一个 URI，指定了一个外部资源（比如一张图片）。如果用户代理无法显示该资源，则必须将其保留为未指定，或显示资源无法显示的某些提示 ：计数器可以指定两个不同的函数：counter() 或 counters()。 前者有两种形式：counter(name) 或 counter(name, style)。生成的文本是该伪元素所在作用域中名为给定 name 的最内层计数器的值，被格式化为指定的 style（默认是 \"decimal\"） 后者有两种形式：counters(name, string) 或 counters(name, string, style)。生成的文本是该伪元素所在作用域中的所有名为给定 name 的计数器的值，从最外层到最内层，由指定 string 分隔。计数器被渲染为指定的 style（默认是 \"decimal\"）。更多信息见自动计数器与编号。name 必须不为 \"none\"、\"inherit\" 或者 \"initial\"，这样的 name 会导致声明被忽略掉 open-quote 和 close-quote：这些值会根据 quotes 属性替换为合适的字符串 no-open-quote 和 no-close-quote：不引入内容，但会增加（减少）引号的嵌套层级 attr(X)：该函数返回一个字符串，为该选择器的对象（原：subject）的 X 属性的值。该字符串不会被CSS处理器解析。如果该选择器的对象没有 X 属性，就返回一个空字符串。属性名的大小写敏感性取决于文档语言 注意：在 CSS2.2 中，不能引用除 选择器对象 之外的其它元素的属性。 display 属性控制内容是放在一个 块盒子 里，还是一个 行内盒子 里。 下列规则会在每个 元素前生成字符串 \"Chapter: \"： h1:before { content: \"Chapter: \"; display: inline; } 作者可以通过在 content 属性后面的字符串中写上 \"\\A\" 转义序列，以此在生成的内容中包含 换行（原：newlines）。插入的这个行结束符也受 white-space 属性约束。关于 \"\\A\" 转义序列的更多信息见 \"字符串\" 与 \"字符和大小写\" h1:before { display: block; text-align: center; white-space: pre; content: \"chapter\\A hoofdstuk\\A chapitre\" } 生成的内容不会改变文档树。特别的，它不会反馈给文档语言处理器（例如，用于重新解析）。 12.3 引号（Quotation marks） 在 CSS2.2 中，作者可以指定 用户代理 应该怎样渲染 引号。以 风格敏感的（原：style-sensitive）还是依赖上下文的（原：context-dependent）方式。quotes 属性为每层内嵌引用指定了引号对。content属性允许访问那些引号，并且会让他们在一个引用之前和之后插入。 12.3.1 用 quotes 属性指定引号 关键信息摘要： 属性名称：quotes 值：[ ]+ | none | inherit 初始值：depends on user agent 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性为所有内嵌引用指定了引号。值具有以下含义： none：值为 \"open-quote\" 和 \"close-quote\" 的 content 属性不会产生引号 [ ]+：值为 \"open-quote\" 和 \"close-quote\" 的 content 属性从（属性值）列出的引号（左引号和右引号）对中取。第一（最左边的）对代表最外层引用，第二对是第一层内嵌，等等。用户代理必须根据嵌套层级来应用合适的引号对 比如，应用下面的样式表： /* Specify pairs of quotes for two levels in two languages */ q:lang(en) { quotes: '\"' '\"' \"'\" \"'\" } q:lang(no) { quotes: \"«\" \"»\" '\"' '\"' } /* Insert quotes before and after Q element content */ q:before { content: open-quote } q:after { content: close-quote } 到下面的 HTML 片段： Quotes Quote me! 会允许用户代理产生： \"Quote me!\" 如果是这个 HTML 片段： Quotes Trøndere gråter når Vinsjan på kaia blir deklamert. 将会产生： «Trøndere gråter når \"Vinsjan på kaia\" blir deklamert.» 注意：尽管前一个示例中通过 quotes 指定的引号都很方便地位于计算机键盘上，但高质量排版将会需要不同的 ISO 10646 字符。下面信息性的表格列出了一些 ISO 10646 引号字符： Character Approximate rendering ISO 10646 code (hex) Description \" \" 0022 QUOTATION MARK [the ASCII double quotationmark] ' ' 0027 APOSTROPHE [the ASCII single quotation mark] ‹ 2039 SINGLE LEFT-POINTING ANGLE QUOTATION MARK › > 203A SINGLE RIGHT-POINTING ANGLE QUOTATION MARK « « 00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK » » 00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK ‘ ` 2018 LEFT SINGLE QUOTATION MARK [single high-6] ’ ' 2019 RIGHT SINGLE QUOTATION MARK [single high-9] “ `` 201C LEFT DOUBLE QUOTATION MARK [double high-6] ” '' 201D RIGHT DOUBLE QUOTATION MARK [double high-9] „ ,, 201E DOUBLE LOW-9 QUOTATION MARK [double low-9] 12.3.2 用 content 属性插入引号 可以用值为 open-quote 和 close-quote 的 content 属性插入文档中合适的位置。根据嵌套的深度，出现的每个 open-quote 或 close-quote 会被替换成 quotes 的某一个字符串。 open-quote 表示一对引号中的第一个，close-quote 表示一对引号中的第二个。使用哪一对引号由嵌套的深度决定：open-quote 在当前位置之前的所有生成文本中的出现次数 - close-quote 的出现次数。如果深度为 0，使用第一对；如果深度为 1，使用第二对；等等。如果 深度 大于（引号）对数，就重复使用最后一对。一个会让深度变为负数的 close-quote 或 no-close-quote 属于错误情况，会被忽略掉（在渲染时）：深度为 0 且不渲染引号（尽管仍然会插入 content 属性值的其余部分）。 注意：引用深度独立于源文档或者格式化结构的嵌套。 一些排版样式需要让 左引号在横跨多段的引用中 的每个段落前重复，但只在最后一段的结尾处有一个右引号。CSS中，这可以通过插入 \"虚拟\"（原：phantom）的右引号来实现。关键字 no-close-quote 能减少引用层级，但不会插入引号 下列样式表会给 中的每个段落添上一个左引号，并在末尾插入一个右引号： blockquote p:before { content: open-quote } blockquote p:after { content: no-close-quote } blockquote p.last:after { content: close-quote } 这需要给最后一段标记 .last。 同理，也有一个 no-open-quote 关键字，不插入任何东西，但会让引用深度加 1。 12.4 自动计数器和编号（Automatic counters and numbering） 自动编号在 CSS2.2 中是通过两个属性控制的，counter-increment 和 counter-reset。这些属性定义的计数器 和 content 属性的值里的 counter() 和 counters() 函数配合使用。 关键信息摘要： 属性名称：counter-reset 值：[ ? ]+ | none | inherit 初始值：normal 适用元素：all elements 继承：no 百分比：N/A 适用媒体：all 计算值：as specified 关键信息摘要： 属性名称：counter-reset 值：[ ? ]+ | none | inherit 初始值：normal 适用元素：all elements 继承：no 百分比：N/A 适用媒体：all 计算值：as specified counter-increment 属性接受一个或多个计数器名称（标识符），每个后面都可以跟一个可选的整数。这个整数表示每次出现该元素时计数器递增几。默认增量是 1，可以接受 0 和负数。 counter-reset 属性也包含一个或多个计数器名称，每个后面可以跟一个可选的整数。该整数给定了每次出现该元素时给计数器设置的值，默认为 0。 关键字 none、inherit和 initial 不能用作计数器名。值为 none 表示不需要重置或者递增计数器。inherit 表示它（指：inherit）的一般含义（见6.2.1）。inherit 是为将来的用法保留的。 本例展示了一种把章节编号为 \"Chapter 1\"，\"1.1\"，\"1.2\" 等等的方式： body { counter-reset: chapter; /* Create a chapter counter scope */ } h1:before { content: \"Chapter \" counter(chapter) \". \"; counter-increment: chapter; /* Add 1 to chapter */ } h1 { counter-reset: section; /* Set section to 0 */ } h2:before { content: counter(chapter) \".\" counter(section) \" \"; counter-increment: section; } 如果元素 递增/重置（原：increments/resets）一个计数器并使用了它（在其 :before 或 :after 伪元素的 content 属性中），计数器是在递增/重置之后才使用的。 如果元素 重置并递增 了一个计数器，计数器会先重置再递增。 如果给同一个计数器指定了多次 counter-reset 和 counter-increment 属性的值，计数器的每次重置/递增会按指定的顺序来处理。 下例会把 \"section\" 计数器重置为0： h1 { counter-reset: section 2 section } 下例会把 \"chapter\" 计数器递增到3： h1 { counter-increment: chapter chapter 2 } counter-reset 属性遵循层叠规则。因此，由于层叠，下列样式表： h1 { counter-reset: section -1 } h1 { counter-reset: imagenum 99 } 只会重置 \"imagenum\"。要同时重置两个计数器的话，它们必须一起指定： h1 { counter-reset: section -1 imagenum 99 } 12.4.1 嵌套计数器与作用域 计数器是 \"自嵌套的\"，在某种意义上如果重置一个 位于后代元素或伪元素中的 计数器，则会自动创建创建一个新的计数器实例。这对 HTML 中的列表之类的场景来说很重要，在这种场景下，元素嵌套在任意深度内，无法为每一层定义计数器唯一的命名。 因此，如下（样式表）就可以给嵌套列表项编号。结果与给 元素设置 display: list-item 和 list-style: inside 非常相似： ol { counter-reset: item } li { display: block } li:before { content: counter(item) \". \"; counter-increment: item } 计数器的作用域从文档中具有 counter-reset 该计数器的第一个元素开始，包括该元素的后代和后续兄弟及其后代。但不包括处于同名计数器作用域中的任何元素，（同名计数器）由该元素的后续兄弟或后续同（类型）元素的 counter-reset 创建。 如果一个元素或伪元素上的 counter-increment 或者 content 引用了一个不处于任何 counter-reset 作用域的计数器，实现应该表现得就像已经通过该元素或伪元素上的 counter-reset 把该计数器重置为 0 了一样。 上例中， 将会创建一个计数器，并且 的 所有子元素 将引用该计数器。 如果我们用 \"item[n]\" 表示 \"item\" 计数器的第 n 个实例，用 \"{\" 和 \"}\" 表示一个作用域的开始和结束，那么下列 HTML 片段将使用标注的计数器（我们假设样式表是上例中给出的那个） item item item item item item item item item item item item 另一个示例，下面展示了当计数器用在非嵌套元素时作用域的工作方式。展示了上面给出的用来为章节编号的样式表是怎样应用于给定标记的。 About CSS CSS 2 CSS 2.1 Style counters() 函数生成一个由作用域内所有同名计数器组成的字符串，用给定的字符串分隔。 下列样式表会把嵌套的列表项编号为 \"1\"、\"1.1\"、\"1.1.1\" 等等 ol { counter-reset: item } li { display: block } li:before { content: counters(item, \".\") \" \"; counter-increment: item } 12.4.2 计数器样式（Counter styles） 默认情况下，计算器会被格式化成十进制，但 list-style-type 属性的所有可用样式也可以用于计数器，表示方式为： counter(name) 对应默认样式（计数器），或者： counter(name, ) 所有样式都是合法的，包括'disc'，'circle'，'square'和'none' h1:before { content: counter(chno, upper-latin) \". \" } h2:before { content: counter(section, upper-roman) \" - \" } blockquote:after { content: \" [\" counter(bq, lower-greek) \"]\" } div.note:before { content: counter(notecntr, disc) \" \" } p:before { content: counter(p, none) } 12.4.3 'display: none' 的元素的计数器 不显示（display: none）的元素不会让计数器重置或递增。 比如，用下列样式表，具有 \"secret\" 类的 不会让 \"count2\" 计数器递增： h2.secret {counter-increment: count2; display: none} 没生成的伪元素也不会让计数器重置或递增。 比如，如下（样式表）不会让 \"heading\" 计数器递增： h1::before { content: normal; counter-increment: heading; } 12.5 列表（Lists） CSS2.2 提供了列表的基本视觉格式化。display: list-item 的元素会给元素的内容（原：content）生成一个 主块盒子（原：principal block box），并且根据 list-style-type 的值和 list-style-image 的值，可能还有一个 标记盒子（原：marker box）作为视觉指示，表明该元素是个列表项。 list 属性描述了列表的视觉格式化：它们允许样式表指定标记类型（图片，字形或者数字）以及相对于该 主盒子（原：principal box）的标记位置（在它内部或外部，在内容之前）。但它们不允许作者为列表标记指定不同的样式（颜色、字体、对齐等等）或调整相对于 主盒子 的位置，这些都会从 主盒子 去继承。 background 属性只适用于 主盒子，外部（原：outside）的 标记盒子 是透明的。 12.5.1 列表：list-style-type、list-style-image、list-style-position、 list-style 属性 关键信息摘要： 属性名称：list-style-type 值：disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit 初始值：disc 适用元素：elements with 'display: list-item' 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性指定了 列表项标记 的外观。如果 list-style-image 为 none 或者如果 URI 指向的图片无法显示的话，none 值不指定标记，否则有三种标记类型：字形，编号系统（原：numbering systems）和字母系统（原：alphabetic systems）。 字形通过 disc、circle 和 square 来指定。用户代理决定其最终的呈现效果。 编号系统通过下列（值）来指定： decimal：十进制数，从 1 开始 decimal-leading-zero：（左）填充了 0 的十进制数（比如：01, 02, 03, ..., 98, 99） lower-roman：小写的罗马数字（比如：i, ii, iii, iv, v, ...） upper-roman：大写的罗马数字（比如：I，II，III，IV，V, ...） georgian：传统的格鲁吉亚（原：Georgian）编号（an，ban，gan，...，he，tan，in，in-an，...） armenian：传统的大写亚美尼亚（原：Armenian）编号 字母系统通过下列（值）来指定： lower-latin 或 lower-alpha：小写 ascii 字母（a，b，c，... z） upper-latin 或 upper-alpha：大写 ascii 字母（A，B，C，... Z） lower-greek：小写古典希腊 alpha、beta、gamma，... （α，β，γ，...） 本规范没有定义字母系统在字母表结束处怎样处理（剩下的列表），比如，在 26 个列表项之后，lower-latin 的渲染是未定义的。因此，对于长列表，我们建议作者指定真正的数字。 CSS 2.2 没有定义列表编号怎样重置和递增。预期在 CSS List Module [CSS3LIST] 定义它。 比如，下列 HTML 片段： Lowercase latin numbering ol { list-style-type: lower-roman } This is the first item. This is the second item. This is the third item. 可能产生以下的结果： i This is the first item. ii This is the second item. iii This is the third item. 列表标记对齐方式（这里是右对齐）由用户代理决定。 关键信息摘要： 属性名称：list-style-image 值： | none | inherit 初始值：none 适用元素：elements with 'display: list-item' 继承：yes 百分比：N/A 适用媒体：visual 计算值：absolute URI or 'none' 该属性设置了将用作列表项标记的图像。当图像可用时，它将代替用 list-style-type 设置的标记。 图像的尺寸根据下列规则计算： 如果该图像具有固有宽高，宽高的应用值就是固有宽高 否则，如果该图像具有固有比例和固有宽度或固有高度，宽/高的应用值与提供的固有宽/高相同，缺失的尺寸的应用值根据已提供的尺寸和比例来计算 否则，如果图像具有固有比例，则宽度的应用值为 1em，高度的应用值根据这个宽度和固有比例计算。如果这会让高度大于 1em，那么高度的应用值就设置为 1em，宽度的应用值根据这个高度和固有比例来计算 否则，该图像宽度的应用值为其固有宽度，如果有的话，否则就是 1em。图片高度的应用值为其固有高度，如果有的话，否则就是 1em 下例把每个列表项的开始处的标记设置为图片 \"ellipse.png\"： ul { list-style-image: url(\"http://png.com/ellipse.png\") } 关键信息摘要： 属性名称：list-style-position 值：inside | outside | inherit 初始值：outside 适用元素：elements with 'display: list-item' 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性指定了标记盒子相对于主块盒子的位置。值含义如下： outside：标记盒子位于主块盒子外部。列表项标记的位置与浮动（盒子）相邻的情况在 CSS2.2 中是未定义的。CSS2.2 没有指定标记盒子的精确位置和它在绘制顺序中的位置，但对于那些 direction 属性为 ltr 的列表项，标记盒子必须位于内容的右边。标记盒子相对于主块盒子的边界固定，不会随主块盒子的内容滚动。CSS2.2 中，UA 可能会隐藏标记，如果该元素的 overflow 不为 visible 的话（这在将来可能会变更）。标记盒子的尺寸或内容可能会影响 主块盒子的高度 和/或其 第一个行盒子 的高度，某些情况下，可能会创建一个新的行盒子。注意：这种相互影响可能会在将来的 CSS 版本中进行更精确的定义。 inside：标记盒子位于主块盒子的第一个行盒子里，在该元素的内容和所有 :before 伪元素之前。CSS2.2 没有指定标记盒子的精确位置。 案例分析： Comparison of inside/outside position ul { list-style: outside } ul.compact { list-style: inside } first list item comes first second list item comes second first list item comes first second list item comes second 上例可能会被格式化成： 在从右向左的文本中，标记将位于该盒子的右边。 关键信息摘要： 属性名称：list-style 值：[ || || ] | inherit 初始值：see individual properties 适用元素：elements with 'display: list-item' 继承：yes 百分比：N/A 适用媒体：visual 计算值：see individual properties list-style 属性是在样式表中一次性设置 list-style-type、list-style-image 和 list-style-position 三个属性的简写表示法： ul { list-style: upper-roman inside } /* Any \"ul\" element */ ul > li > ul { list-style: circle outside } /* Any \"ul\" child of an \"li\" child of a \"ul\" element */ 尽管作者可以直接给列表项元素（比如，HTML中的 ）指定 list-style 信息，但这样做要特别小心。下列规则看起来很相似，但第一条声明了一个后代选择器，而第二条声明了一个（更特殊的）子选择器： ol.alpha li { list-style: lower-alpha } /* Any \"li\" descendant of an \"ol\" */ ol.alpha > li { list-style: lower-alpha } /* Any \"li\" child of an \"ol\" */ 那些只用后代选择器的作者可能无法得到他们预期的结果。考虑下列规则： WARNING: Unexpected results due to cascade ol.alpha li { list-style: lower-alpha } ul li { list-style: disc } level 1 level 2 想要的渲染效果是让 1级 列表项带有 \"lower-alpha\" 标签，2 级列表项带有 \"disc\" 标签。然而，层叠顺序会让第一条样式规则（包括特殊类信息的）掩盖掉第二条。下列规则通过换用子选择器解决了这个问题： ol.alpha > li { list-style: lower-alpha } ul li { list-style: disc } 另一个方案是只对列表类型的元素指定 list-style 信息： ol.alpha { list-style: lower-alpha } ul { list-style: disc } 继承机制会让 list-style 的值从 和 元素转移到 元素。这是指定列表样式信息的推荐方式。 一个 URI 值可以与其它值结合起来，如： ul { list-style: url(\"http://png.com/ellipse.png\") disc } 上例中，当图片不可用时，将使用 \"disc\"。 list-style 属性的 \"none\" 值会把（简写属性中）未声明的 list-style-type 和list-style-image 设置成 \"none\"。然而，如果（在简写属性中）同时指定了两者，声明将出错（因而被忽略）： ul { list-style: none disc url(bullet.png) } 比如，值为 \"none\" 的 list-style 属性会把 list-style-type 和 list-style-image 设置为 \"none\"： ul { list-style: none } 结果是不会显示列表项标记。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-09-22 11:59:07 "},"docs/CSS/CSS2.2/13 分页媒体.html":{"url":"docs/CSS/CSS2.2/13 分页媒体.html","title":"13 分页媒体","keywords":"","body":"13 分页媒体 13.1 分页媒体简介 分页媒体（比如，纸、幻灯片、显示在计算机屏幕上的页面等等）与连续媒体的区别是文档的内容分布在一个或者多个不连续的页里。为了处理页面，CSS2.2 描述了怎样给页盒设置页外边距，以及怎样声明分页符。 用户代理负责把一个文档的页面盒子转换到最终渲染文档的真实纸张（纸、幻灯片、屏幕等等）上。通常页盒与页之间都有一对一的关系，但并不总是这样。可能的转换情况包括： 把一个页面盒子转换到一个页面（比如，单面打印） 把两个页面盒子转换到同一页的两面（比如，双面打印） 把 N 个（较小的）页面盒子转换到一个页（叫 \"分栏\"） 把一个（较大的）页盒转换到 N x M 个页（叫 \"拼图\"） 创建签名。签名是在一页上打印一组页面，折叠裁剪时像本书一样，以其适当的顺序出现 把一份文档打印到多个输出盘 输出到一个文件中 13.2 页面盒子：@page 规则 页面盒子是一个矩形区域，它包含两块区域： 页面区域：页面区域包括该页面上的盒子。第一页页面区域的边界形成的矩形是文档的初始包含块。 外边距区域：其围绕着页面区域。页面的外边距区域是透明的。 在 CSS2.2 中无法指定页面盒子的大小。 作者可以在 @page 规则中指定页面盒子的外边距。一条 @page 规则包含关键字 @page，后面跟着一个可选的页面选择器，再后面是一个块包含声明和 @ 规则。在 @page 关键字和页面选择器之间，页选择器和块之间允许有可选的注释和空白字符。@page 规则中的声明处于页面上下文中。 注意：CSS2 没有可以出现在 @page 里的 @ 规则，但这种 @ 规则预期在 CSS3 中定义。 页面选择器指定声明应用于哪些页面。CSS2.2 中，页面选择器可以指定第一页、所有左页或所有右页。 13.2.1 页面外边距 在 CSS2.2 中，只有外边距属性（margin-top，margin-right，margin-bottom，margin-left 和 margin）适用于页面上下文。下图展示了页面，页面盒子和页面外边距之间的关系： 有个给所有页面设置页面外边距的简单例子： @page { margin: 3cm; } 页面上下文没有字体的概念，所以不允许使用 em 和 ex 单位。外边距属性的百分比值是相对于页面盒子的尺寸的。对于左右外边距，参照页面盒子的宽度，而对于上下外边距，就参照页面盒子的高度。各个 CSS2.2 属性相关的所有其它单位都是合法的。 由于（可能存在）负外边距值（在页面盒子上或者元素上）或者 绝对定位 内容 可能跑到页面盒子外，但这部分内容会被 \"切掉\" —被用户代理、打印机或者切纸机。 13.2.2 页面选择器：选择左页，右页或第一页 当打印双面文档时，位于左面和右面的页面盒子可能有差异。这可以通过两个用于页面选择器的CSS 伪类来表达。 所有页面都会被用户代理自动分类为 :left 或者 :right 伪类。文档的第一页是 :left 还是 :right 取决于根元素的主书写方向。比如，一份主书写方向为从左向右的文档的第一页将是 :right 页，而一份主书写方向为从右向左的文档的第一页将是 :left 页。为了显式地强制让一份文档从左面页还是右面页开始打印，左者可以在第一个生成盒子之前插入一个分页符 @page :left { margin-left: 4cm; margin-right: 3cm; } @page :right { margin-left: 3cm; margin-right: 4cm; } 如果已经给左页和右页指定了不同的声明，用户代理必须遵守这些声明，即使用户代理不把这些页面盒子转换到左页和右页上（比如，一个只支持单面打印的打印机）。 作者也可以用 :first 伪类给一份文档的第一页指定样式： @page { margin: 2cm } /* All margins set to 2cm */ @page :first { margin-top: 10cm /* Top margin on first page 10cm */ } （上面的）在 :left @page 或者 :right @page 规则中指定的属性重写了那些不带伪类的@page 规则中指定的属性。在 :first @page 规则中指定的属性重写了那些 :left @page 或者 :right @page 规则中指定的属性。 如果一个强制结束符出现在第一个生成盒子之前，:first 是否适用于该结束符之前的空白页还是该页之后的页，这在 CSS2.2 中是未定义的。 左页，右页和第一页上的 margin 声明可能会导致不同的页区宽度。为了简化实现，用户代理可以对左页、右页和第一页应用单页区宽度，此时，应该应用第一页的页区宽度。 13.2.3 页面盒子外的内容 在格式化页面模型里的内容时，有些内容可能会跑到当前页面盒子外。比如，一个 white-space 属性值为 的元素可能会生成一个比页面盒子宽的盒子。再比如，当盒子为绝对定位或者相对定位时，它们可能会跑到 \"不便\"（访问）的位置。比如，图片可能被放在页面盒子的边界或者页面盒子下方100,000米的位置。 对这种元素的精确格式化超出了本规范的范围。然而，我们推荐做者和用户代理遵守下列关于页面盒子外内容的一般性原则： 为了让页面 \"出血（bleed 译注：印刷术语，见Bleed (printing)）\" ，允许内容稍微超出页面盒子 用户代理应该避免为了遵守元素的定位而生成大量的空页盒子（比如，你不想打印100个空白页） 作者不应该为了不渲染元素而把它们定位到不便（访问）的位置 用户代理可以用多种方式处理定位在页面盒子外的盒子，包括丢弃它们或者为其在文档末尾创建页面盒子 13.3 分页符 本节描述了 CSS2.2 中的分页符。五个属性指定了用户代理可以或者应该在哪里分页，以及后续内容应该在哪个页面（左页还是右页）继续。每次分页都会结束当前页面盒子里的布局，还会让文档树的其余部分被放置在新的页面盒子里。 13.3.1 分页符属性：page-break-before，page-break-after，page-break-after 关键信息摘要： 属性名称：page-break-before 值：auto | always | avoid | left | right | inherit 初始值：auto 适用元素：block-level elements (but see text) 继承：no 百分比：N/A 适用媒体：visual, paged 计算值：as specified 关键信息摘要： 属性名称：page-break-after 值：auto | always | avoid | left | right | inherit 初始值：auto 适用元素：block-level elements (but see text) 继承：no 百分比：N/A 适用媒体：visual, paged 计算值：as specified 关键信息摘要： 属性名称：page-break-inside 值：avoid | auto | inherit 初始值：auto 适用元素：block-level elements (but see text) 继承：no 百分比：N/A 适用媒体：visual, paged 计算值：as specified 这些属性值的含义如下： auto：既不强制也不禁止生成盒子之前（之后，内部）的分页符 always：总是强制生成盒子之前（之后）有一个分页符 avoid：避免生成盒子之前（之后，内部）的分页符 left：强制生成盒子之前（之后）有一个或者两个分页符，以便下一页被格式化为左页 right：强制生成盒之前（之后）有一个或者两个分页符，以便下一页被格式化为右页 （与CSS规范）一致的用户代理可以把 left 和 right 值解释成 always。 典型的，一个潜在的分页符位置受父元素的 page-break-inside 属性，前面元素的 page-break-after 属性以及后面元素的 page-break-before 属性的影响。当这些属性值不为 auto 时，always、left 和 right 值优先于 avoid。 用户代理必须把这些属性应用给根元素的常规流中的块级元素。用户代理还可能会把这些属性应用到其它元素上，比如，table-row 元素。 当一个分页符分割了一个盒子时，该盒子的外边距、边框和填充在分割出现的地方没有视觉效果。 13.3.2 元素内的分页符：orphans，widows 关键信息摘要： 属性名称：orphans 值： | inherit 初始值：2 适用元素：block container elements 继承：yes 百分比：N/A 适用媒体：visual, paged 计算值：as specified 关键信息摘要： 属性名称：widows 值： | inherit 初始值：2 适用元素：block container elements 继承：yes 百分比：N/A 适用媒体：visual, paged 计算值：as specified orphans 属性指定了必须要在 页面底部 的块容器里保留的最小行数。 widows 属性指定了必须要在 页面顶部 的块容器里保留的最小行数。下面给出如何用它们来控制分页符的示例。 只允许正值。 关于段落格式化的信息，请查看行盒子章节。 13.3.3 合法分页符 在普通流中，分页符可能出现在以下位置： 在块级盒子之间的垂直外边距。当此处发生 非强制分页 时，相关的 margin-top 和 margin-bottom 属性的使用值为 0。当此处发生 强制分页 时，相关的 margin-bottom 的使用值为 0，margin-top 的使用值为 0 或保留。 在块容器盒子里的行内盒子之间。 在块容器盒子里的内容边界与其子内容的边界之间（块级子（盒子）的外边距边界或内联级子（盒子）的行内盒子边界），如果它们之间存在（非零）间隙。 注意：预期 CSS3 将会指定（怎样）在一个强制分页符后面应用相关的 margin-top（即，不再置为 0） 这些分页符受以下规则的限制： 规则 A：只有生成在此外边距满足的盒子的所有元素的 page-break-after 和 page-break-before 属性允许时，分页符才可以在(1)处（译注：见上面的 123）分页，也就是当其中至少一个值为 always、left 或 right，或者它们都是 auto。 规则 B：但是，如果它们全部都是 auto 并且它们的一个公共祖先具有值为 avoid 的 page-break-inside，那么不允许在此处分页。 规则 C：只有结束符与其所在的块盒子开始处之间的行盒子的数量大于等于 orphans 的值，并且结束符与该盒子结束处之间的行盒子的数量大于等于 widows 的值时，才可以在(2)处分页。 规则 D：另外，只有当该元素及其所有祖先的 page-break-inside 属性都是 auto 时，才可以在(2)或(3)处分页。 如果上面的规则无法提供足够的分页位置来阻止内容从页面盒子溢出，那么就删掉规则A、B和D，以寻找额外的分页位置。 如果分页位置还不够，就把规则 C 也删掉，以寻找更多的分页位置。 13.3.4 强制分页符 如果该处所有元素生成盒子的 page-break-after 和 page-break-before 属性中，至少有一个值为 always、left 或 right 的话，必须都在(1)处放置分页符（不论其它元素值是什么，即便是 avoid） 13.3.5 \"最佳\"分页符 CSS2.2 没有定义必须使用哪一组合法的分页符，CSS2.2 没有禁止用户代理在任何可能的分页点分页，或者完全不分页。但CSS2.2 推荐用户代理遵守下列启发式方法（虽然承认它们有时很矛盾）： 尽量少分页 让所有不以强制分页结束的页面看起来高度大致相等 避免在替换元素内部分页 比如，假设样式表含有 orphans: 4、widows: 2，并且当前页面的底部有 20 行（行盒子）可用： 如果当前页面结束处有一个小于等于 20 行的段落，它应该放在当前页面 如果该段落包含 21 或者 22 行，该段落的第二部分不能违反 widows 约束，所以第二部分必须刚好只有两行 如果该段落大于等于23行，第一部分应该包含20行，而第二部分包含其余行 现在假设 orphans 为 \"10\"、widows 为 \"20\"，并且当前页面底部有8行可用： 如果当前页面结束处有一个小于等于 8 行的段落，它应该放在当前页面 如果该段落大于等于 9 行，它无法分割（将会违反 orphan 约束），所以它应该被当作一个块移动到下一页 13.4 页面上下文的层叠 页面上下文中的声明遵循层叠，就像常规CSS声明一样 考虑下例： @page { margin-left: 3cm; } @page :left { margin-left: 4cm; } 由于伪类选择器更高的特殊性，左页的左外边距将是 '4cm'，而所有其它页面（即，右页）将具有 '3cm' 的左外边距 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-07-01 14:54:46 "},"docs/CSS/CSS2.2/14 颜色和背景.html":{"url":"docs/CSS/CSS2.2/14 颜色和背景.html","title":"14 颜色和背景","keywords":"","body":"14 颜色和背景（Colors and Backgrounds） CSS 属性允许作者指定元素的 前景色(foreground color) 和 背景（background）。背景可能是颜色或图像。背景允许作者定义背景图像，平铺它，并声明它是应该相对于 视口 固定还是随文档滚动。 合法颜色值的语法，请参考 颜色单位 相关的部分。 14.1 前景色：color 属性（Foreground color: the 'color' property） 关键信息摘要： 属性名称：color 值： | inherit 初始值：depends on user agent 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性描述了元素文本内容的前景色。指定红色的多种方法： em { color: red } /* predefined color name */ em { color: rgb(255,0,0) } /* RGB range 0-255 */ 14.2 背景（The background） 作者可以把一个元素的背景（即其渲染表面）指定为颜色或图像。对于盒子类型来说，\"背景\" 是指 内容（content）、内边距（padding）、边界区域（border areas）的背景。边界颜色（color）和样式（style）由 border 属性设置。外边距始终是透明的。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-09-22 11:59:18 "},"docs/CSS/CSS2.2/15 字体.html":{"url":"docs/CSS/CSS2.2/15 字体.html","title":"15 字体","keywords":"","body":"15 字体 15.1 简介 设置字体属性是样式表最常见用途。不幸的是，对于字体归类，没有明确的定义和普遍接受的分类方法，而且适用于一个字体族的术语可能不适用于其它（字体族）。比如，italic 通常用来标记倾斜的字体，但倾斜字体也可能被标记为 Oblique、Slanted、Incline、Cursive 或Kursiv。因此，把典型的字体选择属性映射到特定字体不是个简单的问题。 15.2 字体匹配算法 由于字体属性不存在可接受的通用分类法，因此必须将属性与字体匹配时必须谨慎。这些属性以确定的顺序进行匹配，以确保匹配处理的结果尽可能与 UA 一致（假定给它们提供了相同的字体库）： 用户代理创建（或访问）一个 UA 知道的所有字体的相关 CSS2.2 属性的数据库。如果有两种字体具有完全相同的属性，则用户代理会选择其中一种。 对于给定元素和该元素中的每个字符，UA 会适用于该元素的字体属性。使用完整的属性集，UA根据 font-family 属性来选择一种暂定的字体族。根据每个属性的匹配标准对其余属性进行尝试。如果所有剩余属性都匹配，那么这就是给定元素或字符的匹配字体。 如果经过第 2 步处理后，该 font-family 里没有匹配的字体，如果字体集里存在下一个可选的 font-family，那么就对下一个可选 font-family，重复步骤 2。 如果存在一种匹配字体，但它不包含当前字符的字形，并且如果字体集里存在下一个可选的 font-family，那么就对下一个可选的 font-family，重复步骤 2。 如果第 2 步中没有选出字体，那么就用依赖于 UA 的默认 font-family 并重复第 2 步，使用默认字体中的最佳匹配。如果一个特殊字符无法用这种字体显示，那么 UA 可以用其它方式来为该字符确定一个合适的的字体。UA 应该把其中每个没有合适字体的字符映射到由 UA 选择的可见符号，最好是可供 UA 使用的字体中的一个 \"缺失字符\"）字形。 （可以优化上述算法，以避免重新访问每个字符的 CSS2.2 属性） 上面第 2 步中各个属性的匹配规则如下： 首先尝试 font-style。 如果 UA 的字体数据库中有一个标有 CSS 关键字 italic（首选）或 oblique 的面，则会显示 '斜体'。否则，值必须完全匹配或 font-style 将失败。 接下来尝试 font-variant。\"small-caps\" 会匹配被标记为 \"small-caps\" 的字体，合成小型大写字母的字体，或所有小写字母由大写字母替换的字体。\"normal\" 匹配字体的常规（非小型大写字母）状态。字体不能没有常规字体。仅可作为小型大写字母的字体应该既可以作为 \"normal\" 字体，也可以作为 \"small-caps\" 来选择。 接下来匹配 font-weight。不可能（匹配）失败（见下面的 font-weight）。 font-size 必须在一个依赖于 UA 相关的容差范围内匹配(通常，可缩放字体大小可四舍五入到最接近的整数像素，而位图的字体容差可能高达 20%)。进一步计算，（比如，其它属性的 em 值）取决于 font-size 的计算值。 15.3 字体族：font-family 属性 关键信息摘要： 属性名称：font-family 值：[[ | ] [, [ | ] ]* ] | inherit 初始值：depends on user agent 适用元素：all elements 继承：no 百分比：N/A 适用媒体：visual 计算值：as specified 属性值是字体族名称和/或通用族名称的优先级列表。与大多数其他 CSS 属性不同，分量值由逗号分隔以表示它们是替代方案： body { font-family: Gill, Helvetica, sans-serif } 虽然很多字体提供了 \"缺失字符\" 的字形（通常是一个打开的盒子），因为它的名字暗示这不应该被认为是在字体中无法找到的字符的匹配。（然而，应该被认为是 U+FFFD，\"缺失字符\" 字符码位值的匹配）。 有两种类型的字体族名： ：一个字体族的名字。上一个示例中，Gill 和 Helvetica 都是字体族。 ：上例中，最后一个值是个通用字体族名。定义了下列通用字体族名 serif（比如，Times） sans-serif（比如，Helvetica） cursive（比如，Zapf-Chancery） fantasy（比如，Western） monospace（比如，Courier） 鼓励样式表设计者提供一个通用字体族作为最后一个备选项。通用字体族名是关键字，不要用引号包起来。 字体族名要么必须用引号包起来作为字符串，要么不用引号包起来作为一系列一个或多个标识符。这意味着每个 token 开头的大多数标点符号和数字必须在未用引号包裹的字体系列名称中转义，比如，下列声明是非法的： /* error */ font-family: Red/Black, sans-serif; font-family: \"Lucida\" Grande, sans-serif; font-family: Ahem!, sans-serif; font-family: test@foo, sans-serif; font-family: #POUND, sans-serif; font-family: Hawaii 5-0, sans-serif; 如果给定了一系列标识符作为字体族名，计算值为把该名字转换为通过用空格拼接所有标识符形成的字符串序列。 为了避免转义期间的错误，建议用引号把含有除连字符外的空白字符、数字或者标点符号字符的字体族名包起来： body { font-family: \"New Century Schoolbook\", serif } 刚好与关键字值相同的字体族名（inherit、serif、sans-serif、monospace、fantasy、cursive）必须用引号包起来，防止与同名的关键字混淆。关键字 initial 和 default 为将来的用法保留，用作字体名时也必须用引号包起来。UA 不能把这些关键字当作 类型匹配。 15.3.1 通用字体族 通用字体族是一种回退机制，在最坏的情况下，指定的所有字体都不可用时，（这是）能通过这种方式保留样式表作者的一些意图。为了最佳的排版控制，应该在样式表中使用特定命名的字体。 5 个通用字体族的定义全都存在于所有 CSS 实现中（它们不一定要映射到 5 个不同的实际字体）。用户代理应该为通用字体族提供合理的默认选项，表达每个族的特征和可能存在的底层技术的限制 鼓励用户代理允许用户为通用字体族选择可选的替代项。 15.3.1.1 serif 衬线字体的字形，作为 CSS 中使用的术语，通常会有精加工笔锋，喇叭形或锥形末端，或具有实际衬线的末端（包括粗衬线字体）。衬线字体通常按比例间隔。与 sans-serif 通用字体系列中字体相比，它们通常在粗和细笔锋之间显示出更大的变化。CSS 术语 serif 适用于任何脚本的字体，即使其它名称对于特定脚本更加熟悉，比如 Mincho（日语）、Sung 或 Song（中文）、Totum 或 Kodig（韩语）。如此描述的字体都可用于表示通用的 serif 系列。 符合该描述的字体示例包括： 拉丁字体（Latin fonts）：Times New Roman, Bodoni, Garamond, Minion Web, ITC Stone Serif, MS Georgia, Bitstream Cyberbit 希腊字体（Greek fonts）：Bitstream Cyberbit 西里尔字体（Cyrillic fonts）：Adobe Minion Cyrillic, Excelsior Cyrillic Upright, Monotype Albion 70, Bitstream Cyberbit, ER Bukinist 希伯来字体（Hebrew fonts）：New Peninim, Raanana, Bitstream Cyberbit 日文字体（Japanese fonts）：Ryumin Light-KL, Kyokasho ICA, Futo Min A101 阿拉伯字体（Arabic fonts）：Bitstream Cyberbit 彻罗基字体（Cherokee fonts）：Lo Cicero Cherokee 15.3.1.2 sans-serif 无衬线字体的字形，作为 CSS 中使用的术语，通常会有明显的笔锋结尾-有一点或没有向外展开的、交叉笔锋或其它装饰。无衬线字体通常按比例间隔。与 serif 族的字体相比，它们通常在粗细笔锋间通常几乎没区别。CSS 术语 sans-serif 适用于任何脚本的字体，即使其它名称对于特定脚本更加熟悉，比如 Mincho（日语）、Sung 或 Song（中文）、Totum 或 Kodig（韩语）。如此描述的字体都可用于表示通用的 sans-serif 系列。 符合该描述的字体示例包括： 拉丁字体（Latin fonts）：MS Trebuchet, ITC Avant Garde Gothic, MS Arial, MS Verdana, Univers, Futura, ITC Stone Sans, Gill Sans, Akzidenz Grotesk, Helvetica 希腊字体（Greek fonts）：Attika, Typiko New Era, MS Tahoma, Monotype Gill Sans 571, Helvetica Greek 西里尔字体（Cyrillic fonts）：Helvetica Cyrillic, ER Univers, Lucida Sans Unicode, Bastion 希伯来字体（Hebrew fonts）：Arial Hebrew, MS Tahoma 日文字体（Japanese fonts）：Shin Go, Heisei Kaku Gothic W5 阿拉伯字体（Arabic fonts）：MS Tahoma 15.3.1.3 cursive 草书字体的字形，作为 CSS 中使用的术语，通常会有连笔或除斜体字体外的草书特征。字形部分或完全连接在一起，结果看起来更像是手写笔或笔刷而不是印刷字母。对于某些文字而言，如阿拉伯文字，字体差不多都是草书形式。CSS 术语 cursive 适用于任何文字，尽管其它名字，比如 Chancery、Brush、Swing 和 Script 也用于字体名。 符合该描述的字体示例包括： 拉丁字体（Latin fonts）：Caflisch Script, Adobe Poetica, Sanvito, Ex Ponto, Snell Roundhand, Zapf-Chancery 西里尔字体（Cyrillic fonts）：ER Architekt 希伯来字体（Hebrew fonts）：Corsiva 阿拉伯字体（Arabic fonts）：DecoType Naskh, Monotype Urdu 507 15.3.1.4 fantasy 梦幻字体，作为 CSS 中使用的术语，主要用于装饰性的，同时依然有字符表现。 符合该描述的字体示例包括： 拉丁字体（Latin fonts）：Alpha Geometrique, Critter, Cottonwood, FB Reactor, Studz 15.3.1.5 monospace 等宽字体的唯一标准就是所有字形拥有相同的固定宽度。（这可能使得一些文字，如阿拉伯文字，看起来比较奇怪），效果与手动打字机类似，通常用来设置计算机代码的样例。 符合该描述的字体示例包括： 拉丁字体（Latin fonts）：Courier, MS Courier New, Prestige, Everson Mono 希腊字体（Greek fonts）：MS Courier New, Everson Mono 西里尔字体（Cyrillic fonts）：ER Kurier, Everson Mono 日文字体（Japanese fonts）：Osaka Monospaced 彻罗基字体（Cherokee fonts）：Everson Mono 15.4 字体样式：font-style 属性 关键信息摘要： 属性名称：font-style 值：normal | italic | oblique | inherit 初始值：normal 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified font-style 属性可以选择一个字体族中的常规（normal）、斜体（italic）、倾斜（oblique）的字体。 normal 值会在 UA 的字体数据库中选择一个被分类为 normal 的字体，而 oblique 会选择一个被标记为 oblique 的字体。italic值会选择一个被标记为 italic 的字体，或者如果 italic 不可用，就选择被标记为 oblique 的字体。 UA 的字体数据库中被标记为 oblique 的字体实际上可能已经通过电子的方式倾斜常规字体生成了。 通常，名字中含有 Oblique、Slanted 或者 Incline 的字体在 UA 的字体数据库中会被标记为 oblique。名字中含有 Italic、Cursive 或者 Kursiv 的字体会被标记为 italic。 h1, h2, h3 { font-style: italic } h1 em { font-style: normal } 上例中， 中被强调的文本将以常规字体呈现。 15.5 小型大写字母：font-variant 属性 关键信息摘要： 属性名称：font-variant 值：normal | small-caps | inherit 初始值：normal 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 字体族中的另一种变体就是小型大写字母。在小型大写字母字体中，小写字母看起来和大写字母很相似，但尺寸更小且比例略有差异。可以用 font-variant 属性选择这种字体。 normal 值会选择一个非小型大写字母字体，small-caps 会选择一个小型大写字母字体。如果小型大写字母字体是通过把常规字体中的小写字母替换为缩放的大写字符创建的，在 CSS2.2 中也可以接受（但不是必须的）。万不得已时，大写字母将被用作小型大写字母字体的替代品。 下例会让 元素为小型大写字母，所有被强调的单词都是倾斜， 中所有被强调的单词为倾斜小型大写字母： h3 { font-variant: small-caps } em { font-style: oblique } 字体族中还可能存在其它变体，比如，老式数字（old-style numerals）、小型大写数字（small-caps numerals）、缩紧或者扩宽的字体等等。CSS2.2 没有可以选择这些字体的属性。 注意：只要此属性导致文本转换为大写，则会应用与 text-transform 相同的注意事项。 15.6 字体粗细：font-weight 属性 关键信息摘要： 属性名称：font-weight 值：normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit 初始值：normal 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：see text font-weight 属性用来选择字体粗细程度。值为 100 到 900 的有序序列，每个数字表示一个粗细程度，至少和它的前一个一样粗。关键字 normal 等同于 400，bold 等同于 700。除 normal 和 bold 外的关键字经常与字体名混淆，因此一般在列出的 9 个数字分级中选择。 p { font-weight: normal } /* 400 */ h1 { font-weight: 700 } /* bold */ bolder 和 lighter 值选择的字体粗细程度是相对于从父级继承到的粗细程度： strong { font-weight: bolder } 字体（字体数据）通常具有一个或多个属性，其值是描述字体 \"粗细\" 的名称。这些粗细程度名称没有公认的通用含义。它们的主要作用是区分单一字体族中不同的粗细程度。用法在各个字体族之间差异很大。比如，一个 bold 字体可能被描述为 Regular、Roman、Book、Medium、Semi- 或者 DemiBold、Bold 或者 Black，取决于设计中 normal 字体有多粗。因为没有标准的名称用法，粗细的属性值在 CSS2.2 中是以数字分级给出的，值 400（或者 normal）对应该字体族的 normal 文本字体。通常，与该字体相关的粗细名称为Book、Regular、Roman、Normal 或者 Medium。 字体族中其它粗细与数字粗细值的关联只是想要保留字体族中粗细程度的顺序。然而，如下启发式方法描述了这种情况下如何完成分配： 如果字体族已经用了 9 值数字分级（比如，OpenType就是这样），应该直接映射到字重 如果存在一个被标记为 Medium 的和一个被标记为 Book、Regular、Roman或者 Normal 的字体，那么 Medium 一般被分配为 500 被标记为 Bold 的字体通常对应粗细值 700 一旦字体族的粗细被映射到 CSS 分级上，缺少的粗细就按照如下规则选择： 如果需要的粗细小于 400，小于目标粗细的粗细按降序检查，然后大于目标粗细的粗细按升序检查，直到找到匹配的 如果需要的粗细大于 500，大于目标粗细的粗细按升序检查，然后小于目标粗细的粗细按降序检查，直到找到匹配的 如果需要的粗细为 400，先检查 500，然后应用需要的粗细小于 400 的规则 如果需要的粗细为 500，先检查 400，然后应用需要的粗细小于 400 的规则 下面的两个例子展示了典型的映射 假设 \"Rattlesnake\" 字体族中的 4 种weight，从最细到最粗为：Regular、Medium、Bold、Heavy： 假设 \"Ice Prawn\" 字体族中的 6 种weight：Book、Medium、Bold、Heavy、Black、ExtraBlack。注意，这种情况下，用户代理已经决定了不给 \"Ice Prawn ExtraBlack\" 分配数字分级： 值为 bolder 和 lighter 表示相对于父元素的粗细。基于继承到的粗细值，粗细的应用值按照下表来计算。子元素继承粗细的计算值，而不是 bolder 或者 lighter。 上表相当于给出一个含有 normal 和 bold 字体以及 thin 和 heavy 字体的字体族，从中选择下一个相对更粗或者更细的字体。想要更好地控制给定元素的精确粗细值的作者应该使用数字分级而不是相对粗细程度。 无法保证每个 font-weight 值都存在一个更粗的字体。比如，有些字体可能只有 normal 和 bold 字体，而其它的可能具有 8 种字重。无法保证 UA 会怎样把字体族中的字体映射到粗细值。唯一能保证的是给定值的字体不会比 lighter 值对应的字体更细。 15.7 字体大小：font-size 属性 关键信息摘要： 属性名称：font-size 值： | | | | inherit 初始值：medium 适用元素：all elements 继承：yes 百分比：refer to inherited font size 适用媒体：visual 计算值：absolute length 字体大小对应于 em square，这是排版中使用的概念。注意，某些字形可能会溢出其正方形之外。值具有以下含义： ： 一个 关键字是字体大小表的索引，该表由 UA 计算和维护。值可能为：[ xx-small | x-small | small | medium | large | x-large | xx-large ] 下表提供了 用于 HTML 标题和绝对字体大小的绝对大小映射的 用户代理指南。medium 值是用户代理的首选字体大小，并被用作参考中间值 实现者应该为 medium 字体大小相关的 absolute-size 关键字和特殊设备及其特征（比如，设备分辨率）建立一个比例因子表。 不同媒体可能需要不同的比例因子。计算该表时，UA 还应该考虑字体的质量和可用性。不同字体族对应的表可能不一样。 注意： 为了保持可读性，应用这些指南的 UA 应该避免在计算机显示器上创建 小于 9 像素每 EM 单元 的 font-size。 在 CSS1 中，建议相邻索引间的比例因子为 1.5，此时用户体验最佳。CSS2 中，建议的计算机屏幕上相邻索引间的比例因子为 1.2，对于小尺寸仍然会出问题。实现经验表明 相邻 absolute-size 关键字间固定的比例是有问题的，本规范不推荐这种固定比例。 ： 关键字根据字体大小表和父元素的字体大小来解释。可能的值为：[ larger | smaller ]。比如，如果父元素的字体大小为 medium，值为 larger 会让当前元素的字体大小变成 large。如果父元素的大小不贴近表格项，UA 可以自由地在表格项中插值或者舍入为最近的表格项。如果数字值超出了关键字的话，UA 可能必须推算表格值 当计算元素的字体大小时，长度和百分比值不应考虑字体大小表。 不允许使用负值。 在所有的其它属性上，em 和 ex 长度值指的是当前元素的字体大小的计算值。在 font-size 属性中，这些长度单位指的是父元素的字体大小的计算值。 注意：应用程序可能会重新解释明确的大小，具体取决于上下文。比如，在 VR 场景内，由于透视失真，字体中可能得到不同的大小。 示例： p { font-size: 16px; } @media print { p { font-size: 12pt; } } blockquote { font-size: larger } em { font-size: 150% } em { font-size: 1.5em } 15.8 简写字体属性：font 属性 关键信息摘要： 属性名称：font 值：[ [ || || ]? [ / ]? ] | caption | icon | menu | message-box | small-caption | status-bar | inherit 初始值：see individual properties 适用元素：all elements 继承：yes 百分比：see individual properties 适用媒体：visual 计算值：see individual properties 除了如下所述之外，font 属性是用于设置 font-style、font-variant、font-weight、font-size、line-height、font-family 的简写属性。该属性的语法基于传统印刷简写表示法来设置与字体相关的多个属性。 所有与字体相关的属性首先重置为其初始值，包括上文中列出的那些。然后，将那些在 font 简写中给定明确值的属性设置为给定的值。关于合法值和初始值的定义，请参阅先前定义的属性。 p { font: 12px/14px sans-serif } p { font: 80% sans-serif } p { font: x-large/110% \"New Century Schoolbook\", serif } p { font: bold italic large Palatino, serif } p { font: normal small-caps 120%/120% fantasy } （上述）第二条（CSS）规则中，字体大小的百分比值（\"80%\"）是指父元素的字体大小。（上述）第三条（CSS）规则中，行高百分比是指元素本身的字体大小。 在上面的前三个规则中，没有明确提到 font-style、font-variant 和 font-weight，这意味着它们都被设置为初始值（\"normal\"）。第四条规则将 font-weight 设置为 bold、font-style 设置为 italic，并隐式将 font-variant 设置为 normal。 第五条规则设置 font-variant（\"small-caps\"）和 font-size（父级字体的 120%），line-height（当前字体大小的 120%）和 font-family（\"fantasy\"）。因此，关键字 normal 应用于其余两个属性：font-style 和 font-weight。 下列值引用系统字体： caption：用于标题控件的字体（比如，按钮、下拉框等等） icon：用于标记图标的字体 menu：用于菜单的字体（比如，下拉菜单和菜单列表） message-box：用于对话框的字体 small-caption：用于标记小控件的字体 status-bar：用于窗口状态栏的字体 系统字体只能作为整体来设置，也就是说，会同时设置字体族、大小、粗细程度、样式等等。如果需要的话，之后可以单独改变这些值。如果给定平台上不存在具有指定的特征的字体，用户代理应该智能地替换（比如，caption 字体更小的版本可以用作 small-caption 字体），或者替换为用户代理默认字体。至于常规字体，相对对于一个系统字体，如果任何单个属性都不是操作系统的可用用户首选的一部分，则将这些属性设置为初始值。 这就是为什么这个属性 \"几乎\" 是一个简写属性：系统字体只能用这个属性指定，而不能用 font-famiy 本身来指定，所以 font 允许作者做的不仅仅是它的子属性的总和。但是，font-weight 等各个属性仍然是从系统字体中获取的值，可以单独更改。 button { font: 300 italic 1.3em/1.7em \"FB Armada\", sans-serif } button p { font: menu } button p em { font-weight: bolder } 如果一个特殊系统中用于下拉菜单字体恰好是，比如，9-point Charcoal，weight为600，那么作为 后代的 元素将被显示成这条规则的效果： button p { font: 600 9px Charcoal } 因为 font 简写属性会把所有没有显式给定值的属性重置为其初始值，与这个声明的效果一样： button p { font-family: Charcoal; font-style: normal; font-variant: normal; font-weight: 600; font-size: 9px; line-height: normal; } Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-07-22 20:42:47 "},"docs/CSS/CSS2.2/16 文本.html":{"url":"docs/CSS/CSS2.2/16 文本.html","title":"16 文本","keywords":"","body":"16 文本 定义在下列小节的属性会影响字符、空格、单词和段落的视觉呈现。 16.1 缩进：text-indent 属性 关键信息摘要： 属性名称：text-indent 值： | | inherit 初始值：0 适用元素：block containers 继承：yes 百分比：相对于包含块的宽度 适用媒体：visual 计算值：the percentage as specified or the absolute length 该属性指定了块容器中第一行文本的缩进。确切的说，它指定了排列 在该块内第一个行盒子里 的 第一个盒子 的缩进。该盒子相对行盒子的左边（或右边，对于从右向左布局）缩进。用户代理必须将此缩进呈现为空格。 text-indent 只影响元素的第一个格式化行。比如，匿名块盒子的第一行会受到影响。如果它是父元素（指匿名块盒子）的第一个孩子的话。 值含义如下： ：缩进是一个固定长度 ：缩进是包含块宽度的百分比 text-indent 的值可能是负数，但可能存在于特定的实现限制。如果 text-indent 的值为负或超过了该块的宽度，则上述第一个盒子可以从块中溢出。overflow 的值将影响这种从块溢出的文本是否可见。 下例会产生 3em 的文本缩进 p { text-indent: 3em } 注意：因为 text-intent 属性会继承，给一个块元素指定时，它将影响后代 inline-block 元素。因此，一般最好给被指定了 display: inline-block 的元素指定 text-indent: 0 16.2 对齐：text-align 属性 关键信息摘要： 属性名称：text-align 值：left | right | center | justify | inherit 初始值：a nameless value that acts as 'left' if 'direction' is 'ltr', 'right' if 'direction' is 'rtl' 适用元素：block containers 继承：yes 百分比：N/A 适用媒体：visual 计算值：the initial value or as specified 该属性描述了块容器的行内级内容怎样对齐。值含义如下： left, right, center, justify：分别为左对齐、右对齐、居中和两端对齐文本，如行内格式化章节 所述 文本块是行盒子的堆叠。对于 left、right、center，该属性指定了每个行盒子里的行内级盒子相对于行盒子的左边和右边怎样对齐，对齐不是相对于视口的。对于 justify，该属性指定了，如果可能的话通过扩宽或缩紧行盒子的内容，让行内级盒子与行盒子的两边对齐，否则就按照初始值对齐（另见 letter-spacing 和 word-spacing）。 如果元素的 white-space 的计算值为 pre 或 pre-wrap，那么该元素文本内容的字形及其空格都不会因为两端对齐而发生变化。 注意：CSS 将来可能会新增一种让 white-space: pre-wrap 文本两端对齐的方法。 本例中，注意因为 text-align 是可继承的，带有类名 important 的 元素中的所有块级元素会让它们的行内内容居中 div.important { text-align: center } 注意：应用的实际两端对齐算法取决于用户代理和文本的语言/脚本（script）。 （与CSS规范）一致的用户代理可能会把 justify 值解释为 left 或者 right，分别取决于该元素的默认书写方向是从左向右还是从右向左 16.3 装饰 16.3.1 下划线、上划线, 突出, 和闪烁: text-decoration 属性 关键信息摘要： 属性名称：text-decoration 值：none | [ underline || overline || line-through || blink ] | inherit 初始值：none 适用元素：all elements 继承：no (see prose) 百分比：N/A 适用媒体：visual 计算值：as specified 该属性描述使用元素颜色添加到元素文本（以此来修饰元素）。当指定或传播给一个行内元素时，它会影响该元素生成的所有盒子，还会进一步传播给 分割该行内元素的 所有流内块级元素（见：9.2.1.1 小节）。但在 CSS2.2 中，装饰是否会传入块级表格是未定义的。对于建立了行内格式化上下文的块容器，装饰将传播到一个匿名行内元素，该元素包住了所有流内行内级子级。对于所有其它元素，会传播给所有流内子级。注意，文本装饰不会传播给浮动和绝对定位的后代，也不会传播给原子行内级后代（如行内块和行内表）的内容。 下划线、上划线、中划线只适用于文本（包括空白字符，字母间隔和单词间隔）：外边距、边框和填充会被跳过。用户代理不能在非文本内容上呈现这些文本装饰。比如，不能对图像和行内块加上下划线。 注意：如果一个元素 E 既有 visibility: hidden 也有 text-decoration: underline，那么下划线将不可见（即使 E 的父级的装饰都是可见的）。然后，CSS2.2 没有指定 E 的子级的 下划线是否可见或不可见： underlined or not? 这种情况将在 CSS3 中指定（如何处理） 后代元素的 text-decoration 属性不会影响祖先的装饰。在确定文本装饰线的位置和粗细程度时，用户代理可以考虑后代的主基线（原：dominant baseline）和字体大小，但每行必须应用相同的基线和粗细程度。相对定位一个后代元素会移动影响该后代元素文本的所有文本装饰，不会影响装饰初始位置的计算。 值含义如下： none：不会产生文本装饰 underline：每行文本都有下划线 overline：每行文本上方都有一条线 line-through：每行文本都有一条线从中间穿过 blink：文本闪烁（在可见和不可见交替）。（与CSS规范）一致的用户代理可以简单的不闪烁文本。注意：不闪烁文本是一项满足 WAI-UAAG的checkpoint 3.3（译注：WAI-UAAG 是指 Web 可访问性倡议-用户代理可用性指南）的技术 文本修饰需要的颜色必须来自 text-decoration 所在的元素的 color 属性值。修饰的颜色必须保持相同，即使后代元素具有不同的 color 值。 某些用户代理已经通过把装饰传播给后代元素实现了 text-decoration，而没有保留上面描述的不变的粗细程度和行位置。这在 CSS2 宽松措辞 中可以说是允许的。SVG1、CSS1-only、CSS2-only 的用户代理可以实现旧模式，并仍然声称与 CSS2.2 这部分一致（这不适用于在本规范发布后开发的 UA） 如下 HTML 的示例中，所有 元素的文本内容会像超链接（无论访问过与否）一样被加上下划线： a:visited, a:link { text-decoration: underline } 下列样式表和文档片段中： blockquote { text-decoration: underline; color: blue; } em { display: block; } cite { color: fuchsia; } Help, help! I am under a hat! —GwieF ...blockquote 元素的下划线被传播给一个环绕着 span 元素的匿名行内元素，让文本 \"Help, help!\" 变成蓝色，带有来自它下面的匿名行内元素的蓝色下划线，颜色取自 元素。 块中的 text 也有下划线，因为它位于下划线能传播到的流内块中。最后一行文本是（紫红色），但它下方的下划线仍然是来自匿名行内元素的蓝色下划线。 此图展示了上例中所涉及的盒子。圆角水绿色线代表包裹着段落元素的行内内容的匿名行内元素，圆角蓝色线代表span元素，橘黄色线代表块 16.4 字母与单词间距：letter-spacing 和 word-spacing 属性 关键信息摘要： 属性名称：letter-spacing 值：normal | | inherit 初始值：normal 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：'normal' or absolute length 该属性指定了文本字符间隔的行为。值有以下含义： normal：间隔是当前字体的常规间隔。该值允许用户代理为了让文本两端对齐而改变字符间隔 ：该值表示除字符间的默认间隔外的字符间间隔。值可以为负，但可能存在具体实现限制。用户代理不能为了让文本两端对齐而进一步增加或者减少字符间间隔 字符间隔算法是由用户代理实现。 本例中， 元素中的字符间隔增大了 \"0.1em\" blockquote { letter-spacing: 0.1em } 下例中，不允许用户代理改变字符间间隔： blockquote { letter-spacing: 0cm } /* Same as '0' */ 当两个字符间产生的间隔与默认间隔不同时，用户代理不应该使用连体字母（ligature） 关键信息摘要： 属性名称：word-spacing 值：normal | | inherit 初始值：normal 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：for 'normal' the value '0'; otherwise the absolute length 该属性指定了单词间的间隔行为。值有以下含义： normal：常规单词间间隔，由 当前字体 和/或 UA 定义 ：该值表示除默认单词间隔外的单词间间隔。值可以为负，但可能存在具体实现限制 单词间隔算法是由用户代理实现。单词间隔也受两端对齐的影响（见 text-align 属性）。单词间隔会影响每个空格(U+0020)和非间断空格(U+00A0)，留在空白字符处理规则应用之后的文本中。该属性对其它单词分隔符字符的效果是未定义的。然而，一般标点符号，零预宽字符（例如，零预宽空格U+200B）和固定宽度空格（比如，U+3000和U+2000到U+200A）都不受影响 本例中， 元素中每个单词间的单词间隔增大了 \"1em\" h1 { word-spacing: 1em } 16.5 大写：text-transform 属性 关键信息摘要： 属性名称：text-transform 值：capitalize | uppercase | lowercase | none | inherit 初始值：none 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性控制元素文本的大写效果。值有以下含义： capitalize：让每个单词的第一个字符大写，其它字符不受影响 uppercase：让每个单词的所有字符都大写 lowercase：让每个单词的所有字符都小写 none：没有大写效果 每种情况下的实际转换依赖书写语言。确定一个元素的语言的方法见 BCP47（[BCP47]）（译注：BCP 指最佳当前实践） 只有属于 \"bicameral scripts\" [UNICODE]（译注：bicameral scripts是指具有大小写差异的文字）的字符会受到影响 本例中， 元素中的所有文本都会被转换为大写文本 h1 { text-transform: uppercase } 16.6 空白字符：white-space 属性 关键信息摘要： 属性名称：white-space 值：normal | pre | nowrap | pre-wrap | pre-line | inherit 初始值：normal 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性声明了元素内的空白字符如何处理。值有以下含义： normal：该值引导用户代理把合并空白字符和换行序列作为填充行盒子的必要操作 pre：该值阻止用户代理合并空白字符序列。只在保留换行符处换行 nowrap：该值和 normal 一样会合并空白字符，但会抑制文本中的换行 pre-wrap：该值阻止用户代理合并空白字符序列。在保留换行符处换行，根据需要填充行框 pre-line：该值引导用户代理合并空白字符序列。在保留换行符处换行，根据需要填充行框 源码中的换行可以用回车换行(U+000D)，换行(U+000A)或者它们两个(U+000D U+000A)或者某些其它标识文档片段开始和结束的机制（例如，SGML RECORD-START和RECORD-END token）来表示。CSS white-space 处理模型假设所有换行已经被标准化为换行符了。识别其它换行表示的UA必须应用空白字符处理规则，就像已经标准化过了一样。如果没有为文档语言指定换行规则，文档文本中的每个回车换行(U+000D)和CRLF序列(U+000D U+000A)都会被当作单个换行字符。默认标准化规则也适用于生成的内容。 UA 必须识别换行(U+000A)是换行符。此外，UA 也可以把其它强制中断符当作 UAX14（译注：指 Unicode Standard Annex，Unicode标准附件14）换行符。 下例展示了 HTML 中 和 元素和 nowrap 属性预期的空白字符行为 pre { white-space: pre } p { white-space: normal } td[nowrap] { white-space: nowrap } 此外，具有非标准的 wrap 属性的 HTML 元素的效果如下例所示： pre[wrap] { white-space: pre-wrap } 16.6.1 white-space 处理模型 对于每个行内元素（包括匿名行内元素），执行下列步骤，对于双向格式化字符，就当它们不存在： 如果 white-space 被设置为 normal、nowrap 或 pre-line 的话，换行符(U+000A)周围的每个制表符(U+0009)，回车换行(U+000D)或者空格(U+0020)字符会被移除 如果 white-space 被设置为 pre 或者 pre-wrap 的话，所有没被元素边界隔开的空格(U+0020)序列会被当作一系列非间断空格。然而，对于 pre-wrap，在每个序列的结束处存在换行机会 如果 white-space 被设置为 normal 或者 nowrap，为了渲染的目的，换行符会根据基于内容文字的具体 UA 算法转换为下列字符之一：空格符，零宽空格符(U+200B)或者没有字符（即，不渲染） 如果 white-space 被设置为 normal、nowrap 或者 pre-line 每个制表符(U+0009)会被转换为一个空格(U+0020) 所有跟着另一个空格(U+0020)—甚至一个位于行内（盒）前的空格，如果该空格的 white-space 被设置为 normal、nowrap 或者 pre-line 的话则移除 然后，放置块容器的行内（盒子）。放置行内（盒子）时，要考虑双向重新排序，并按照 white-space 属性指定的方式来换行。换行时，换行位置根据上面的空白字符合并步骤之前的文本来定。 当每行都摆放好后， 如果 white-space 被设置为 normal、nowrap 或者 pre-line 的行开始处有一个空格(U+0020)，它会被移除 所有制表符(U+0009)会被渲染为一个水平位移，到该行下一个制表位的下一个字形的开始边。制表位出现在从该块的开始内容边界起，该块的字体中呈现的空格(U+0020)宽度的8倍的位置 如果 white-space 被设置为 normal、nowrap 或者 pre-line 的行结束处有一个空格(U+0020)，它会被移除 如果 white-space 被设置为 pre-wrap 的行结束处有一个空格(U+0020)或者制表符(U+0009)，UA 可以从视觉上把它们合并起来 浮动的和绝对定位的元素不会引入换行机会 注意：CSS2.2 没有完整定义换行机会出现的位置 16.6.2 空白字符合并的双向性示例 给出如下标记片段，特别注意空格（为了强调和标识带有不同背景和边框）： ... 元素代表一个从左向右的嵌入）， 元素代表一个从右向左的嵌入，假设 white-space 被设置为 normal，上面的处理模型将产生如下结果： 这样会剩下两个空格，一个在 A 后面处于从左向右的嵌入层级，一个在 B 后面处于从右向左的嵌入层级。然后根据 Unicode 双向算法来渲染，结果为： 注意：A 和 B 之间有两个空格，而 B 和 C 之间没有。有时可以通过使用字符的自然双向性而不是显式嵌入层级来避免。还有，最好避免紧跟在开始标签后和结束标签前的空格，因为在处理空白字符合并时，这往往会引发奇怪的事情 16.6.3 控制与合并字符的细节 除U+0009（tab），U+000A（换行），U+0020（空格）和U+202x（双向格式化字符）外的控制字符会被当作任意常规字符，以相同方式渲染 组合字符（Combining character）应该被当作那些将被组合的字符的一部分。例如，如果具有类似于 o&#x308; 的内容的话，:first-letter 会样式化整个字形，而不会只匹配基本字符（base character） Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-06-24 15:09:20 "},"docs/CSS/CSS2.2/17 表格.html":{"url":"docs/CSS/CSS2.2/17 表格.html","title":"17 表格","keywords":"","body":"17 表格 17.1 表格简介 本章定义了 CSS 中表格的处理模型。布局是该处理模型的一部分。对于布局，本章介绍了两种算法：第一种是固定表格布局算法（原：the fixed table layout algorithm），是明确定义的；第二种是自动表格布局算法（原：the automatic table layout algorithm），本规范并没有完整定义它。 对于自动表格布局算法，有些应用广泛的实现已经达到了相当接近的可交互性（原：relatively close interoperability）。 表格布局可以用于数据之间的表格关系。作者在文档语言中指定这些关系，用 CSS2.2 指定其呈现（原：presentation）。 在可视化媒介中，CSS 表格可以实现特定的布局。这种情况下，作者不应该在文档语言中使用表格相关的元素，而应该给相关结构元素应用 CSS 来实现需要的布局。 作者可以把表格当作一个矩形单元网格来指定其视觉格式。可以分别将行和列的单元格组织成行组（原：row groups）和列组（原：column groups）。在行，列，行组，列组和单元格的周围可以绘制边框（CSS2.2 中有两种边框模型）。作者可以把单元格中的数据垂直或者水平对齐，以及对齐一行或一列里的所有单元格中的数据。 用 HTML4 描述的一个简单的 3 行 3 列表格： This is a simple 3x3 table Header 1 Cell 1 Cell 2 Header 2 Cell 3 Cell 4 Header 3 Cell 5 Cell 6 该代码创建了一个表格（ 元素），3 行（ 元素），3 个表头单元格（ 元素）和 6 个数据单元格（ 元素）。注意，本例中的 3 列是隐式指定的：列数与表头和数据单元格需要的列数相同。 下列 CSS 规则让表头单元格中的文本水平居中，并让表头单元格中的文本表现为粗体： th { text-align: center; font-weight: bold } 下面的规则让 表头单元格 中的文本相对其基线对齐，并让每个 数据单元格 中的文本垂直居中： th { vertical-align: baseline } td { vertical-align: middle } 下面的规则指定了 第一行 具有 3px 的蓝色实线边框，让 其它行 具有 1px 的黑色实线边框： table { border-collapse: collapse } tr#row1 { border: 3px solid blue } tr#row2 { border: 1px solid black } tr#row3 { border: 1px solid black } 然而，注意，行周围的边框（原：borders）在两行相接的位置有重叠。row1 和 row2 之间的边框将是什么颜色（黑色还是蓝色）和粗细程度（1px 还是 3px）？我们在边框冲突处理小节讨论这个话题 如下规则把表格标题放在了表格上方： caption { caption-side: top } 之前的示例展示了 CSS 怎样配合 HTML4 元素。在 HTML4 中，各种表格元素（TABLE，CAPTION，THEAD，TBODY，TFOOT，COL，COLGROUP，TH 和 TD）的语义都被明确定义了。在其它文档语言（比如，XML 应用程序）中，可能不存在预定义的表格元素。因此 CSS2.2 允许作者通过 display 属性把文档语言元素“映射”到表格元素。比如，下列规则让 FOO 元素表现得像 HTML TABLE 元素一样，让 BAR 元素表现得像 CAPTION 元素一样： FOO { display : table } BAR { display : table-caption } 我们在接下来的小节中讨论各种表格元素。本规范中，术语表格元素指的是表格创建中涉及的任意元素。内部表格元素是指生成行、行组、列、列组或者单元格的元素。 17.2 CSS 表格模型 CSS 表格模型基于 HTML4 表格模型，其表格结构与表格的可视化布局极为相似。该模型中，一个表格由一个可选的标题和任意行数的单元格组成。表格模型可以说是 \"以行为主（row primary）\" 的，因为作者在文档语言中显式指定行而不是列。列是在指定好所有行后衍生出来的--每行的第一个单元格属于第一列，第二个属于第二列，等等）。行和列可以被结构化分组，并且这种分组会反映在表现中（比如，可以在一组行周围绘制边框）。 因此，表格模型由表格、标题、行、行组（包括表头组和表尾组）、列、列组和单元格组成。 CSS 模型不要求文档语言包含 有与这些组件对应 的元素。对于没有预定义的表格元素的文档语言（比如 XML 应用程序），作者必须把文档语言元素映射到表格元素上，这通过 display 属性来完成。下列 display 值为任意元素赋予表格格式化规则： table(HTML中的TABLE) 指定一个元素定义一个块级表格：它是一个参与 块格式化上下文 的矩形块 inline-table (HTML中的TABLE) 指定一个元素定义一个行内级表格：它是一个参与 行内格式化上下文 的矩形块 table-row (HTML中的TR) 指定元素是一行单元格 table-row-group (HTML中的TBODY) 指定元素对一行或多行进行分组 table-header-group (HTML中的THEAD) 类似于 table-row-group，但对于可视化格式而言，该行组总是显示在所有其它行和行组之前，在所有顶部标题之后。打印用户代理可能会在每一页重复跨越多页的表头。如果一个表格含有多个具有 display: table-header-group 的元素，只有第一个会被渲染成表头，其它的就当它们具有 display: table-row-group table-footer-group (HTML中的TFOOT) 类似于 table-row-group，但对于可视化格式而言，该行组总是显示在所有其它行和行组之后，在所有底部标题之前。打印用户代理可能会在每一页重复跨越多页的 footer 行。如果一个表格含有多个具有 display: table-footer-group 的元素，只有第一个会被渲染成 footer，其它的就当它们具有 display: table-row-group table-column (HTML中的COL) 指定元素描述一列单元格 table-column-group (HTML中的COLGROUP) 指定元素对一列或者多列进行分组 table-cell (HTML中的TD, TH) 指定元素代表一个表格单元 table-caption (HTML中的CAPTION) 为表格指定一个标题。所有具有 display: table-caption 的元素都必须渲染，如17.4 节所述 在布局期间，具有这些 display 值的替换元素会被视为给定的 display 类型。比如，一个设置了 display: table-cell 的图片将填满可用的单元格空间，并且它的尺寸会像普通单元格一样被用于表格尺寸算法。 display 被设置为 table-column 或者 table-column-group 的元素不会被渲染（就像它们具有 display: none一样），但它们有用，因为它们可以具有能为其代表的列引入样式的属性。 附录中 HTML4 的默认样式表描述了 HTML4 中这些值的应用： table { display: table } tr { display: table-row } thead { display: table-header-group } tbody { display: table-row-group } tfoot { display: table-footer-group } col { display: table-column } colgroup { display: table-column-group } td, th { display: table-cell } caption { display: table-caption } 用户代理可能会忽略 HTML 表格元素上的这些 display 属性值，因为 HTML 表格可能为了向后兼容渲染，而用其它算法渲染。然而，这并不妨碍对 HTML 中其它非表格元素应用 display: table 17.2.1 匿名表格对象 除 HTML 外的文档语言可能不包含 CSS2.2 表格模型中的所有元素。这种情况下，“缺失的”元素必须要假定（原：assumed）出来，以配合表格模型。所有表格元素将在它周围自动生成必要的匿名表格对象，至少包括 3 个嵌套的对象，分别对应 'table'/'inline-table'元素，table-row 元素和 table-cell 元素。缺失的元素根据下列规则生成匿名对象（比如，可视化表格布局中的匿名盒）： 在这些规则中，定义了下列术语： 行组盒（row group box） table-row-group，table-header-group 或者 table-footer-group 适当的表格子级（proper table child） table-row 盒子，行组盒盒子，table-column 盒子，table-column-group 盒子或者 table-caption 盒子 适当的表格行父级（proper table row parent） table 或者 inline-table盒子 或者 行组盒子 内部表格盒子（internal table box） table-cell 盒子，table-row 盒子，行组盒子，table-column 盒子或者 table-column-group 盒子 表格容器（tabular container） table-row 盒子或者适当的表格行父级 连续的（consecutive） 如果两个兄弟盒子没有 除只含空白字符的匿名行内盒子外的 中间兄弟，它们就是连续的。如果一系列兄弟盒子中每个盒子都与（该序列中）它前面的那个是连续的，那么这些兄弟盒子是连续的 这些规则中，流外（原：out-of-flow）元素被视为宽高都为 0 的行内元素，其包含块也根据这些规则来选择 以下步骤分 3 个阶段执行： 移除不相关的盒子： 一个 table-column 父级的所有子级盒会被当作它们具有 display: none 一样 如果一个 table-column-group 父级的子级 C 不是一个 table-column 盒，那么就当它具有 display: none 如果一个表格容器 P 的子级 C 是一个只含有空白字符的匿名行内盒子，并且如果有的话，它前后紧挨着的兄弟分别为 P的适当的表格后代和 table-caption 或者内部表格盒子，那么就当它具有 display: none。如果盒子 D 可以作为 A 的后代，而不会导致任何中间 table 或者 inline-table 生成的话，D 是 A 的一个适当的表格后代 如果盒子 B 是一个只含空白字符的匿名行内盒子，并且位于两个紧挨着的兄弟之间，（兄弟）是 内部表格盒子 或者 table-caption 盒子，那么就当 B 具有 display: none 生成缺失的子级容器（wrapper） 如果一个 table 或者 inline-table 盒子的子级 C 不是一个 适当的表格子级，那么就在 C 和 C 的所有连续的非适当的表格子级兄弟周围生成一个匿名 table-row 盒子 如果一个 行组盒子 的子级 C 不是一个 table-row 盒子，就在 C 和 C 的所有连续的非 table-row 盒子的兄弟周围生成一个匿名 table-row 盒子 如果一个 table-row 盒子的子级 C 不是一个 table-cell，就在 C 和 C 的所有连续的非 table-cell 盒子兄弟生成一个匿名 table-cell 盒子 生成缺失的父级 对于一系列连续的内部表格和 table-caption 兄弟中的每一个 table-cell 盒子 C，如果 C 的父级不是一个 table-row，就在 C 和 C 的所有连续的 table-cell 盒子兄弟周围生成一个匿名 table-row 盒子 对于一系列连续的 适当的表格子级 中的每个 适当的表格子级 C，如果 C 缺少父级（misparented），就在 C 和 C 的所有连续的 适当的表格子级兄弟 周围生成一个匿名 table 或者 inline-table 盒子 T（如果 C 的父级是一个 inline 盒子，那么 T 必须是一个 inline-table 盒子，否则就必须是一个 table 盒子） 如果一个 table-row 的父级既不是一个行组盒子也不是一个 table 或者 inline-table 盒，它就缺少父级（原：misparented） 如果一个 table-column 的父级既不是一个 table-column-group 盒也不是一个 table 或者 inline-table 盒子，它就缺少父级（原：misparented） 如果一个行组盒子，table-column-group 盒子或者 table-caption 盒子的父级既不是一个 table 盒子也不是一个 inline-table 盒子，它就缺少父级（原：misparented） 在这个 XML 示例中，假设 元素包含 元素： George 4287 1998 因为关联的样式表是： HBOX { display: table-row } VBOX { display: table-cell } 本例中，假设 3 个 table-cell 元素包含行中的文本。注意文本被进一步包进了匿名行内盒子中，如视觉格式化模型中所述： This is the top row. This is the middle row. This is the bottom row. 样式表为： STACK { display: inline-table } ROW { display: table-row } D { display: inline; font-weight: bolder } 17.3 列 表格单元可以属于两个上下文：行和列。然而，在源文档中单元格是行的后代，而不是列的。尽管如此，仍然可以通过在列上设置属性来影响单元格的某些方面。 下列属性适用于列和列组元素： border：只有在表格元素的 border-collapse 被设置为 collapse 时，各种border 属性才适用于列。这种情况下，在列和列组上设置的边框将输入到冲突处理算法中，以选择每个单元格边界的边框样式 background：只有在单元格和行背景透明时，才可以通过 background 属性设置列中单元格的背景。见 \"表格层与透明性\" 小节 width：width 属性给定了最小列宽 visibility：如果一列的 visibility 被设置为 collapse，该列中的元素都不会被渲染，并且跨越到其它列的单元格会被裁剪。此外，表格宽度会减掉该列所占的宽度。见下面的 \"动态效果\"。visibility 的其它值不影响（列中元素） 下面是一些给列设置属性的样式规则示例。前两条规则共同实现了 HTML4 值为 cols 的 rules 属性。第 3 条规则让 \"totals\" 列变为蓝色，最后2条规则展示了怎样通过固定布局算法让一列（具有）固定大小： col { border-style: none solid } table { border-style: hidden } col.totals { background: blue } table { table-layout: fixed } col.totals { width: 5em } 17.4 视觉格式化模型中的表格 根据视觉格式化模型，一个表格可以表现得像个块级（对于 display: table）或者行内级（对于 display: inline-table）元素 这两种情况下，表格都会生成一个叫做表格容器盒子（原：table wrapper box） 的主块盒子，它包含 表格盒子本身 以及 所有标题盒子（按文档顺序）。表格盒子是一个含有 该表格内部表格盒子 的块级盒子。标题盒子是保留其原本的内容、填充、外边距和边框区的块级盒子，会被当作表格容器盒子中的常规块盒子来渲染。标题盒子放在表格盒子前面还是后面由 caption-side 属性决定，如下所述 对于 display: table（的元素）的表格容器盒子是一个块级（盒子）。对于 display: inline-table（的元素）的表格容器盒子是一个行内级（盒子）。表格容器盒子建立了一个块格式化上下文，表格容器盒子建立了一个表格格式化上下文。对 inline-table 进行基线垂直对齐时，使用表格盒子（不是表格容器盒子）。表格容器盒的的宽度是它里面的表格盒的边框边界宽度（原：border-edge width），如 17.5.2 节所述。表格上 width 和 height 的百分比是相对于表格容器盒子的包含块的，而不是表格容器盒子本身 表格元素上 position、float、margin-*、top、right、bottom和 left 属性的计算值被应用在表格容器盒子上，而不是表格盒子。所有其它不可继承的属性值应用在表格盒子上，而不是表格容器盒子（如果表格元素的值未在表格和表格容器盒子中使用，就用初始值代替） 17.4.1 标题定位与对齐 关键信息摘要： 属性名称：caption-side 值：top | bottom | inherit 初始值：top 适用元素：'table-caption' elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性指定了标题盒子相对于表格盒子的位置。值含义如下： top：把标题盒子放在表格盒子上方 bottom：把标题盒子放在表格盒子下方 注意：CSS2 描述了一种不同的宽度（计算）和水平对齐行为。这种行为将在 CSS3 中通过该属性的 top-outside 和 bottom-outside 值引入 为了在标题盒子里水平对齐标题内容，可以使用 text-align 属性 本例中，（通过）caption-side 属性把标题放在了表格下方。标题将和表格的父级一样宽，并且标题文本将会左对齐 caption { caption-side: bottom; width: auto; text-align: left } 17.5 表格内容的可视化布局 内部表格元素生成带有内容和边框的矩形盒子，单元格也有填充。内部表格元素没有外边距 这些盒子的可视化布局由不规则行列组成的矩形网格控制。每个盒子占据整数个单元格，由下列规则来定。这些规则不适用于 HTML4 及更早的 HTML 版本，HTML 对行和列跨度（原：row and column spans）施加了自己的限制： 每个行盒子占据一行网格单元。行盒子一起按照源文档中出现的顺序从上到下铺满表格（即，表格占用的网格行与行元素的数量完全相同） 一个行组与它所包含的行占据的网格单元相同 一个列盒子占据一列或者多列网格单元。列盒子按照其出现顺序一个挨一个地放置。第一列可能在左边或者右边，取决于表格 direction 属性的值 一个列组盒子与它所包含的列占据的网格单元相同 单元格可以跨越多个行或者列 一个单元格盒子不能超出表格的最后一行或者行组，用户代理必须缩短它直到能适应 合并边框模型中，行、列、行组和列组的边缘与单元格边框所在的假想网格线一致（因此，该模型中，所有行恰好铺满表格，不会留下空白，列也是这样）。在独立边框模型中，边与单元格的border边完全一致（因此，该模型中，行、列、行组或者列组之间可能存在空白，对应 border-spacing 属性） 注意 表格单元的定位和浮动会让它们不再是表格单元，根据9.7节中的规则。当应用浮动时，匿名表格对象上的规则也可能导致创建匿名单元格对象 下例描述了规则5。下列非法 (X)HTML 片段定义了冲突的单元格： 1 2 3 4 5 用户代理可以自由视觉上重叠单元格，如左图。或者移动单元格来避免视觉重叠，如右图 上面是 一个错误 HTML 表格的两种可能渲染方式 17.5.1 表格层与透明性 为了找出每个表格单元背景，不同的表格元素可以被看作位于6个叠加的层上。其中某一层中设置在某个元素上的背景只有当它上方的层都具有透明背景时，才可见 表格层级图解： 最底层是个单一平面，表示表格盒子本身。和所有盒子一样，它可以是透明的 下一层包含列组。每个列组从顶行单元格的顶部延伸到底行单元格的底部，从它最左端的列的左边界到它最右端的列的右边界。背景恰好完全覆盖列组中所有的单元格区域，即使它们跨越到了列组外，但这种区域上的差异不会影响背景图片定位 列组上面是表示列盒的区域。每列的宽度与列组相同，高度和列中的常规（单列跨度）单元格相同。背景恰好完全覆盖列中所有单元格区域，即使它们跨越到了列外，但这种区域上的差异不会影响背景图片定位 下一层包含行组，每个行组从它第一列顶部单元格的左上角延伸到最后一列底部单元格的右下角 倒数第二层包含行。每行的宽度与行组相同，高度和行中的常规（单行跨度）单元格相同。与列类似，背景恰好完全覆盖行中所有的单元格区域，即使它们跨越到了行外，但这种区域上的差异不会影响背景图片定位 最顶层包含单元格自身。如图所示，虽然所有行都含有相同数目的单元格，但并非每个单元格都有具体内容。在独立边框模型（border-collapse 为 separate）中，如果它们的 empty-cells 属性值为 hide，这些 \"空\" 单元格的单元格、行、行组、列和列组的背景都将是透明的，会让表格背景显示出来 一个 \"缺失单元格（原：missing cell）\" 是一个没有被元素或伪元素占据的行/列网格中的单元格。缺失单元格会被当作一个占据该网格位置的匿名表格单元盒子 下例中，第一行含有 4 个非空单元格，而第二行只含有一个非空单元格，因此，表格背景会透出来，除了第一行中那个跨越到了该行的单元格的所在的位置。下列 HTML 代码和样式规则： Table example table { background: #ff0; border: solid black; empty-cells: hide } tr { background: red } td { border: solid black } 1 2 3 4 5 可能会被格式化成这样（底行具有空元素的表格）： 注意，如果表格具有 border-collapse: separate，由 border-spacing 属性给定的区域的背景总是该表格元素的背景。见独立边框模型 17.5.2 表格宽度算法：table-layout 属性 CSS 没有为表格定义一种“最佳”布局，因为在很多场景下，最佳的定义是个品味问题。CSS 只定义了用户代理在布局表格时必须遵守的一些约束。用户代理可以用任何它们想用的算法来实现，并且可以自由选择偏重渲染速度还是精确程度，设定了“固定布局算法”时除外 注意，本节重写了 10.3 节描述的用于计算宽度的规则。特殊的，如果一个表格的外边距被设置为 '0'，宽度被设置为 'auto'，表格将不会自动改变大小填满其包含块。然而，一旦表格 'width' 的计算值确定了（用下面给出的算法，或者在适当的时候使用某些依赖 UA 的其它算法），就应用 10.3 节的其它部分。因此，例如，左右外边距为 'auto' 能让表格居中 CSS将来的更新可能会引入让表格自动适应其包含块的方法 关键信息摘要： 属性名称：table-layout 值：auto | fixed | inherit 初始值：auto 适用元素：'table' and 'inline-table' elements 继承：no 百分比：N/A 适用媒体：visual 计算值：as specified table-layout 属性控制用于表格单元、行和列布局的算法。值含义如下： fixed：用固定表格布局算法 auto：用任意自动表格布局算法 下文描述了这两种算法 17.5.2.1 固定表格布局 用这种（快速）算法，表格的水平布局不依赖单元格的内容，它只取决于表格宽度，列宽和边框或者单元格间距 表格的宽度可以通过 width 属性显式指定。auto 值（对于 display: table 和 display: inline-table 都适用）表示用自动表格布局算法。然而，如果表格是一个常规流中的块级表格（display: table），UA 可以（但不是必须）用 10.3.3 的算法来计算宽度并应用固定表格布局，即使指定的宽度是 auto width 为 auto 时，如果 UA 支持固定表格布局，下列（规则）将会创建一个比其包含块窄 4em 的表格： table { table-layout: fixed; margin-left: 2em; margin-right: 2em } 在固定表格布局算法中，每列的宽度由下述规则决定： width 属性值不为 auto 的列元素所在的列宽度就设置为该宽度值 否则，由第一行中 width 属性值不为 auto 的单元格确定该列的宽度。如果单元格跨越了多列，就给宽度除以列数 所有剩余列均分剩余的水平表格空间（减去边框或单元格间距） 表格的宽度为表格元素的 width 值与列宽之和（加上单元格间距或者边框）两者之间的较大值。如果表格宽度比列宽之和还宽，额外的空间应该分布在各列中 如果一个后续行具有的列数目大于由 table-column 元素确定的数值与由第一行确定的数值两者之间的较大值，那么就不渲染额外的列。CSS2.2 没有定义已渲染的列和表格的宽度，在使用 table-layout: fixed 时，作者不应该省掉（omit）第一行中的列 按这种方式，一旦接收到了完整的第一行，用户代理就可以开始布局表格了。后续行中的单元格不影响列宽。所有内容溢出的单元格，用 overflow 属性来确定是否裁剪溢出的内容 17.5.2.2 自动表格布局 在该算法中（一般要求最多遍历两次），表格的宽度由它所包含的列（和中间边框）的宽度决定。该算法反映了编写本规范时几种流行的HTML用户代理的行为。table-layout 为 auto 时，不要求 UA 实现该算法来决定表格布局。它们可以用任何其它算法，即使会导致不同的行为 自动表格布局的输入必须只包括包含块的宽度、表格及其所有后代的内容及设置的 CSS 属性 注意 在 CSS3 中，这块可能会被定义得更详细 本节剩余部分是非规范的 该算法可能很低效，因为它需要用户代理在确定最终布局之前，拿到表格中所有内容，并且可能需要多次遍历 列宽由下列步骤决定： 计算每个单元格的最小内容宽度(MCW)：格式化内容可以跨越任意多行，但不能从单元格溢出。如果单元格指定的 width (W)大于 MCW，W 就是最小单元格宽度。 auto 值表示 MCW 是最小单元格宽度。然后，计算每个单元格的 \"最大\" 宽度：格式化内容，不考虑除显式换行外的换行 对于每一列，从只跨越该列的单元格中确定一个最大和最小列宽。最小值是单元格所需的最小单元格宽度（或列width，以较大的值为准）。最大值是单元格所需的最大单元格宽度（或者列width，以较大的值为准） 对于每个跨越多列的单元格，增加其所跨列的最小宽度，让它们至少与单元格一样宽。对于最大宽度也这样处理。如果可能的话，把跨越的所有列再扩宽差不多相同的宽度 对于每个 width 不为 auto 的列组元素，增加其所跨列的最小宽度，让它们至少与列组的 width 一样宽 这样每一列都有了一个最大和最小宽度 标题最小宽度（CAPMIN）是通过计算每个标题的最小标题外宽（outer width），作为含有被格式化为 display: block 的标题的假想表格单元的 MCW。最小标题外宽中的最大值是CAPMIN 列和标题宽度对最终表格宽度的影响如下： 如果 table 或者 inline-table 元素的 width 属性的计算值(W)不为 auto，宽度的应用值就是W、CAPMIN、以及所有列加上单元格间距和边框(MIN)所需要的最小宽度三者之间的最大值，如果宽度的应用值大于MIN，额外的宽度应该分布在各列中 如果 table 或者具有 width: auto 的 inline-table 元素，宽度的应用值为表格包含块的宽度，CAPMIN和MIN三者之间的最大值。然而，如果CAPMIN或者列加上单元格间距和边框(MAX)所需要的最大宽度都小于包含块宽度的话，就用max(MAX, CAPMIN) 百分比值的列宽是相对于表格宽度的。如果表格具有 width: auto，百分比表示对列宽的约束，UA 应该尝试满足它（显然，这并不总是可能的：如果列宽是 '110%' 的话，该约束无法满足） 注意：该算法中，行（和行组）和列（和列组）都受其所含的单元格尺寸的约束。设置列的宽度可能会间接影响行的高度，反之亦然 17.5.3 表格高度算法 表格的高度由 table 或者 inline-table 的 height 属性给定。auto 值表示高度为行高度之和加上所有单元格间距和边框。所有其它值都会被当作最小高度。当 height 属性导致表格比其它情况更高时，CSS2.2 没有定义额外空间如何分布 注意：CSS 将来的更新可能会进一步详细说明这个问题 一旦用户代理有了该行中所有可用单元格，table-row 元素的盒子的高度就能计算了：为该行 height 的计算值，行中每个单元格 height 的计算值，以及单元格所需要的最小高度(MIN)三者之间的最大值。table-row 的 height 值为 auto 表示用于布局的行高度为 MIN。MIN 取决于单元格盒子的高度和单元格盒子的对齐方式（与行盒子高度的计算非常类似）。表格单元和表格行的高度被指定为百分比值时，CSS2.2 没有定义如何计算其高度。CSS2.2 没有定义行组上 height 的含义 CSS2.2 中，一个单元格盒子的高度是内容所需的最小高度。表格单元的 height 属性会影响行的高度（见上文），但不会增加该单元格的高度 CSS2.2 没有指定跨越多行的单元格怎样影响行高度的计算，但涉及的行高度之和必须大到能够包住跨行的单元格 每个表格单元的 vertical-align 属性决定了它在行中的对齐方式。每个单元格的内容都具有基线、顶部、中部和底部，如同行自身一样。在表格上下文中，vertical-align 的值含义如下： baseline：单元格的基线被放在与它跨越的第一行的基线相同的高度（单元格和行的基线的定义见下文） top：单元格盒子的顶部与它跨越的第一行的顶部对齐 bottom：单元格盒子的底部与它跨越的最后一行的底部对齐 middle：单元格的中心与它跨越的行的中心对齐 sub, super, text-top, text-bottom, , ：这些值不适用于单元格，单元格会相对基线对齐 一个单元格的基线是该单元格中 第一个流内行盒子，或者该单元格中 第一个流内表格行 的基线，以先出现的为准。如果没有这样的行盒子或者表格行，基线就是该单元格盒子的内容边界的底部。为了找出基线，具有滚动机制（见 overflow 属性）的流内盒子必须被当作滚动到其初始位置了。注意，单元格的基线可能低于于其下边框，见下面的示例 单元格盒子的顶部到所有具有 vertical-align: baseline 的单元格的基线之间的最远距离用于设置行的基线，下面是个示例： 单元格盒子1和2相对各自基线对齐。单元格盒子2基线上方的高度最大，以致于决定了行的基线。 如果一行没有相对其基线对齐的单元格盒子，该行的基线就是该行中最低的单元格的内容边界的底部。 为了避免歧义，单元格的对齐按如下顺序进行： 首先，定位那些相对于各自基线对齐的单元格，这将建立行基线。然后，定位具有 vertical-align: top 的单元格 现在行具有顶部，可能有基线，还有个暂定高度，（暂定高度）为从顶部到目前已定位的单元格中最低的底部（见下面单元格内边距的（添加）条件） 如果任意剩余的与底部或者中部对齐的单元格具有大于该行当前高度的高度，通过降低底部，将该行的高度增加至这些单元格高度的最大值 最后定位其余单元格 小于行高度的单元格盒子会被添上额外的上下填充 本例中单元格的基线低于其下边框下方： div { height: 0; overflow: hidden; } Test 17.5.4 列中元素的水平对齐 一个单元格盒子里的行内级内容的水平对齐方式可以通过该元素上 text-align 属性的值来指定 17.5.5 动态行列效果 行、行组、列和列组元素的 visibility 属性取 collapse 值。该值会让整行或者整列从显示结果中移除，这些行和列在常规情况下占据的空间可以供其它内容使用。与合并列或行相交的跨行跨列的内容会被裁剪掉。然而，行或列的抑制作用不会影响表格布局。这样就允许动态移除表格行或列，而不用为了列约束中潜在的变动而强制重新布局表格 17.6 边框 CSS 中有两种不同的模型可以用来设置表格单元的边框。一种最适合围绕着各个单元格的所谓的独立边框，另一种适合从表格一端到另一端的连续边框。通过这两种模型能实现许多边框样式，所以用哪一种通常是喜好问题。 关键信息摘要： 属性名称：border-collapse 值：collapse | separate | inherit 初始值：separate 适用元素：'table' and 'inline-table' elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 该属性选择了表格的边框模型。separate 值选择独立边框模型，collapse 值选择合并边框模型。这两种模型如下所述 17.6.1 独立边框模型 关键信息摘要： 属性名称：border-spacing 值： ? | inherit 初始值：0 适用元素：'table' and 'inline-table' elements* 继承：yes 百分比：N/A 适用媒体：visual 计算值：two absolute lengths 注意：用户代理也可以给 frameset 元素应用 border-spacing 属性。哪些元素是 frameset 元素不由本规范定义，由文档语言来定。比如，HTML4 定义了一个 元素，而 XHTML1.0 定义了一个 元素。因此，一个 frameset 元素上的 border-spacing 属性可以用作非标准的 framespacing 属性的合法替代品。 该长度指定了相邻单元格边框之间的距离。如果指定了 1 个长度，就把它作为水平和垂直间隔。如果指定了 2 个，第一个是水平间隔，第二个是垂直间隔。长度不能为负。 表格边框与表格边缘上的单元格边框之间的距离为 表格在该边的填充 加上 相关边框间隔距离。比如，在右手边，该距离为右填充 + 水平水平边框间隔。 表格的宽度是从左填充内边界到右填充内边界的距离（包括边框间隔但不包括填充和边框）。 然而，在 HTML 和 XHTML1 中， 元素的宽度是从左边框边界到右边框边界的距离。 注意：在 CSS3 中，这种特殊的需求将由 UA 样式表和 box-sizing 属性来定义。 该模型中，每个单元格都有各自的边框。border-spacing 属性指定了相邻单元格的边框之间的距离。这段间隔中，行、列、行组和列组的背景是不可见的，会让表格背景透出来。行、列、行组和列组没有边框（即，用户代理必须忽略这些元素的 border 属性）。 下图中的表格可能是下面样式表产生的结果： table { border: outset 10pt; border-collapse: separate; border-spacing: 15pt } td { border: inset 5pt } td.special { border: inset 10pt } /* The top-left cell */ 17.6.1.1 空单元格的边框与背景：empty-cells 属性 关键信息摘要： 属性名称：empty-cells 值：show | hide | inherit 初始值：show 适用元素：'table-cell' elements 继承：yes 百分比：N/A 适用媒体：visual 计算值：as specified 在独立边框模型中，该属性控制不含可见内容的单元格周围的边框和背景的渲染。空单元格和 visibility 属性被设置为 hidden 的单元格被认为不含可见内容。单元格为空，除非它们包含下列一项或多项内容： 浮动内容（包括空元素） 在流内内容（包括空元素）之外的空白，已被 white-space 属性处理所合并 当该属性值为 show 时，边框和背景会被绘制在空单元格的周围/后面（像常规单元格一样）。 hide 值表示不会在空单元格周围/后面渲染边框和背景（见 17.5.1 的第 6 点）。而且，如果行中的所有单元格都具有 hide 值，并且没有可见内容，那么该行为 0 高度，并且该行只有一边存在垂直边框间隔。 如下规则会在所有单元格周围绘制边框和背景： table { empty-cells: show } 17.6.2 合并边框模型 在合并边框模型中，可以指定边框环绕在一个单元格、行、行组、列和列组的一部分或者全部。可以通过 HTML 边框的 rules 属性来指定它。 边框在单元格之间的网格线上居中。用户代理必须找出一个对奇数离散单位（屏幕像素，打印机点）的舍入约束规则。 下图展示了表格宽度，边框宽度，填充和单元格宽度之间的相互影响。它们的关系由下列等式给定，对表格的每一行都成立： 其中 n 是该行中单元格的数量，padding-left[i] 和 padding-right[i] 表示单元格 [i] 的 left (right) padding，border-width[i]表示单元格 [i] 和 [i + 1] 之间的边框。 UA 必须通过检查表格第一行中的第一个和最后一个单元格，为表格计算一个初始的左右边框宽度。表格的左边框宽度是第一个单元格的合并后左边框的一半，而表格的右边框宽度是最后一个单元格的合并后右边框的一半。如果后续行具有更大的合并后左右边框，那么所有超出的部分会涌进（spill into）表格的外边距区。 表格的顶部边框宽度通过检查 所有顶部边框 与 表格的顶部边框 合并了的单元格来计算，表格的顶部边框宽度 等于 最大合并顶部边框的一半。底部边框宽度通过检查所有底部边框与表格的底部合并了的单元格来计算，底部边框宽度等于最大合并底部边框的一半。 在确定表格是否从某些祖先溢出（见 overflow ）时，需要考虑所有涌进外边距的边框。 此图展示了单元格的宽度和单元格的边框及 padding。 注意：在该模型中，表格的宽度包括一半的表格边框。而且，在该模型中，表格没有填充（但有外边距）。 CSS2.2 没有定义表格元素的背景边界的位置。 17.6.2.1 边框冲突处理 在合并边框模型中，每个元素的每条边上的边框可以通过各种与该边相关的元素（单元格、行、行组、列、列组和表格自身）上的 border 属性来指定，而且这些边框宽度，样式和颜色可能不同。经验法则是选择每边上最 \"醒目\" 的边框样式，除了所有 hidden 样式的出现会无条件切断（turn off）边框。 下列规则决定发生冲突时哪种边框样式会“胜出”： border-style 为 hidden 的边框优先于所有其它冲突边框。具有该值的所有边框会抑制此位置的所有边框 具有 none 样式的边框优先级最低。只有在与该边相关的所有元素的 border 属性为 none 时，border 才会被忽略（但注意，none 是 border-style 的默认值） 如果没有 hidden 样式，并且它们中至少有一个不为 none，那么窄边框会被丢弃，用更宽的那个。如果有好几个都具有相同的 border-width，那么样式按这样的顺序来选择：double，solid，dashed，dotted，ridge，outset，groove和优先级最低的：inset 如果 border-style 只在颜色上有差异，那么设置在单元格上的样式优先于设置在行上的，（设置在行上的）优先于行组、列、列组和表格上的。当同类型的两个元素发生冲突时，更靠左（如果表格的 direction 为 ltr 的话。如果是 rtl 就是更靠右的）靠上的优先 下例描述了这些优先级规则的应用，样式表为： table { border-collapse: collapse; border: 5px solid yellow; } *#col1 { border: 3px solid black; } td { border: 1px solid red; padding: 1em; } td.cell5 { border: 5px dashed blue; } td.cell6 { border: 5px solid green; } HTML源码为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 将产生类似于这样的结果（具有合并边框的表格示例）： 一个隐藏合并边框的示例（具有两个被忽略的内边框的表格）： HTML源码： foo bar foo bar 17.6.3 边框样式 border-style的某些值在表格上和在其它元素上的含义不同。在以下列表中用星号标记出来了： none：无边框 *hidden：与 none 相同，但是在合并边框模型中也会抑制所有其它边框（见边框冲突章节） dotted：边框是一系列点 dashed：边框是一系列短线段 solid：边框是一条线段 double：边框是两条实线。两条实线及它们之间的空隙之和等于 border-width 的值 groove：边框看起来像是被刻进了画布 ridge：与'groove'相反：边框看起来像是要从画布里跑出来 *inset：在独立边框模型中，边框让盒看起来像是被嵌进画布了。在合并边框模型中，绘制效果与 ridge相同 *outset：在独立边框模型中，边框让盒看起来像是要从画布里出来了。在合并边框模型中，绘制效果和 groove 相同 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-06-19 13:10:03 "},"docs/CSS/CSS2.2/18 用户界面.html":{"url":"docs/CSS/CSS2.2/18 用户界面.html","title":"18 用户界面","keywords":"","body":"18 用户界面 18.1 光标：cursor 属性 关键信息摘要： 属性名称：cursor 值：[ [ ,]* [ auto | crosshair | default | pointer | move | e-resize | ne-resize | nw-resize | n-resize | se-resize | sw-resize | s-resize | w-resize | text | wait | help | progress ] ] | inherit 初始值：auto 适用元素：all elements 继承：yes 百分比：N/A 适用媒体：visual, interactive 计算值：as specified, except with any relative URLs converted to absolute 此属性指定了 指针式设备 显示的光标类型。值有以下含义： auto：UA 根据当前上下文确定显示的光标 crosshair：十字线（与 \"+\" 类似） default：取决于平台的默认光标。一般展现成箭头 pointer：该光标表明是链接的指针 move：暗示某些东西可以移动 e-resize, ne-resize, nw-resize, n-resize, se-resize, sw-resize, s-resize, w-resize：暗示某些边可以被移动，se-resize 光标可以从盒子的东南角开始移动 text：暗示文本可以被选中。一般展现成 \"I\" 形 wait：暗示程序正忙，用户需要等待。一般展现成 一个表或沙漏 progress：一个进度指示器。程序正在执行某些处理，但与 wait 不同的是，用户仍可以与程序交互。一般展现成旋转的沙滩球，或带有表或沙漏的箭头 help：通过鼠标下方的对象可以获得帮助。一般展现成一个问号或气球 ：用户代理从 URI 指定的资源中获取光标。如果用户代理无法处理光标列表中的第一个光标，它应该尝试处理第二个，等等。如果用户代理无法处理所有用户定义的（user-defined）光标，它必须使用列表末尾的通用光标。除了用一个UA定义的矩形来代替为 background-image 属性建立了坐标系的矩形外，光标的固有尺寸的计算与背景图片类似。UA 定义的矩形应该根据 UA 的操作系统上典型光标的尺寸来定。如果产生的光标尺寸无法适应该矩形，UA 可以按比例缩小产生的光标，直到它能适应该矩形 下例： :link,:visited { cursor: url(example.svg#linkcursor), url(hyper.cur), pointer } 本例把所有超链接上的光标（无论访问与否）都设置成了一个外部 SVG 光标。不支持 SVG 光标的用户代理将跳到下一个值，尝试使用 \"hyper.cur\" 光标。如果也不支持该光标格式，则 UA UA 将跳到下一个值并简单地渲染 pointer 光标。 18.2 系统颜色（已废弃） 系统颜色在 CSS3 Color Module[CSS3COLOR] 已被废弃。 18.3 UA 字体的首选项 像颜色一样，作者也可以通过一种利用用户系统资源的方式来指定字体。详情请查看 font 属性 18.4 动态轮廓：outline 属性 有时，样式表作者可能给可视对象创建轮廓，以此来使它们（如 按钮、活动表单字段、图像映射）凸显出来。CSS2.2 中 轮廓 和 边框 不同的区别如下： 轮廓不占空间 轮廓可以不是矩形的 outline 属性控制这些动态轮廓的样式，关键信息摘要： 属性名称：outline 值：[ || || ] | inherit 初始值：见单独的各个属性 适用元素：all elements 继承：no 百分比：N/A 适用媒体：visual, interactive 计算值：见单独的各个属性 关键信息摘要： 属性名称：outline-width 值： | inherit 初始值：medium 适用元素：all elements 继承：no 百分比：N/A 适用媒体：visual, interactive 计算值：absolute length; '0' if the outline style is 'none' 关键信息摘要： 属性名称：outline-style 值： | inherit 初始值：none 适用元素：all elements 继承：no 百分比：N/A 适用媒体：visual, interactive 计算值：as specified 关键信息摘要： 属性名称：outline-color 值： | invert | inherit 初始值：invert 适用元素：all elements 继承：no 百分比：N/A 适用媒体：visual, interactive 计算值：as specified 用 outline 属性创建的轮廓被绘制在盒子 上面。即轮廓总是位于上面，且不影响该盒子或其它盒子的位置和尺寸。因此，显示或者抑制轮廓不会导致重排（reflow）或者溢出（overflow）。 轮廓会从 边框边缘 外面开始绘制。 轮廓可以是非矩形的。比如，如果元素在多行中断开，则轮廓是包含所有元素盒子的最小轮廓。与 边框 相比，轮廓在 行盒子 的开始处或结束处 不是断开的，而是总会尽量完全连接起来。 outline-width 属性与 border-width 接受相同的值。 outline-style 属性与 border-style 接受相同的值，除了 hidden 值。 outline-color 接受所有的颜色和关键字 invert。invert 用来对屏幕上的像素进行反色。这是一种用来确保焦点边框可见的常见技巧，无论背景色是什么。 不支持屏幕像素反色的平台上的（与 CSS规范）一致的 UA 可以忽略 invert 值。如果 UA 不支持 invert 值，那么 outline-color 属性的初始值为 color 属性的值，与 border-top-color 属性的初始值类似。 outline 是一个简写属性，可以一次性设置 outline-style、outline-width 和 outline-color。 注意：轮廓的所有方向都是一样的。与 边框 相比，不存在 outline-top 或者 outline-left 属性。 本规范没有定义如何绘制多个重叠的轮廓，或者如何为被遮挡在其它元素后面的部分盒子绘制轮廓。 注意：因为轮廓不影响格式化（即盒模型中没给它留任何空间），它可能会与页面上的其它元素重叠。 一个在 元素周围绘制的粗轮廓： button { outline : thick solid} 可通过脚本动态改变轮廓的宽度而不会引起 重排（reflow）。 18.4.1 轮廓与焦点（Outlines and the focus） 图形用户界面可能会用围绕着元素的轮廓来告诉用户页面中的哪些元素具有焦点。这些轮廓不是任何边框，并且开启轮廓和取消轮廓不应该导致文档重排（reflow）。焦点是一份文档中用户交互的对象（比如，对于输入文本，选中按钮等等）。支持的互动媒体组的用户代理必须跟踪焦点位置，并且还必须表现出焦点。这可以通过 动态轮廓 结合 :focus 伪类来实现。 比如，为了在元素具有焦点时，在它周围绘制一条粗黑线，在它处于激活状态时绘制一条粗红线，可以用下列规则： :focus { outline: thick solid black } :active { outline: thick solid red } 18.5 放大（Magnification） CSS工作组认为对文档的放大或者部分放大不应该通过样式表来指定。用户代理可以用不同的方式来支持这种放大（比如，更大的图片，更大的声音，等等）。 在放大一个页面时，UA 应该保留定位元素之间的关系。比如，一个漫画可能由图片和覆盖在上面的文本元素组成。在放大该页面时，用户代理应该保持文本位于漫画对话框（balloon）中。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-05-27 17:41:59 "}}