{"COPYRIGHT.html":{"url":"COPYRIGHT.html","title":"版权","keywords":"","body":"版权 http://creativecommons.org/licenses/by-nc-sa/4.0/ 《不可思议的前端之路》由 chouchou 编写，采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。 本人保留所有权限，保留出版权限，未经本人书面许可任何人不得用于商业出版。 支付宝捐赠请扫码. Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 15:31:05 "},"./":{"url":"./","title":"序言","keywords":"","body":"序言 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 17:57:46 "},"docs/CSS/CSS2.2/1 关于 CSS 2.2 规范.html":{"url":"docs/CSS/CSS2.2/1 关于 CSS 2.2 规范.html","title":"CSS 2.2 中文版","keywords":"","body":"1 关于 CSS 2.2 规范 1.1 CSS 2.2 与 CSS 2 CSS 社区自 1998 年成为推荐（规范）以来，从 CSS 2 中获得了丰富的经验。虽然 CSS 2 规范中的错误在 2011 年的第一个修订版[CSS 21]得到了修正，但有新的勘误表是有必要的。 虽然很多问题可以通过接下来的 CSS 3 规范解决，但目前的状况阻碍了 CSS 2 的实现与互通性。CSS 2.2 规范试图通过以下方式解决这种情况： 保持 CSS 2 中那些已经被广泛接受和实现的部分的兼容性。 合并所有已发布的 CSS 2 勘误表。 如果实现与 CSS 2 规范完全不同，则将规范修改为符合普遍接受的做法。 移除 CSS 2 中那些因为没有被实现而被 CSS 社区拒绝的特性，CSS 2.2 旨在反映那些在HTML 和 XML 语言中被广泛实现的合理特性（不单单是对XML语言，或者HTML）。 移除将被 CSS 3 废弃的 CSS 2 功能，因此鼓励采用 CSS 3 所提出的 功能。 当实现经验表明 CSS 2 需要实现（新特性）时，添加（非常）少量的新属性值。 因此，虽然 CSS 2 样式表不一定与 CSS 2.2 保持向前兼容，但是符合 CSS 2.2 规范的样式更可能兼容现有用户代理，并在将来保持向前兼容。虽然不希望破坏兼容性，但我们认为 CSS 2.2 中修订版本的优点是值得的。 CSS 2.2 源于 CSS 2.1 和 CSS 2，并旨在替代它们。在 CSS 2.2 中，CSS 2的一部分保留一部分删除一部分更改，删除的部分可以用于将来的 CSS 2.2。将来的新规范应该参考 CSS 2.2（除非他们需要 CSS 2 中那些已经在 CSS 2.2 被移除的特性，然后应该仅参考 CSS 2 的这些特性，或者优先参考包含这些特性的 CSS 3 模块）。 1.2 本规范的阅读 这部分非规范。 本规范同时考虑了两种类型的读者：CSS 作者和 CSS 实现者。我们希望该规范将为作者提供编写高效、有吸引力、可访问的文档，不把 CSS 实现的细节告诉他们。而实现者，应该从中寻找构建 符合标准的用户代理 所需的所有内容。规范开篇是 CSS 的一般描述，然后越来越技术和具体。为了快速获取信息，电子版和打印版每章开头都有速查表和内容详情表，以及索引导航。 本规范编写时考虑了两种表现形式：电子版和打印版。虽然这两种形式无疑是相似的，但读者仍会发现一些区别。比如，打印版中链接将失效，并且电子版没有页码。如果存在差异，电子版是文档的权威版本。 1.3 本规范如何组织 这部分非规范。 本规范的章节组织如下： 第 2 章 CSS 2.2 简介：简介包括 CSS 2.2 的简单教程和对 CSS 2.2 中背后的设计原则的讨论。 第 3 - 18 章：CSS 2.2 参考手册：参考手册主要由 CSS 2.2 语言组成，本参考定义了CSS 2.2 样式表中会出现的东西（语法，属性，属性值），以及用户代理该怎样解释这些样式表才能保证一致性 附录：附录包含有关听觉属性（非规范）的信息，HTML 4 的样本样式表，CSS 2.1 的更改，CSS 2.2的语法，规范和信息引用的列表，以及两个索引：一个用于属性，一个用于一般索引。 1.4 约定 1.4.1 文档语言元素和属性（Document language elements and attributes） CSS 属性(原：property)和伪类使用 单引号 CSS 值使用 单引号 文档语言属性(原：attribute)使用小写字母，并用 双引号 1.4.2 CSS 属性定义 CSS 属性的关键信息摘要： Name：属性名称（property-name） Value：合法值和语法 Initial：初始值 Applies to：该属性的适用元素 Inherited：该属性是否继承 Percentages：如何解析百分比值 Media：该属性适用于哪些媒体设备 Computed value：如何计算 计算值（Computed value） 1.4.2.1 值 此部分指定名称为 “property-name” 的属性的合法值集合。属性值可以包含一个或多个组成部分。组成部分值类型以多种方式指定： 关键字值（比如，auto，disc 等等）。 基本数据类型，出现在 “”之间（比如， 和 等等）。 有相同范围的值类型，与属性名相同（比如，、等等）。这种情况下，出现在 “” 之间的类型名就是属性名（比如，），这样的类型不包括 inherit 值。在电子版文档中，每个该类型的实例的非终结符都链接到相应的值定义。 非终结符不会出现同名属性。在这种情况下，非终结符出现在 “” 之间，如。注意 和 之间的区别：后者是根据前者定义的。非终结符位于它在规范中的首次出现的地方。在文档的电子版本中，此类值的每个实例都链接到相应的值定义。 其它的定义的词语以 字面量 形式出现的关键字，没有引号（比如，red）。斜杠（/）和逗号（，）也按字面意思显示。 组成部分的值可以按如下方式排列到属性值中： 几个并列的单词，表示它们必须以给定的顺序全部出现 单竖线(|)分隔两个或者更多可选值：其中必须出现且仅出现一个 双竖线(||)分隔的两个或者更多项：必须出现一个或者多个，顺序随意 双 & 号(&&)分隔的两个或更多部分：必须全部出现，顺序随意 方括号([ ])用来分组 并列比 双 & 号优先级高，双 & 号比双竖线优先级高，双竖线比单竖线优先级高。因此，以下写法是等价的： a b | c || d && e f [ a b ] | [ c || [ d && [ e f ]]] 每个类型，关键字，或者方括号分组都可以跟随以下修饰符之一： 星号（*）表示前面的类型，单词或组出现零次或多次 加号（+）表示前面的类型，单词或组出现零次或多次 问号（?）表示前面的类型，单词或组出现可有可无 花括号中的一对数字（{A, B}）表示前面的类型，，单词或组出现至少出现 A 次 或 B 次。 下面的示例描述了不同的值类型： Value: N | NW | NE Value: [ | thick | thin ]{1,4} Value: [ , ]* Value: ? [ / ]? Value: || Value: inset? && [ {2,4} && ? ] 组成部分的值是根据附录 G.2中的 token 指定的。由于语法允许 expr 生成的组成部分中的 token 之间的空格，因此属性值中的 token 之间可能出现空格。 注意：大多数情况下，使用 空格 区分 token。比如，值 '1em2em' 将被解析为一个带有数字 '1' 和标识符 'em2em'（不是有效单位）的 DIMEN。在这种情况下，在 '2' 之前需要一个空格来将其解析为两个长度 '1em' 和 '2em'。 1.4.2.2 初始值 这部分指定属性的初始值。有关样式表的 指定（值）、继承值、初始值之间的作用，请看 层叠 部分。 1.4.2.3 适用 这部分指定属性适用的元素。任何元素都拥有所有属性，但一些属性对某些元素没有渲染效果，比如，clear 属性只对块级元素起作用。 1.4.2.4 继承 这部分指定属性的值是否继承于祖先元素。有关样式表的 指定（值）、继承值、初始值之间的作用，请看 层叠 部分。 1.4.2.5 百分比 这部分指定属性值如何是百分比的话，应该如何计算。如果出现的是 “N/A”，则表明不支持百分比。 1.4.2.6 媒体类型 这部分指定属性适用的媒体组（类型）。关于媒体组（类型）的信息不是规范的。 1.4.2.7 计算值 这部分指定属性的计算值。关于计算值如何定义的，见 计算值 这一节。 1.4.3 简写属性 某些属性是简写属性，这意味着它们允许作者可以使用单个属性指定多个属性值。 比如，font 属性是可以一次性设置 font-size、font-variant、font-weight、font-size、line-height、font-family 的简写属性。 当简写属性中某些值被省略时，会为每个 省略值 分配其 初始值（见 层叠 部分）。 示例： h1 { font-weight: bold; font-size: 12pt; line-height: 14pt; font-family: Helvetica; font-variant: normal; font-style: normal; } 可以重写为： h1 { font: bold 12pt/14pt Helvetica } 1.4.4 注意事项和示例 所有说明不合法使用的示例都会标记 “ILLEGAL EXAMPLE”。 缺少 DOCTYPE 声明的 HTML 示例是符合 HTML 4.01 Strict DTD HTML4，其它示例与示例给出的 DTD 一致。 所有注意事项都只是一些参考。 规范中的示例和注意事项都会在 HTML 源码中标记出来 1.4.5 图片与长描述 本规范大部分图片都含有 “长描述信息”，“长描述信息” 由 “此图长描述” 来表示。 1.5 致谢 这部分非规范。 CSS 2.2 基于 CSS 2.2 和 CSS 2。对 CSS 2 和 CSS 2.1 贡献的人员见 CSS 2 的致谢部分和CSS 2.1 的致谢部分。 我们感谢以下人员，通过 www-style 邮件的反馈，帮助我们创建了这个规范：TBD。 此外，我们还要特别感谢 TBD。 非常感谢以下人员对测试套件的帮助：TBD ...以及 CSS 1 测试套件的所有贡献者。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/2 CSS 2.2 简介.html":{"url":"docs/CSS/CSS2.2/2 CSS 2.2 简介.html","title":"2 CSS 2.2 简介","keywords":"","body":"2 CSS 2.2 简介 2.1 CSS 2.2 的 HTML 简明教程 这部分非规范。 在本教程中，我们展示设计简单样式表是多么容易。在本教程中，您需要了解一些 HTML（见 HTML4）和一些基本桌面排版术语。 我们从一段简短的 HTML 开始： Bach's home page Bach's home page Johann Sebastian Bach was a prolific composer. 设置 H1 元素的文本为红色： h1 { color: red } 一条 CSS 规则由两个主要组成部分组成：选择器（'h1'）和声明（'color: red'）。在 HTML 中，元素名称不区分大小写，因此 h1 与 H1 一样有效。声明有两部分：属性名称（'color'）和属性值（'red'）。虽然上面的示例试图仅影响呈现 HTML 文档所需的一个属性，但它本身就可以作为样式表。结合其他样式表（CSS 的一个基本特征是样式表被组合），规则将确定文档的最终呈现。 HTML 4 规范定义了如何为 HTML 文档指定样式表规则：在 HTML 文档中，或通过外部样式表。要将样式表放入文档，请使用 STYLE 元素： Bach's home page h1 { color: red } Bach's home page Johann Sebastian Bach was a prolific composer. 为了更大的灵活性，我们建议作者指定外部样式表; 它们可以在不修改源 HTML 文档的情况下进行更改，并且可以在多个文档之间共享。要链接到外部样式表，您可以使用 LINK 元素： Bach's home page Bach's home page Johann Sebastian Bach was a prolific composer. LINK 元素指定： link 的类型：stylesheet href 属性指定样式表的位置 link 的样式表类型：text/css 为了展示样式表与结构化标签的密切联系，我们在教程中继续使用 STYLE 元素，来添加更多颜色： Bach's home page body { color: black; background: white } h1 { color: red; background: white } Bach's home page Johann Sebastian Bach was a prolific composer. 样式表现在有四个规则：前两个设置 BODY 元素的颜色和背景（最好将文本颜色和背景颜色设置在一起），而后两个设置 H1 元素的颜色和背景。 由于没有为 P 元素指定颜色，因此它将从其父元素（即 BODY）继承颜色。 H1 元素也是 BODY 的子元素，但第二个规则会覆盖继承的值。 在 CSS 中，不同值之间经常存在此类冲突，本规范描述了如何解决它们。 CSS 2.2 有超过 90个 属性，包括 color。 让我们看看其他一些： Bach's home page body { font-family: \"Gill Sans\", sans-serif; font-size: 12pt; margin: 3em; } Bach's home page Johann Sebastian Bach was a prolific composer. 首先要注意的是，几个声明被分组，然后由大括号（{...}）括起来的块中，并用分号分隔，尽管最后一个声明后面也可能跟一个分号。 BODY 元素的第一个声明将字体系列设置为 “Gill Sans”。如果该字体不可用，则用户代理（通常称为 “浏览器”）将使用 “sans-serif” 字体系列，该字体系列是所有用户代理知道的五个通用字体系列之一。 BODY 的子元素将继承 font-family 属性的值。 第二个声明将 BODY 元素的字体大小设置为 12pt。 “点” 单元通常用于基于打印的排版，以指示字体大小和其他长度值。这是绝对单位的一个例子，它不会相对于环境进行缩放。 第三个声明使用一个相对单位，它相对于周围环境进行缩放。 “em” 单位指的是元素的字体大小。在这种情况下，结果是 BODY 元素周围的外边距是字体大小的三倍。 2.2 CSS 2.2 的 XML 简明教程 这部分非规范。 CSS 可以与任何结构化文档格式一起使用，比如使用可扩展标记语言[XML11]的应用程序。 事实上，XML 更多地依赖样式表而不是 HTML，因为作者可以创作他们自己的元素，用户代理不知道如何显示（这些）。 这是一个简短的 XML 片段： Fredrick the Great meets Bach Johann Nikolaus Forkel One evening, just as he was getting his flute ready and his musicians were assembled, an officer brought him a list of the strangers who had arrived. 为了以类似文档的方式显示这个片段，我们必须首先声明哪些元素是行内级别的（即，不引起换行符），哪些元素是块级的（即导致换行符）。 INSTRUMENT { display: inline } ARTICLE, HEADLINE, AUTHOR, PARA { display: block } 第一个规则声明 INSTRUMENT 是行内的，第二个规则用逗号分隔的选择器列表声明所有其他元素是块级的。XML 中的元素名称区分大小写，因此以小写形式（比如，“instrument”）编写的选择器与大写（比如，“INSTRUMENT”）不同。 将样式表链接到 XML 文档的一种方法是使用处理指令： Fredrick the Great meets Bach Johann Nikolaus Forkel One evening, just as he was getting his flute ready and his musicians were assembled, an officer brought him a list of the strangers who had arrived. 一个可视化用户代理能够把上面的示例格式化为： 此图长描述 请注意，“flute” 一词仍在段落中，因为它是行内元素 INSTRUMENT 的内容。 尽管如此，文本的格式仍然没有您期望的那样。比如，标题字体大小应该大于文本的其余部分，并且您可能希望以斜体显示作者的名称： INSTRUMENT { display: inline } ARTICLE, HEADLINE, AUTHOR, PARA { display: block } HEADLINE { font-size: 1.3em } AUTHOR { font-style: italic } ARTICLE, HEADLINE, AUTHOR, PARA { margin: 0.5em } 一个可视化用户代理能够把上面的示例格式化为： 此图描述 在样式表中添加更多规则将允许您进一步描述文档的表现。 2.3 CSS 2.2 的处理模型 这部分（除了小节）非规范。 本节介绍了一种支持 CSS 的用户代理如何工作的可能模型。这只是一个概念模型，实际实施可能会有所不同。 在此模型中，用户代理通过执行以下步骤来处理源（文档）： 解析源文档并创建文档树。 确定目标媒体类型。 检索与为目标媒体类型指定的文档相关联的所有样式表。 通过为适用于目标媒体类型的每个属性分配值来标注文档树的每个元素。根据 层叠和继承 一节中描述的机制为属性分配值。 值的计算的一部分取决于适用于目标媒体类型的格式化算法。比如，如果目标媒体是屏幕，则用户代理使用视觉格式化模型。 从有标注的文档树中，生成格式化结构。通常，格式化结构与文档树结构相似，但也可能有很大不同，特别是作者使用伪元素和生成内容时。首先，格式化结构可以不需要时 “树形的”-结构的性质取决于实现。其次，格式化结构可以包含比文档树更多或更少的信息。比如，如果文档树中的元素有 display: none，则元素不会在该格式化结构中生成任何内容。另一方面列表元素可以生成更多信息：列表元素的内容和列表样式信息（比如，▪️）。 注意：CSS 用户代理在此阶段不会改变文档树。特别是，由于样式表产生的内容不会反馈给文档语言处理器（比如，重新解析） 将格式化结构传送给目标媒体（比如，打印结果，在屏幕上显示它们，将它们呈现为语音等）。 2.3.1 canvas 对于所有媒体，术语 canvas 描述 “呈现格式化结构的空间”。画布对于空间的每个维度是无限的，但是渲染通常发生在画布的有限区域内，（该区域）由用户代理根据目标介质建立。比如，呈现给屏幕的用户代理通常施加最小宽度并基于视口的尺寸选择初始宽度。呈现给页面的用户代理通常会施加宽度和高度约束。听觉用户代理可能会对音频空间施加限制，但并不及时。 2.3.2 CSS 2.2 的元素查找模型 CSS 2.2 选择器和属性允许样式表引用文档或用户代理的以下部分： 文档树中的元素以及它们之间的某些关系（见 选择器 部分）。 文档树中元素的属性以及这些属性的值（见 属性选择器部分）。 元素内容的某些部分（见 :first-line和 :first-letter 伪元素）。 文档树处于特定状态时的元素（见 伪类 部分）。 canvas 用来渲染文档的某些部分。 一些系统信息（见 用户界面部分）。 2.4 CSS 设计原则 这部分非规范。 在 CSS 2 和 CSS 1 之前的 CSS 2.2，基于以下设计原则： 向前向后兼容：CSS 2.2 用户代理将能够理解 CSS1 样式表。 CSS1 用户代理将能够读取CSS 2.2 样式表并丢弃他们不理解的部分。此外，没有 CSS 支持的用户代理将能够显示样式增强的文档。当然，通过 CSS 实现的样式增强将不会被渲染，但会呈现所有内容。 对结构化文档的补充：样式表补充了结构化文档（比如，HTML 和 XML 应用程序），为标记文本提供样式信息。在对标记（文本）产生较少或者零影响的前提下，它应该能够轻易改变样式。 供应商，平台和设备的独立性：样式表使文档能够独立于供应商，平台和设备。 样式表本身也与供应商和平台无关，但 CSS 2.2 允许您为一组设备（比如，打印机）设定样式表。 可维护性：通过从文档中指向样式表，网站管理员可以简化站点维护并在整个站点中保持一致的外观。比如，如果组织的背景颜色发生更改，则只需更改一个文件。 简洁：CSS 是一种简单的样式语言，有很好的可读可写性。CSS 属性在最大程度上保持彼此独立，并且通常只有一种方法可以实现某种效果。 网络性能：CSS 提供了如何呈现内容的简洁编码。与 作者经常用于实现某些特定渲染效果的图像或音频文件 相比，样式表通常会减小内容大小。此外，必须打开更少的网络连接，这进一步提高了网络性能。 灵活性：CSS 可以通过多种方式应用于内容。关键功能是能够层叠 默认（用户代理）样式表，用户样式表，链接样式表，文档头以及构成文档正文的元素的属性中指定的样式信息。 丰富性：为作者提供丰富的渲染效果可以增加 Web 作为表达媒介的丰富性。设计人员一直渴望桌面出版和幻灯片应用程序中常见的功能。虽然一些需要的渲染效果与设备独立性有冲突，但 对设计者，CSS 2.2 给予了充分的空间设计。 可选的语言绑定：本规范中描述的 CSS 属性集形成了视觉和听觉呈现的一致格式化模型。可以通过 CSS 语言访问此格式化模型，但也可以绑定到其他语言。比如，JavaScript 程序可以动态地更改某个元素的 “颜色” 属性的值。 可访问性：一些 CSS 功能将使障碍用户更容易访问 Web 控制字体外观的属性，允许作者消除难以访问的位图文本图像 定位属性允许作者消除标记技巧（比如，不可见图像）以用于实现布局效果。 !important 规则的语义意味着具有特定表现要求的用户可以覆盖作者的样式表。 所有属性的 “继承” 值可提高层叠通用性，并允许调整统一风格。 增强媒体支持，包括媒体组和盲文，浮雕和 tty 等媒体类型。允许用户和作者为这些设备定制页面。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/3 一致性：要求和建议.html":{"url":"docs/CSS/CSS2.2/3 一致性：要求和建议.html","title":"3 一致性：要求和建议","keywords":"","body":"3 一致性：要求和建议 3.1 定义 本文档中的关键词 \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", 和 \"OPTIONAL\" 都按照 RFC2119（见RFC2119）中描述的来解释。但是，为了便于阅读，这些词在本说明书中并未以全部大写字母出现。 有时，本规范会为作者和用户代理建议好的实践。这些建议是非规范性的，与本规范的一致性取决于实现。这些建议包括 \"我们建议\"、\"本规范建议\" 或者类似的措辞。 功能被标记为已弃用（如 aural 关键字），或将在 CSS3 中弃用（如 system colors）事实上都不会影响一致性（aural 关键字是非规范的，所以 UA 不需要支持它；system colors 是规范的，所以 UA 必须支持它）。 除注意事项说明的部分外，本规范的所有章节包括附录都是规范的。 示例和注意事项都是非规范的。 示例的开头一般都有 \"比如\" 之类的词语（\"示例：\"、\"下例\"、\"比如\"等等） 注意事项以 \"注意\" 两字开头 图表仅提供说明，不是参考效果图，除非有明确说明 样式表（原：Style sheet） 一组指定文档呈现的语句 样式表可能有 3 个不同的来源：作者、用户和用户代理。这些来源之间的相互作用请查看层叠和继承 合法样式表（原：Valid style sheet） 样式表的合法性取决于样式表使用的 CSS 级别。所有有效的 CSS 1 样式表都是有效的 CSS 2.2 样式表，但 CSS 1 的一些变化意味着 一些 CSS 1 样式表在 CSS 2.2 中的语义略有不同。CSS 2 中的某些功能不是 CSS 2.2 的一部分，因此并非所有 CSS 2 样式表都是有效的 CSS 2.2 样式表。 合法的 CSS 2.2 样式表必须根据 CSS 2.2 的语法编写。此外，它必须仅包含本规范定义的 @规则、属性名称和属性值。任何不合法的@规则、属性名称和属性值无效。 源文档（原：Source document） 应用了一个或多个样式表规则的文档。这是以某种语言编码的，该语言以元素树表示文档。每个元素由一个标识元素类型的名称、多个可选的属性（原：attributes）、一个可能为空的内容组成。比如源文档可以是 XML 或 SGML 实例 文档语言（原：Document language） 源文档的编码语言（比如：HTML、XHTML 或 SVG）。CSS 用来描述文档语言的呈现（形式），而不会改变文档语言的底层语义。 元素（原：Element） （一个 SGML 的术语，见ISO8879）。文档语言的主要语法结构，大多数 CSS 样式表规则都通过元素名称（比如，HTML 中的 、、）来指定该元素应该怎样渲染 替换元素（原：Replaced element） 内容（原：content）超出 CSS 格式化模型范围的元素，如图片、内嵌文档、applet。比如，HTML 中的 元素的内容常常被其 src 属性指定的图片替换。替换元素通常具有固有尺寸：固有宽度、固有高度和固有比率。比如，位图图片有绝对单位指定的固有宽度、固有高度（显然可以确定固有比率）。另一方面，其它文档可能没有固有尺寸（比如，空白 HTML 文档） 用户代理如果觉得这些尺寸可能会泄漏敏感信息给第三方的话，可以认为一个替换元素没有任何固有尺寸。比如，如果一份 HTML 文档是根据用户的银行余额改变固有尺寸，则 UA 可能需要假装这个资源没有固有尺寸。 CSS 的渲染模型不会考虑替换元素的内容 固有尺寸（原：Intrinsic dimensions） 由元素自身定义的宽度和高度，不受环境影响。CSS 不定义如何拿到这些固有尺寸。CSS 2.2 中，只有替换元素有固有尺寸。对于没有可靠分辨率信息的光栅图像，假设每个图像源像素的单位为 1 像素单位。 属性（原：Attribute） 与元素关联的值，由名称和关联（文本）值组成。 内容（原：Content） 与文档中的元素关联的内容。有些元素没有内容，在这种情况下称它为空（元素）。元素的内容可以包括文本，并且可以包括多个子元素，在这种情况下，该元素被称为那些子元素的额父元素。 忽略（原：Ignore） 本规范中该术语有两个略微差异的含义。 第一个，CSS 解析器在样式表中发现未知或不合法语法时必须遵循某些规则。然后就是解析器必须忽略样式表的某些部分。哪些部分应该被忽略的规则在（声明与属性，处理解析错误的规则，不支持的值）小节中有详细描述。 第二个，即使语法合法，用户代理也可能（并且在某些情况下必须）忽略样式表中的某些属性或值。 呈现内容（原：Rendered content） 根据相关样式表应用于渲染后元素的内容。此规范未定义如何渲染替换元素的内容。呈现的内容可以是元素的替代文本（比如，XHTML 的 alt 属性），还可能包含通过样式表隐式或显示插入的项目（符号），比如黑点、数字等。 文档树（原：Document tree） 源文档中编码的元素树。此树中的每个元素只有一个父元素，除根元素外。 子（元素）（原：Child） 当且仅当 B 是 A 的父元素时，元素 A 才被称为是 元素 B 的子元素 后代（元素）（原：Descendant） 如果 A 是 B 的子元素，或者 A 是 B 的其它后代元素 C 的子元素，那么 A 被称为是 元素 B 的后代 祖先（元素）（原：Ancestor） 当且仅当 B 是 A 的后代时，元素 A 才是元素 B 的 祖先 兄弟（原：Sibling） 当且仅当 B 和 A 共享相同的父元素时，元素 A 才是 元素 B 的兄弟。如果元素 A 位于文档树中的 B 之前，则 A 是前导兄弟。如果 元素 B 位于文档树中的 A 之后，则 B 是后继兄弟 前导元素（原：Preceding element） 当且仅当 元素 A 是 B 的祖先，或者 B 是 A 的前导兄弟，A 是 B 的前导元素 后继元素（原：Following element） 当且仅当元素 B 是 A 的前导元素时，A 是 B 的后继元素 作者（原：Author） 作者是编写文档和相关样式表的人。编辑工具是一种用来生成样式表的用户代理 用户（原：User） 用户是与用户代理交互，以查看、听或其它方式使用文档与相关样式表的人。用户可能提供一份个人样式表作为个人偏好 用户代理（UA）（原：User agent (UA)） 用户代理可以是任何程序，该程序能够解释用文档语言编写的文档，并根据本规范的条款应用相关的样式表。 用户代理可以显示文档、大声朗读文档、打印出来、甚至转换为其它各种格式等 属性（原：Property） CSS 定义了一个有限的参数集，称为属性，用于指导文档的呈现。每个属性都有一个名称（比如：color、font 或 border）和一个值（比如：red、12px、dotted）。文档的各个部分，以及文档将通过特殊性、层叠和继承（见：分配属性值、级联、继承 章节）机制的方式把属性附加其中 一个 HTML 源文档示例： My home page My home page Welcome to my home page! Let me tell you about my favorite composers: Elvis Costello Johannes Brahms Georges Brassens 生成的树如下： 此图长描述 根据 HTML4 定义，HEAD 元素将在解析期间被推断出来并作为文档树的一部分，即便源文档里没有出现 \"head\" 标签。类似的，即便源文档中没有 和 标签，解析器也知道 P 和 LI 元素结束的位置。 XHTML（和其它基于 XM L的语言）文档行为不同：没有元素推断，并且所有元素都要有结束标签。 3.2 UA 一致性 本节只定义和 CSS 2.2 规范的一致性。将来还会有其它 CSS 级别，为了保持一致，可能需要用户代理实现不同的特性集。 一般情况，用户代理必须遵守以下几点一致性规范： 必须识别一个或多个 CSS 2.2 媒体类型 对于每个源文档，必须试图检索 适用于已识别媒体类型 的所有相关样式表。如果无法获取所有相关样式表（比如，因为网络错误），必须用那些可以检索的（样式表）显示文档 必须根据本规范解析样式表，特别是，必须识别所有@规则、块、声明和选择器（见 CSS 2.2语法 ）。如果用户代理遇到一个 适用于支持的媒体类型的属性，用户代理必须根据属性定义解析其值。这意味着，用户代理必须接受所有合法值并且必须忽略含有非法值的声明。用户代理必须忽略适用于不支持的媒体类型的规则 对于文档树中的每个元素，它必须根据属性定义和层叠与继承规则给每个属性赋值 如果源文档有可选的样式表集（比如，有 HTML4[HTML4]的 \"alternate\" 关键字），UA 必须允许用户选择 UA 应该适用哪份样式表集 UA 必须允许用户去掉作者（提供的）样式表的影响 不是所有用户代理都必须遵守每一点，然而： 读取样式表但不渲染任何内容的应用程序（比如，CSS 2.2 校验工具）必须遵守 1-3 点 编辑工具只需要输出合法的样式表 渲染具有相关联样式表的文档的用户代理必须遵守 1-6 点，并根据本规范中阐述的媒体特定要求呈现文档。必要时，用户代理可以用近似值 由于特定设备（比如，用户代理无法在单色监视器或页面上渲染颜色）的限制，用户代理无法实现本规范的一部分并不意味着不一致。 UA 必须允许用户指定含有用户样式表的文件。UA 面向的设备无任何写入或指定文件的方式时可以免除此要求。此外，UA 可以提供其它方式来指定用户偏好，比如通过 GUI CSS 2.2 没有定义哪些属性适用于表单控件和框架，以及怎样用 CSS 给它们设置样式。用户代理可能会给这些元素适用 CSS 属性，建议作者把此类支持当做实验性的，CSS 后续版本可能会进一步指定这些 3.3 错误条件 一般情况，本文档通过规范说明了错误处理行为。比如，见处理解析错误的规则 3.4 text/css 内容类型 独立文件中的 CSS 样式表会通过网络作为结合编码信息的字节序列来发送。传输的结构，术语叫消息实体，是在 RFC 2045 和 RFC 2616（见 [RFC2045] 和 [RFC2616] ）中定义的。一个内容类型为 \"text/css\" 的消息实体表示一个独立的 CSS 文档，\"text/css\" 内容类型是在 RFC 2318（[RFC2318]）中提出的 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/4 语法和基本数据类型.html":{"url":"docs/CSS/CSS2.2/4 语法和基本数据类型.html","title":"4 语法和基本数据类型","keywords":"","body":"4 语法和基本数据类型 4.1 语法 本节描述的语法（以及向前兼容的解析规则）适用于任何级别的 CSS（包括CSS 2.2）。CSS 将来的更新也将遵守此处的核心语法，尽管它们可能添加了额外的语法约束。 这些描述都是规范的内容，它们也会被 附录 G 中提出的规范语法规则所补充。 本规范中，类似于 “前面紧跟” 或者 “后面紧跟” 的表述意味着之间没有空格或者注释。 4.1.1 符号化 所有级别的 CSS — CSS 1、CSS 2和将来的任何级别 — 用的都是相同的核心语法。这样 UA 就可以解析（虽然不完全能理解）以 UA 发布时 尚不存在的 CSS 版本编写的样式表。设计者可以根据该特征来创建兼容旧版本用户代理的样式表，同时也能运用最新版本的CSS 在词法层面，CSS 样式表由一系列 标记（符号）组成。CSS 标记（符号）列表如下，这些定义了使用了 Lex 风格的正则表达式。八进制码参考了 ISO 10646（[ISO10646]），和词法分析一样，存在多个匹配时，把最长的匹配作为 标记（符号）。 Token Definition IDENT {ident} ATKEYWORD @{ident} STRING {string} BAD_STRING {badstring} BAD_URI {baduri} BAD_COMMENT {badcomment} HASH #{name} NUMBER {num} PERCENTAGE {num}% DIMENSION {num}{ident} URI `url({w}{string}{w}) url({w}([!#$%&*-[]-~] {nonascii} {escape})*{w})` UNICODE-RANGE u\\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})? CDO CDC --> : : ; ; { \\{ } \\} ( \\( ) \\) [ \\[ ] \\] S [ \\t\\r\\n\\f]+ COMMENT \\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/ FUNCTION {ident}\\( INCLUDES ~= DASHMATCH {ident}\\( DELIM {ident}\\( 以上定义中花括号({})中的宏定义（macros）如下： Macro Definition ident [-]?{nmstart}{nmchar}* name {nmchar}+ nmstart `[_a-z] {nonascii} {escape}` nonascii [^\\0-\\177] unicode `\\[0-9a-f]{1,6}(\\r\\n [ \\n\\r\\t\\f])?` escape `{unicode} \\\\n\\r\\f0-9a-f` nmchar `[_a-z0-9-] {nonascii} {escape}` num `[+-]?([0-9]+ [0-9]*.[0-9]+)(e[+-]?[0-9]+)?` string `{string1} {string2}` string1 `\\\"(\\n\\r\\f\\\\\" \\{nl} {escape})*\\\"` string2 `\\'(\\n\\r\\f\\\\' \\{nl} {escape})*\\'` badstring `{badstring1} {badstring2}` badstring1 `\\\"(\\n\\r\\f\\\\\" \\{nl} {escape})*\\?` badstring2 `\\'(\\n\\r\\f\\\\' \\{nl} {escape})*\\?` badcomment `{badcomment1} {badcomment2}` badcomment1 \\/\\*[^*]*\\*+([^/*][^*]*\\*+)* badcomment2 \\/\\*[^*]*(\\*+[^/*][^*]*)* baduri `{baduri1} {baduri2} {baduri3}` baduri1 `{U}{R}{L}({w}([!#$%&*-~] {nonascii} {escape})*{w}` baduri2 {U}{R}{L}\\({w}{string}{w} baduri3 {U}{R}{L}\\({w}{badstring} nl `\\n \\r\\n \\r \\f` w [ \\t\\r\\n\\f]* L `l \\0{0,4}(4c 6c)(\\r\\n [ \\t\\r\\n\\f])? \\l` R `r \\0{0,4}(52 72)(\\r\\n [ \\t\\r\\n\\f])? \\r` U `u \\0{0,4}(55 75)(\\r\\n [ \\t\\r\\n\\f])? \\u` 比如，最长匹配规则意味着 “red-->” 会被符号化为一个 IDENT “red--” 后面跟着一个DELIM “>”，而不是一个 IDENT 后面跟着一个 CDC。 下面是 CSS 的核心语法，本节接着描述怎样使用它。附录 G 描述了一个约束更多的更接近 CSS 2 的语法。能根据本语法解析，但不能用附录 G中的语法解析 的部分样式表都是按照处理解析错误的规则应该忽略的部分 stylesheet : [ CDO | CDC | S | statement ]*; statement : ruleset | at-rule; at-rule : ATKEYWORD S* any* [ block | ';' S* ]; block : '{' S* [ any | block | ATKEYWORD S* | ';' S* ]* '}' S*; ruleset : selector? '{' S* declaration? [ ';' S* declaration? ]* '}' S*; selector : any+; declaration : property S* ':' S* value; property : IDENT; value : [ any | block | ATKEYWORD S* ]+; any : [ IDENT | NUMBER | PERCENTAGE | DIMENSION | STRING | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES | DASHMATCH | ':' | FUNCTION S* [any|unused]* ')' | '(' S* [any|unused]* ')' | '[' S* [any|unused]* ']' ] S*; unused : block | ATKEYWORD S* | ';' S* | CDO S* | CDC S*; \"unused\" 产生式不用在 CSS 中，也不会被任何将来的扩展使用。这里提到它只是为了帮助完成错误处理。（见 4.2 “处理解析错误的规则”） 注意：标记（符号）不会出现在语法中（为了保持其可读性），但任意数量的标记（符号）都可以出现在其它标记（符号）外的任何地方（注意，然而，出现在 @charset 前或者里面的注释都会导致 @charset 无效）。 上面语法中的标记 S 代表空白字符，空白字符中只能出现 \"space\" (U+0020)、\"tab\" (U+0009)、\"line feed\" (U+000A)、\"carriage return\" (U+000D)和 \"form feed\" (U+000C)。其它的类空白字符，例如\"em-space\" (U+2003)和\"ideographic space\" (U+3000)不会被当作空白字符的一部分。 不能被符号化或解析的输入的含义在 CSS 2.2 中未定义。 4.1.2 关键字 关键字是标识符（原：identifiers）形式的，不能放在引号(\"...\"或者'...')中，因此，而 \"red\" 不是，（它是一个字符串）。 其它非法示例： width: \"auto\"; border: \"none\"; background: \"red\"; 4.1.2.1 特定供应商的扩展 CSS 中，标识符可能以 '-'（短线）或者 ''（下划线）开头，以 '-'或者 ''开头的关键字和属性名是为特定供应商扩展保留的。这样的特定供应商扩展应该满足下列任一格式： '-' + vendor identifier + '-' + meaningful name '_' + vendor identifier + '-' + meaningful name 比如，如果 XYZ 组织添加了一个用来描述东边边框颜色属性，他们可能叫它 -xyz-border-east-color 其它众所周知的示例： -moz-box-sizing -moz-border-radius -wap-accesskey 开头的短线或下划线用来保证不会被现在及将来的任意版本 CSS 用作属性或关键字。因此，通常CSS 实现可能无法识别这种属性，而会根据处理解析错误的规则忽略掉它。然而，因为开头短线或下划线也是语法的一部分，CSS 2.2 的实现者们都应该采用遵从 CSS 的解析器，无论是否支持任何特定供应商扩展。 作者应该避免特定供应商扩展。 4.1.2.2 信息性历史记录 本节内容是信息性的 编写本文档时，下列众所周知的前缀已经存在了： 4.1.3 字符和大小写 下列规则一直是有效的： ASCII 范围内的所有 CSS 语法都是大小写不敏感的（比如，[a-z]和[A-Z]是等效的），那些不由 CSS 控制的部分除外。比如，HTML 中属性 id 和 class 的值，字体名的值和本规范外的 URI 都是大小写敏感的。特别注意，HTML 中元素名是大小写不敏感的，但在 XML 中是大小写敏感的。 CSS 中，标识符（包括选择器中的元素名，类和 ID）都只含有字符 [a-zA-Z0-9] 和 ISO 10646字符中 U+00A0 及之后的，以及连字符(-)和下划线(_)，它们不能以一个数字，2个连字符，或者后面跟着数字的连字符开头。标识符可以含有转义字符和任意作为数字代码的ISO 10646字符。比如，标识符 \"B&W?\" 可以写成 \"B\\&W\\?\" 或者 \"B\\26 W\\3F\" 注意，Unicode和ISO 10646（见[UNICODE]和[ISO10646]）是等效的代码 在 CSS 2.2 中，反斜杠（\\）字符可以表示三种类型的转义之一。在 CSS 注释内部，反斜杠代表自己，如果样式表的末尾后面紧跟反斜杠，它也代表自己（即，DELIM token）。 首先，在字符串内部，将忽略换行符后跟的反斜杠（即，该字符串被视为不包含反斜杠或换行符）。在字符串之外，反斜杠后跟换行符代表自己（即，DELIM 后跟换行符）。 其次，它取消了 CSS 特殊字符的含义。任何字符（除十六进制数字，换行符，回车符或分页符以外）都可以使用反斜杠进行转义，以消除其特殊含义。比如，\"\\\"\" 是一个由双引号组成的字符串，样式表预处理器不能从样式表中删除这些反斜杠，因为这会改变样式表的含义。 然后，反斜杠转义能使作者引用文档的特殊字符。在这种情况下，反斜杠后跟最多六个十六进制数字（0..9A..F），它代表 ISO 10646（[ISO 10646]）中对应数字的 字符，这个数字一定是非零的（如果样式表确实包含 Unicode 码位值为零的字符会发生什么，CSS 2.2 没有定义）。如果在 [0-9a-fA-F] 范围内的字符跟随十六进制，则需要明确数字的结束位置，这里有两种办法： 用一个空格（或者其他空白字符）：\"\\26 B\" (\"&B\")，在这种情况下，用户代理应将 \"CR/LF\" (U+000D/U+000A) 视为单个空白字符。 提供刚好是 6 位十六进制数：\"\\000026B\" (\"&B\")。 实际上，这两种方法可以结合起来。在十六进制转义后，只会忽略一个空白字符。注意：这意味着转义序列后面的一个 “真正的” 空格必须双写。 如果该数字超出 Unicode 允许的范围（比如，\"\\110000\" 超出当前 Unicode 允许的最大 10FFFF），则 UA 可以用 “替换字符”(U+FFFD) 换掉这个转义。如果要显示该字符，则 UA 需要显示一个可见的符号，比如 “缺失字符” 的字形（见 15.2 小节第 5 点）。 注意：反斜杠转义符始终会被认为是标识符或字符串的一部分（即，\"\\7B\" 不是标点符号，即使 \"{\" 是这个；\"\\32\" 允许使用在类名开头，但 \"2\" 就不能）。\"te\\st\" 标识符和 \"test\" 一样。 4.1.4 语句 CSS 样式表适用于任何级别的 CSS，并且由一系列语句组成（参见上面的语法）。这里有两种声明语句：@规则 和 规则集。声明（语句）前后可能有空白字符。 4.1.5 @规则 @规则 以一个 @ 关键字开头，@ 字符后面紧跟着一个标识符（比如，@import，@page）。 一个规则包含下一个分号（；）或下一个分块的所有内容，以谁先出现为准。 CSS 2.2 用户代理必须忽略所有出现在块内部，或者在 @charset 或 @import 规则之外的任何无法忽略的语句之后出现的 @import 规则。 示例：CSS 2.2 解析器遇到此样式表： @import \"subs.css\"; h1 { color: blue } @import \"list.css\"; 根据 CSS 2.2，第二个 @import 不合法。 CSS 2.2 解析器就忽略了整个规则，样式表实际成了： @import \"subs.css\"; h1 { color: blue } 示例：第二个 @import 是不合法，因为它出现在 @media 块的内部。 @import \"subs.css\"; @media print { @import \"print-main.css\"; body { font-size: 10pt } } h1 {color: blue } 相反的，要实现只在媒体类型为 print 时引入样式表的效果，可以使用带媒体类型的@import 规则语法，比如： @import \"subs.css\"; @import \"print-main.css\" print; @media print { body { font-size: 10pt } } h1 {color: blue } 4.1.6 块 块以左大括号（{）开头，以右大括号（}）为结束。在它们之间可能有任何的 token，但括号（()），方括号（[]），大括号（{}）总是成对出现并且可以嵌套。单引号（'）和双引号（\"）也总是成对出现的，并且它们之间的字符被解析为字符串。参考上面的 Tokenization 定义。 块的示例：请注意，双引号之间的右括号与块的左括号不匹配，并且第二个单引号是转义字符，因此与第一个单引号不匹配 { causta: \"}\" + ({7} * '\\'') } 注意：CSS 2.2 中，上面规则不合法，但符合其定义。 4.1.7 规则集，声明块，选择器 规则集（也称为“规则”），由 选择器 后跟 声明块 组成。 声明块 以左大括号（{）开头，以匹配的右大括号（}）结束。在它们之间必须有零个或多个声明和规则的列表。声明必须以分号（;）结尾，除非它们是列表中的最后一个。 注意：CSS 级别 2 可能没有出现在规则集内的规则，但在未来的级别中可能出现。 选择器（见 选择器 部分）包含第一个左大括号（{）的所有内容（但不包含 左大括号）。选择器总是与声明块一起使用。当用户代理无法解析选择器时（即，不是合法的 CSS 2.2 选择器），它也必须忽略选择器和紧跟随的声明块（如果有的话）。 在选择器中，CSS 2.2 赋予了逗号（,）特殊的含义。但是，由于不知道 逗号 会在将来的 CSS 中是否有其它含义，因此，如果在选择器中有任何位置出现错误，则忽略整个语句，即使选择器的其余部分看起来合理。 示例：由于 “＆” 不是 CSS 2.2 选择器中的有效标记，因此 CSS 2.2 用户代理必须忽略整个第二行，而不是将 H3 的颜色设置为红色： h1, h2 {color: green } h3, h4 & h5 {color: red } h6 {color: black } 更复杂的示例：前两对花括号位于一个字符串内，但没标记选择器的结束，这是一个合法的 CSS 2.2 规则： p[example=\"public class foo\\ {\\ private int x;\\ \\ foo(int x) {\\ this.x = x;\\ }\\ \\ }\"] { color: red } 4.1.8 声明和属性 声明要么为 空，要么由一个后面跟冒号（:）和选择器 的属性名组成。（它们）之间可以有空白字符。 由于选择器的工作方式，同一选择器的多个声明可以组织成使用分号（;）分隔的组。 因此，以下规则： h1 { font-weight: bold } h1 { font-size: 12px } h1 { line-height: 14px } h1 { font-family: Helvetica } h1 { font-variant: normal } h1 { font-style: normal } 等价于 h1 { font-weight: bold; font-size: 12px; line-height: 14px; font-family: Helvetica; font-variant: normal; font-style: normal } 属性名是一个标识符。属性值可能会出现任何的 token。圆括号(( ))，方括号([ ])，大括号({ })，单引号(')和双引号(\")必须成对出现，并且非字符串形式的分号必须转义。圆括号，方括号和大括号可以嵌套。在引号里，字符解析为字符串。 （属性）值的语法为每个属性单独指定的，任何情况下，值都是由 标识符，字符串，数字，长度，百分比，URI，颜色等构建的。 用户代理必须忽略含有无效属性名称或无效值的声明。每个 CSS 属性对其接受的值都有自己的语法或语义限制。 示例：CSS 2.2 解析如下规则： h1 { color: red; font-style: 12pt } /* Invalid value: 12pt */ p { color: blue; font-vendor: any; /* Invalid prop.: font-vendor */ font-variant: small-caps } em em { font-style: normal } 第一行的第二个声明有无效值 '12pt'。第二行的第二个声明包含一个未定义的属性 font-vendor。CSS 2.2 解析器将忽略这些声明，样式表解析为： h1 { color: red; } p { color: blue; font-variant: small-caps } em em { font-style: normal } 4.1.9 注释 注释以字符 /* 开头，以字符 */ 结尾。它们可能出现在其他 token 之外的任何地方，其内容对渲染没有影响。注释可能不会嵌套。 CSS 也允许在语法定义的某些位置使用 SGML 注释分隔符（ 和 -->），但不会分隔 CSS 注释。它们让出现在 HTML 源文档（STYLE 元素）中的样式规则可以在用户代理中隐藏起来。更多信息请查看 HTML 4 规范（[HTML4]）。 4.2 处理解析错误的规则 在某些情况下，用户代理必须忽略不合法样式表的某一部分。本规范定义忽略是意味着用户代理要解析非法部分（为了找到起止位置），但还要表现得像这部分不存在一样。CSS 2.2 保留了 CSS 所有的属性未来的更新：值组合和不含以斜线和下划线开头的标识符的@关键字。实现必须忽略这样的组合（除了那些在将来 CSS 更新中介绍的）。 为了保证将来可以添在现有的属性上添加新属性和新值，用户代理遇到下列场景时需要遵循下列规则： 未知属性：用户代理必须忽略未知属性的声明。比如，样式表如下： h1 { color: red; rotation: 70minutes } // 解析为 h1 { color: red } 不合法值：用户代理必须忽略不合法值的声明。比如，样式表如下： img { float: left } /* correct CSS 2.2 */ img { float: left here } /* \"here\" is not a value of 'float' */ img { background: \"red\" } /* keywords cannot be quoted */ img { border-width: 3 } /* a unit must be specified for length values */ // 解析为 img { float: left } img { } img { } img { } 格式错误的声明：用户代理必须处理解析声明期间遇到的异常 token，一直读到声明结束，从()，[]，{}，\"\"和'' 对中寻找对应的规则，并正确处理转义。比如，格式错误的声明可能会缺少属性名称，冒号(:)或者属性值。 当 UA 从 声明或 @规则 的开始遇到异常 token，则该 token 被认为是格式错误声明的第一个 token。即，在这种情况下，应使用格式错误的声明而不是使用格式错误的语句来忽略那些 token。 p { color:green } p { @foo { bar: baz } color:green } /* unknown at-rule */ p { color:green; color } /* malformed declaration missing ':', value */ p { color:red; color; color:green } /* same with expected recovery */ p { color:green; color: } /* malformed declaration missing value */ p { color:red; color:; color:green } /* same with expected recovery */ p { color:green; color{;color:maroon} } /* unexpected tokens { } */ p { color:red; color{;color:maroon}; color:green } /* same with recovery */ 格式错误的语句：用户代理必须处理解析语句期间遇到的异常 token，一直读到语句结束，从()，[]，{}，\"\"和'' 对中寻找对应的规则，并正确处理转义。比如，格式错误的语句可能会异常的大括号或 @关键字。以下规则被忽略： p @here {color: red} /* ruleset with unexpected at-keyword \"@here\" */ @foo @bar; /* at-rule with unexpected at-keyword \"@bar\" */ \\}\\} \\{\\{ - \\}\\} /* ruleset with unexpected right brace */ ) ( {} ) p {color: red } /* ruleset with unexpected right parenthesis */ @规则有未知关键字：@规则有未知关键字。用户代理必须忽略不合法的关键字及其后面跟着的任何东西，直到遇到 不合法@关键字的块结束，或分号，或下一个块。 @three-dee { @background-lighting { azimuth: 30deg; elevation: 190deg; } h1 { color: red } } h1 { color: blue } @three-dee 不是 CSS 2.2 的一部分，因此忽略整个规则，解析为： h1 { color: blue } 样式表异常结束：用户代理必须让样式表成对闭合（比如，块，小括号，方括号，规则，字符串和注释），如： @media screen { p:before { content: 'Hello 解析为： @media screen { p:before { content: 'Hello'; } } 字符串异常结束：用户代理必须闭合行尾的字符串（即，在未转义的换行，回车，换页符之前），但要删除包含该字符串的声明或规则，如： p { color: green; font-family: 'Courier New Times color: red; color: green; } 因为第二条声明 （从 font-family 到 color: red;）是不合法的，则解析为： p { color: green; color: green; } 声明块的规则：见 4.1.7-规则集，声明块，选择器 小节。 4.3 值 4.3.1 整数和实数 某些值类型可能是整数值（用 表示）或实数值（用 表示）。实数和整数都只是用十进制的表示。 由一个或多个 \"0\" 到 \"9\" 的数字组成， 既可以是一个 ，也可以是 0 个或多个数字，后面跟着一个小数点和一个或多个数字。整数和实数之前都可以有 \"-\" 或者 \"+\" 表示符号。-0 等价于 0，不是负数， 注意：很多允许整数或者实数作为值的属性实际上限制了值的范围，通常是一个非负值 4.3.2 长度 长度是指距离测量。 长度值的格式是一个 后面紧跟着一个单位标识符（比如，px，em）。0 长度后面的单位标识符可选。 一些属性允许负长度值，但这可能使格式化模型复杂了，并且存在特定的限制。若不支持，则会转换为可支持的近似值。 如果负长度值不允许使用，则忽略该声明。 如果设置的长度不支持，则设置其近似支持值。 有两种类型的长度单位：相对和绝对。相对长度单位指定相对于另一个长度属性的长度。使用相对单位的样式表可以更容易地从一个输出环境扩展到另一个输出环境。 相对单位有： em：相关字体的 font-size ex：相关字体的 x-height h1 { margin: 0.5em } /* em */ h1 { margin: 1ex } /* ex */ em 单位等于 使用该规则的元素的 font-size 属性的计算值。有一种例外情况是，当 em 用于其它属性时，在这种情况下它使用父元素的 font-size。 ex 单位由元素的第一个可用字体定义。有一种例外情况是，ex 用于 font-size 属性的值时，在这种情况下它使用父元素的 ex。 之所以称为 x-height，是因为它通常等于小写 “x” 的高度。但是，即使对于不包含 “x” 的字体，也会定义 “ex”。 可以通过不同的方式获得 x-height。有些字体会包含 x-height 的精确指标。如果字体的精确指标无法获得，则 UA 可以从小写字形的高度来确定 x-height。一种可能的方式是看小写 \"o\" 的字形延伸到基线下方多远，并减去其边界的 top 值。如果实在没法确定 x-height，就使用 0.5em。 如下规则： h1 { line-height: 1.2em } 表示 h1 元素的行高比 h1 元素的字体大小大 20%，另一种情况： h1 { font-size: 1.2em } 表示 h1 元素的行高比 h1 元素继承的字体大小大 20% 当文档树的根（比如，HTML 中的 \"HTML\"）指定为 相对单位时，em 和 ex 相对该属性的初始值。 子元素不继承父元素指定的相对值，它们继承的是计算值。 如下规则，如果 h1 是 body 元素的子级，则 h1 元素的 text-indent 为 36 px，而不是 45 px： body { font-size: 12px; text-indent: 3em; /* i.e., 36px */ } h1 { font-size: 15px } 绝对长度单位相对于彼此固定。它们主要用于在已知当前环境的情况下。绝对单位由物理单位（in，cm，mm，pt，pc）和 px 单位组成： in：英寸，1in === 2.54cm cm：厘米 mm：毫米 pt：点（原：points），CSS 中的 1pt === 1in 的 1/72 pc：派卡（原：picas），1px == 12pt px：像素单位，1px === 0.75pt 对于 CSS 设备，这些尺寸要么参照（i）物理测量相关的物理单元，要么参照（ii）参考像素相关的像素单元。对于打印介质和类似的高分辨率设备，参照单位应该是标准物理单位之一（英寸，厘米等）。对于低分辨率设备和具有特殊观看距离的设备，建议将参照单位作为像素单元。对于这种设备，建议像素单元参考最接近参考像素的整数设备像素。 注意：如果参照单位是像素单位，则物理单位可能与其物理测量值不匹配。或者，如果参照单位是物理单位，则像素单位不能映射到整数个设备像素。 注意：这里像素单位和物理单位的定义在 CSS 之前的版本定义不同。特别地，在 CSS 之前的版本中，像素单位与物理单位没有 固定比例 的关系：物理单位总是与物理测量的相关，而像素单位会变得接近参考像素。（这种变化出现是因为太多现有内容依赖96 dpi 的假设，而破坏这个假设就会破坏这些内容）。 而 参考像素 是 像素密度为 96 dpi 的设备上一个像素与 人的臂长和屏幕之间 的距离长度 的视角。对于标准臂长为 28in 来说，视角约为 0.0213 角度。为了在臂长位置上阅读，所以 1px 约等于 0.26 mm（1/96 in）。 下图描述了视距对参考像素大小的影响：在 71 cm（28 in）的阅读距离下 一个参考像素是 0.26 mm，而在 3.5 m 的阅读距离下 一个参考像素是 1.3 mm。 此图长描述 下图描述了设备分辨率对像素单位的影响：1px * 1px 的区域被在低分辨率设备（如通用计算机屏幕）上的 1 个点覆盖，而同一个区域在高分辨率设备（如打印机）被 16 个点覆盖。 此图长描述 h1 { margin: 0.5in } /* inches */ h2 { line-height: 3cm } /* centimeters */ h3 { word-spacing: 4mm } /* millimeters */ h4 { font-size: 12pt } /* points */ h4 { font-size: 1pc } /* picas */ p { font-size: 12px } /* px */ 4.3.3 百分比 百分比值的格式（本规范适用 表示）是 后紧跟 %。 百分比值始终相对于另一个值，比如 长度。每个属性如果允许百分比的值的话，定义也会给出所参考的值。该值可以是同一个元素的另一个属性的值，祖先元素的属性或格式化上下文的值（比如，包含块的宽度）。当给 根元素 的属性上设置百分比值，并且 百分比参考某些属性的继承值时，结果值是 百分比乘该属性的初始值。 由于子元素（通常）继承其父元素的计算值，因此下列示例中，P 元素的子级将继承为 line-height: 12px 的值，而不是百分比值（120%）： p { font-size: 10px } p { line-height: 120% } /* 120% of 'font-size' */ 4.3.4 URL 和 URI 本规范中的 URI 值（统一资源标识符，见 RFC3986，包含 URL、URN 等等），用 表示。用于属性值使用 URI 的功能，用 url()，如： body { background: url(\"http://www.example.com/pinkish.png\") } 一个 URI 值的格式是 url(后跟可选空白字符，后跟可选的单|双引号，后跟 URI 本身，后跟可选的单|双引号)，后跟)。两个前后引号字符必须相同。 没有引号的示例： li { list-style: url(http://www.example.com/redball.png) disc } 出现在不带引号的 URI 中的某些字符（如括号，空格字符，单引号（'）和双引号（\"））必须使用反斜杠进行转义，以便生成的 URI 值为 URI 标记：'('，')'）。 根据 URI 的类型，也可能将将上述字符写为 (\" = %28, \")``= %29 等等，如 RFC3986。 注意：注释的 token 不会出现在其它 token 中：因此，url(/*x*/pic.png) 表示为 /*x*/pic.png，而不是 pic.png。 为了创建不依赖于资源绝对位置的模块化样式表，作者可以使用相对 URI。相对 URI（如 RFC3986 定义）会根据基础 URI 解析为完整的 URI。RFC 3986 的第 5 节定义了解析的算法过程。对于 CSS 样式表而言，基础 URI 是相对于该样式表（所在的 URL），而不是源文档。 比如，以下规则： body { background: url(\"yellow\") } URI 的样式表地址：http://www.example.org/style/basic.css，则源文档的背景图片的地址为 http://www.example.org/style/yellow。 用户代理在如何处理非合法法 URI 或者 URI 指向的不可用或不适用资源上（的处理方式）可能有差异。 4.3.5 计数器 计数器由大小写敏感的标识符表示（见 “计数器增量”和 “计数器重置” 属性）。为了使用计数器的值，使用符号 counter() 或 counter(，)，并使用可选的空格分隔标记。默认样式为 “十进制”。 要使用一系列相同名称的嵌套计数器，表示法是 counters(，)或 counters(，，) 可选的空白字符分隔这些 token。 关于用户代理如何确认计数器值的细节见 生成内容 章节。要想了解计数器值如何转换为字符串，参考 content 属性的定义。 在 CSS 2.2 中，只能从 content 属性引用计数器的值。注意，none 有可能是 ：counter(x, none) 生成一个空字符串。 示例：一个样式表相对每章 h1 的 段落 p 进行计数。段落使用罗马数字计数，后面跟一个句号和一个空格： p {counter-increment: par-num} h1 {counter-reset: par-num} p:before {content: counter(par-num, upper-roman) \". \"} 4.3.6 颜色 要么是一个关键字，要么就是合法的 RGB 数值。 颜色列表的关键字：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, 和 yellow。这 17 种颜色的值如下： 除了这些颜色关键字之外，在用户环境中，用户还可以指定对应的用于某些对象的颜色关键字。更多信息请查看 系统颜色 章节。 body {color: black; background: white } h1 { color: maroon } h2 { color: olive } RGB 颜色模型用于数字颜色规范。这些示例都指定了相同的颜色： em { color: #f00 } /* #rgb */ em { color: #ff0000 } /* #rrggbb */ em { color: rgb(255,0,0) } em { color: rgb(100%, 0%, 0%) } 十六进制表示法的 RGB 值格式为：# 后跟三个或六个 十六进制字符。三位 RGB 表示法（#rgb）通过复制数字而不是通过添加零来转换为六位数形式（#rrggbb）。比如，#fb0 转为 #ffbb00。这也可以确保白色用（#fff）来指定（#ffffff），且去掉了对显示器颜色深度的依赖。 函数表示法的 RGB 值格式为：rgb('后面由逗号分割的3个数值，数值可以为整数或百分比')。整数值 255 对应于 100%，即 rgb(255,255,255) = rgb(100%, 100%, 100%) = #fff。数值周围可使用 空白字符。 所有 RGB 颜色都在 sRGB 颜色空间中指定（参见[SRGB]）。用户代理在它们表示这些颜色的保真度方面可能有所不同，但是使用 sRGB 提供的颜色是明确可测量的，这与国际标准由关（参见[COLORIMETRY]）。 （与本规范保持一致的）用户代理可能会进行伽马校正，限制其颜色的显示。sRGB 指定在特定观察环境下动态灰度（原：display gamma）为 2.2。用户代理会调整 CSS 给出的颜色，这样结合输出设备的 “自然” 动态灰度，一个有效的 2.2 动态灰度就产生了。注意，只有在 CSS 中指定的颜色才会有影响，比如，图片就被认为携带了自己的颜色信息。 在设备色域以外的值理应被裁切或映射到已知色域中：red、green 和 blue 应该被转为设置支持的范围内。用户代理可能会进行 从一个（低）色域到高色域的颜色映射。对于典型的 RCT 显示器，其色域值和 RGB 相同，则下面四条规则是一样的： em { color: rgb(255,0,0) } /* integer range 0 - 255 */ em { color: rgb(300,0,0) } /* clipped to rgb(255,0,0) */ em { color: rgb(255,-10,0) } /* clipped to rgb(255,0,0) */ em { color: rgb(110%, 0%, 0%) } /* clipped to rgb(100%,0%,0%) */ 其它设备，如打印机，其色域与 sRGB 不同，（在设备色域内）某些 0...255 sRGB 之外的颜色也是可以表示的，而那些在 0...255 sRGB 之内的颜色可能因为不在 设备色域 内而被映射。 注意：色值的映射或裁切应该在 设备色域已知（可能比 0...255 大或小） 时进行。 4.3.7 字符串 字符串可以使用双引号或单引号编写。除非转义，双引号内不能出现双引号。单引号同理。 \"this is a 'string'\" \"this is a \\\"string\\\"\" 'this is a \"string\"' 'this is a \\'string\\'' 字符串不能直接包含换行符。（如果）要在字符串内使用换行符，则需要使用 ISO-10646 (U+000A)中换行符的转义符，比如 \\A 或 \\00000a。这个字符在 CSS 中表示 “换行”。示例见 content 属性。 出于美观或其它原因，字符串有可能分成几行，这种情况下，换行符自身要使用反斜杠（\\）转义。下面两个选择器等价： a[title=\"a not s\\ o very long title\"] {/*...*/} a[title=\"a not so very long title\"] {/*...*/} 4.3.8 不支持的值 如果 UA 不支持某个特殊值，则在样式表解析的时应忽略该值，好像该值不合法一样。比如： h3 { display: inline; display: run-in; } 支持 display: run-in 的 UA 会接受第一个 display 声明，然后使用第二个 display 覆盖。不支持的话，将处理第一个 display 声明且忽略掉第二个声明。 4.4 CSS 样式表的展示 CSS 样式表是通用字符集中的一系列字符（参见[ISO10646]）。为了传输和存储，这些字符必须根据 US-ASCII 中可用字符集的字符编码（比如，UTF-8，ISO 8859-x，SHIFT JIS等）编码。有关字符集和字符编码的详细介绍，请参阅 HTML 4 规范（[HTML4]，第5章）。另请参阅 XML 1.1 规范（[XML11]，第 2.2 和 4.3.3 节以及附录 E）。 当样式表嵌入在另一个文档中时，比如在 HTML 的 STYLE 元素或 “style” 属性中，样式表共享整个文档的字符编码。 样式表位于单独的文件中时，用户代理在确定样式表的字符编码时（从最高优先级到最低优先级）必须遵循以下优先级： “Content-Type” 字段中的 HTTP “charset” 参数（或其他协议中的类似参数） BOM 和/或 @charset（见下方） 或来自其它链接的元数据（如果有的话） 要引入样式表或文档的字符集（如果有的话） 假设为 UTF-8 @charset 规则应该放在样式表的开头，需用引号指定字符编码，必须写成字面量形式（即，@charset（小写、不含反斜杠转义）+ 编码名 + ;）如： @charset \"ISO-8859-1\"; 编码名必须是 IANA 注册库 中的字符集名。完整列表见 [CHARSETS]。含有 MIME 的字符集名应优先使用。 用户代理至少必须支持 UTF-8 编码。 如果上面的规则 1 （HTTP “charset” 参数 或类似参数）生成的字符编码且是 UTF-8、UTF-16、UTF-32 三者之一，则文件开头的 BOM （如果有）会覆盖字符编码，如下： 如果规则 1 生成的字符编码是 UTF-16BE、UTF-16LE、UTF-32BE、UTF-32LE 之一，则如今以 BOM 开头会报错。CSS UA 则需要忽略指定的编码切使用上表来恢复。 用户代理必须忽略任何不在样式表开头的 @charset 规则。 当用户代理使用 BOM 和/或@charset 规则检测字符编码时，它们应遵循以下规则： 除了这里指定的规则外，所有 @charset 规则都会忽略。 编码通过样式表开头的字节流来检测。下表给出了初始字节序列的一组可能写法（以十六进制编写）。与样式表开头匹配的第一行根据 BOM 和/或 @charset 规则提供编码检测结果。如果没有匹配的行，则无法根据 BOM 和/或 @charset 规则检测编码。符号(...)* 指的是匹配部分可能会重复匹配几次。标记为 “XX” 的字节是用于确定编码名称的，通过按给定的顺序将它们视为 ASCII 字符序列。标记为 “YY” 的字节类似，但需要根据提示转码为 ASCII。如果用户代理不支持与条目相关的任何编码，则可以忽略表中的条目： 如果编码是根据上面的被标记为 “与指定值相同” 的某一项检测出来的，但根据选定的@charset 解码字符流开头部分无法被解析成一个合适的@charset规则的话，用户代理应该忽略该样式表。 @charset 规则只在样式表的编码中生效 字节顺序标记只在支持字节顺序标记的编码中被忽略，并且 编码名不能含有换行符 用户代理必须忽略未知编码的样式表。 4.4.1 涉及当前字符集之外的字符 样式表可能不得不引入那些在当前字符编码中无法显示的字符。这些字符必须被写成转义的 ISO 10646 字符。这些转义的目的都是把数字字符引入 HTML 或者 XML 文档中（参见[HTML4]，第5章和25章）。 字符转义机制应该只被用在一些必须以这种方式显示的字符上。如果样式表中的大部分内容都需要转义，作者应该用一种更合适的编码来对它进行编码（比如，如果样式表含有大量的希腊文字，作者应该用 \"ISO-8859-7\" 或者 \"UTF-8\"） 使用不同的字符编码的中间处理器可以把这些转义的序列翻译成相应编码的字节序列。另一方面，中间处理器不能改变转义序列取消ASCII字符的特殊含义。 （与本规范）一致的用户代理必须能够正确地把 ISO-10646 的所有字符映射成它们可识别的字符编码（或者它们必须表现得至少看起来是正确的）。 比如，一份以 ISO-8859-1(Latin-1) 传输的样式表不能直接包含希腊字母：\"κουρος\"（希腊语：\"kouros\"(青年)）必须写作 \"\\3BA\\3BF\\3C5\\3C1\\3BF\\3C2\"。 注意：在 HTML 4 中，数字字符引用被解释为 \"style\" 属性的值，而不是 STYLE 元素的内容，我们建议作者对 \"style\" 属性和 STYLE 元素都使用 CSS 字符转义机制而不是数字字符引用，比如，我们推荐： ... 而不是： ... Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/5 选择器.html":{"url":"docs/CSS/CSS2.2/5 选择器.html","title":"5 选择器","keywords":"","body":"5 选择器 5.1 模式匹配 在 CSS 中，模式匹配规则决定哪些样式规则适用于文档树中的元素。这些模式就叫选择器，范围可以从简单的元素名称到丰富的上下文模式。如果模式中所有的所有条件对于某个元素都为真，则选择器匹配该元素。 在选择器中，文档语言元素名称的大小写取决于文档语言。比如，在 HTML 中元素名称不区分大小写，但在 XML 中，它们区分大小写。 下表总结了 CSS2.2 选择器语法： 模式 含义 描述 * 匹配所有元素 Universal selector（通用选择器） E 匹配所有 E 元素（比如元素的类型为 E） Type selectors（类型选择器） E F 匹配所有作为 E 元素后代的 F 元素 Descendant selectors（后代选择器） E > F 匹配所有作为 E 元素直接子元素的 F 元素 Child selectors（子选择器） E:first-child 当 E 元素是其父元素的第一个子元素时匹配 E 元素 The :first-child pseudo-class（:first-child 伪类） E:link E:visited 如果 E 元素尚未访问（:link）或已访问（:visited），则匹配 E 元素 The link pseudo-classes（link 伪类） E:active E:hover E:focus 在用户某些操作的时候匹配 E The dynamic pseudo-classes（动态伪类） E:lang(c) 如果语言为 c （文档语言会指定怎样确定语言），则匹配 E 元素 The :lang() pseudo-class（:lang() 伪类） E + F 匹配所有前面紧跟着 E 元素的 F 元素 Adjacent selectors（相邻选择器） E[foo] 匹配所有具有 foo 属性集（无论值是什么）的 E 元素 Attribute selectors（属性选择器） E[foo=\"warning\"] 匹配所有 foo 属性完全等于 warning 的 E 元素 Attribute selectors（属性选择器） E[foo~=\"warning\"] 匹配所有 foo 属性值是空格分隔值列表，其中一个值是 warning Attribute selectors（属性选择器） 匹配所有 lang 属性值以 en 开头（从左到右）用连字符分隔值 的 E 元素 Attribute selectors（属性选择器） DIV.warning 语言指定的（与 DIV[class~=\"warning”] 一样） Class selectors（类选择器） E#myid 匹配所有 ID 为 myid 的 E 元素 ID selectors（ID 选择器） 5.2 选择器语法 简单选择器可以是 类型选择器 或 后面紧跟 0 个或多个以任意顺序排列的属性选择器，ID 选择器，伪类 的通用选择器。简单选择器需要其所有部分都匹配成功才算匹配成功。 选择器是一串用连接符分隔的一个或多个简单选择器。连接符有：空白字符、>、+。空白字符可以出现在连接符和它前后的简单选择器之间。 与选择器匹配的文档树元素称为选择器的对象。由单个简单选择器组成的选择器匹配所有可以满足其需求的元素。给一串（选择器）前面加上一个简单选择器和连接符就会增加额外的匹配约束，所以一个选择器的对象总是最后一个简单选择器匹配的元素的子集。 一个伪元素可以被添加在一串选择器中最后一个选择器后面，此时样式信息会被适用在每个匹配上的元素的子内容上。 5.2.1 分组 当多个选择器共享相同的声明时，它们分组成以逗号分隔的列表里。 本例中，我们把三条有相同声明的规则压缩成一条，因此 h1 { font-family: sans-serif } h2 { font-family: sans-serif } h3 { font-family: sans-serif } // 等同于 h1, h2, h3 { font-family: sans-serif } CSS 也提供了其它简写机制，包括（一次）声明多条（规则）和 属性简写。 5.3 通配选择器 通配选择器写作 *，匹配所有元素类型的名称。匹配文档树中的任意单个元素。 如果通配选择器不是简单选择器的唯一组成部分（即选择器不为 ），* 可以省略，比如： *[lang=fr] 等价于 [lang=fr] *.warning 等价于 .warning *#myid 等价于 #myid 5.4 类型选择器 类型选择器匹配 文档语言 元素类型名称。一个类型选择器会匹配文档树中所有该元素类型的实例。 下列规则匹配文档树中的所有 H1 元素： h1 { font-family: sans-serif } 5.5 后代选择器 有时，作者可能希望选择器匹配一个 在文档树中 作为另一个元素后代的 元素（比如，匹配 元素包含的那些 元素）。后代选择器用模式表达这种关系。后代选择器由 两个或多个 由 空白字符（white space）分隔的选择器组成。形如 A B 的后代选择器匹配一个元素 B，只要它是祖先元素 A 的任意后代。 比如，考虑下面的规则： h1 { color: red } em { color: red } 尽管这些规则的目的是通过改变颜色来给文本添加强调，但效果会在该情况下消失： This headline is very important 对于这种情况，我们通过 用一条设置文本颜色为蓝色的规则来补充之前的规则 解决，无论 出现在 内的哪个位置： h1 { color: red } em { color: red } h1 em { color: blue } 第三条规则将会匹配下列片段中的 ： This headline is very important 下列选择器： div * p 匹配作为 元素的 孙子或后来的 后代的 元素。注意，* 的前后的空白字符不是通配选择器的一部分，空白字符是一种连接符，表明 div 元素必须是某个元素的祖先，并且该元素是 的祖先。 下列规则中结合了 后代选择器和属性选择器 的选择器，匹配 具有 [href] 属性集且本身位于 元素内部的 元素的内部 的任意元素。 div p *[href] 5.6 子级选择器 子级选择器匹配一个 作为某个元素的 子元素时。子选择器由 两个或多个 被 > 分隔的选择器组成。 下面的规则设置了所有作为 子元素的 元素的样式： body > P { line-height: 1.3 } 下面的示例结合了后代选择器和子选择器： div ol>li p 它匹配一个作为 元素的后代的 元素，这个 元素必须是 元素的子元素， 元素必须是 元素的后代。注意：连接符 > 前后可选的空白字符被删掉了。 关于选择元素的第一个子元素的更多信息查看下面的 :fist-child 伪类小节。 5.7 相邻兄弟选择器 相邻兄弟选择器语法如下：E1 + E2，其中 E2 是选择器的对象。如果 E1 和 E2 在文档树中拥有相同的父级且 E1 紧挨着 E2 前面，忽略非元素节点（如文本节点和注释），则选择器成功匹配 E2。 因此，下列规则指出，当一个 元素紧跟着一个 元素后面时，它不应该缩减： math + p { text-indent: 0 } 下一个示例减少了紧挨着的 和 之间的垂直边距： h1 + h2 { margin-top: -5mm } 下面的规则与之前的示例相似，只是它添加了一个类选择器，因此，特殊的格式化只在 上有 class=\"opener\" 时才出现： h1.opener + h2 { margin-top: -5mm } 5.8 属性选择器 CSS 2.2 允许作者指定规则来匹配在源文档中定义了某些属性的元素。 5.8.1 匹配属性和属性值 属性选择器可以通过四种方式匹配： [att]：当元素设置了 att 属性时匹配，无论该属性的值是什么 [att=val]：当元素的 att 属性是 val 时匹配 [att~=val]：表示元素具有 att 属性，该属性值是以 空白字符 分隔的单词列表，其中一个正好是 val。如果 val 包含 空白字符，则它永远不会表示任何内容（因为单词由空格分隔）。如果 val 是空字符串，也不会代表任何东西。 [att|=val]：表示元素具有 att 属性，该属性值要么正好是 val 要么以 val 开头，后跟 -（U+002D）。这主要是为了允许 语言子码 按照 BCP47 或后续版本进行匹配（比如， 元素下的 hreflang 属性）。关于 lang（或 xml:lang）语言子码匹配，请看 :lang 伪类 小节 属性值必须是 标识符 或 字符串，选择器中属性名和值的大小写敏感取决于文档语言。 比如，下列属性选择器匹配所有指定 title 属性的元素，无论值是什么： h1[title] { color: blue; } 下例中，选择器匹配所有 class 属性值恰好是 example 的 元素： span[class=example] { color: blue; } 多个属性选择器可以用来引用同一个元素的几个属性，或者甚至把同一个属性引用多次 下面的选择器匹配所有 hello 属性值恰好是 Cleveland、goodbye 属性值恰好是 Columbus 的 元素： span[hello=\"Cleveland\"][goodbye=\"Columbus\"] { color: blue; } 下列选择器描述了 = 和 ~= 的区别，第一个选择器将匹配，例如，rel 属性值为 copyright copyleft copyeditor（的元素）。第二个只匹配 href 属性值为 http://www.w3.org/（的元素）。 a[rel~=\"copyright\"] a[href=\"http://www.w3.org/\"] 下面的规则隐藏了所有 lang 属性值为 fr（即语言是法语）的元素： *[lang=fr] { display : none } 下面的规则将匹配 lang 属性值以 en 开头，包括 en，en-US 和 en-cockney： *[lang|=\"en\"] { color : red } 同样，以下听觉样式表规则允许每个角色以 不同的声音 大声朗读 文本： DIALOGUE[character=romeo] { voice-family: \"Laurence Olivier\", charles, male } DIALOGUE[character=juliet] { voice-family: \"Vivien Leigh\", victoria, female } 5.8.2 DTD 中的默认属性值 省略，原因：HTML5 不需要引用 DTD 5.8.3 类选择器 编写 HTML 时，在表示 class 属性时，作者可以使用黑点 . 替代 ～=。因此，对于 HTML 来说，div.value 等同于 div[class~=value]。属性值必须紧跟黑点 . 后面。UA 可以在 XML 文档中把黑点 . 符号用于选择器，如果 UA 有特定命名空间信息允许它决定各个命名空间下哪个属性是 class 属性。这种特定命名空间信息的示例在针对特殊命名空间的规范（比如，SVG 1.1 [SVG11]描述了 SVG class 属性以及 UA 应该怎样解释它，类似的，MathML 3.0 [MATH30]描述了 MathML class 属性）中有。 比如，我们将样式信息分配给所有 具有 class~=\"pastoral\" 的元素： *.pastoral { color: green } /* all elements with class~=pastoral */ 或者直接 .pastoral { color: green } /* all elements with class~=pastoral */ 下面只给具有 class~=\"pastoral\" 的 元素设置样式： h1.pastoral { color: green } /* h1 elements with class~=pastoral */ 根据给出的这些规则，下面第一个 实例将不会有绿色文本，而第二个会： Not green Very green 为了匹配 class 的值的一个子集，每个值前面必须有一个 .。 比如，下列规则匹配所有 class 属性被赋值为一列空格分隔的含有 \"pastoral\" 和 \"marine\" 的值： p.marine.pastoral { color: green } 该规则匹配 class=\"pastoral blue aqua marine\" 但不匹配 class=\"pastoral blue\"。 注意：CSS 赋予了 class 属性非常多的能力，作者可以在与表现无关的元素（比如，HTML 中的 和 ）上设计他们自己的 \"文档语言\"，并通过 class 属性来设置样式信息。作者应该避免这种实践，因为文档语言的结构化元素通常具有可识别和可接受的含义，而作者定义的 class 没有。 注意：如果一个元素拥有多个 class 属性，在搜索 class 之前，它们的值必须以 空白字符连接起来。目前，工作组对这种情况能被达成的方式并不明确，所以本规范中，这种行为显然是非规范的。 5.9 ID 选择器 文档语言可能包含声明为 ID 类型的属性。ID 类型属性的特殊之处是没有两个这样的属性可以有相同的值。无论在什么文档语言中，一个 ID 属性都可以被用作其元素的唯一标识。在 HTML 中，ID 属性都被命名为 \"id\"，XML 可能以不用方式命名 ID 属性，但会受到同样的限制。 文档语言的 ID 属性允许做者给文档树中的一个元素实例设置一个标识符。CSS ID 选择器根据它的标识符匹配一个元素实例。一个 CSS ID 选择器包含\"#\"和后面紧跟着的ID值，该值必须是一个标识符。 下列 ID 选择器匹配 ID 属性值为 \"chapter1\" 的 H1 元素： Match P *#z98y { letter-spacing: 0.3em } Wide text 下一个示例中，样式规则将只匹配一个 ID 值为 \"z98y\" 的 H1 元素，该规则不会匹配本例中的 P 元素： Match H1 only h1#z98y { letter-spacing: 0.5em } Wide text ID 选择器比属性选择器的特殊性更高。比如，在 HTML 中，根据层叠，选择器 #p123 比[id=p123] 更具体。 如果一个元素有多个 ID 属性，鉴于 ID 选择器的目的，它们必须全部都被当作这个元素的 ID。这种情况可以通过使用 id[XMLID]、DOM3 Core [DOM-LEVEL-3-CORE]、XML DTDs [XML10]和特定命名空间信息的混合来实现。 5.10 伪元素和伪类 在 CSS 2.2 中，样式通常根据元素在 文档树 中的位置添加的。这种简单模型在大多数情况下就足够了，但在有些常见的排版场景下可能无法根据文档树中的结构（添加样式）。比如，HTML4 中，没有元素对应 一个段落的第一行，因此 CSS 中没有简单的选择器可以引用它。 为了允许基于文档树之外的信息进行格式化，CSS 引入了 伪元素 和 伪类 的概念。 伪元素建立了 对超出文档语言指定的文档树 的抽象。比如，文档语言不提供访问元素内容的 第一个字母或第一行的机制。CSS 伪元素允许样式表设计者引用通过其它方式无法访问的信息。伪元素也给样式表提供了一种方式，给源文档中不存在的内容分配样式（比如，:before 和 :after 伪元素提供了对生成的内容的访问） 伪类根据元素的特征分类，而不是名字、属性、内容。原则上这些特征无法通过文档树推断得出。伪类可能是动态的，用于与文档交互时，元素可能获取或丢失一个伪类。:first-child 是一个特例，可以根据文档树推断出来，:lang() 某些情况下也能根据文档树推断出来。 伪元素和伪类都不会出现在文档源或文档树中。 伪类允许出现在任何选择器的后面，而一个伪元素只能紧跟在选择器的最后一个简单选择器的后面。 伪元素和伪类名称不区分大小写。 有些伪类是互斥的，而其它伪类可以同时应用于同一个元素。如果规则冲突了，则结果由正常的层叠顺序决定。 5.11 伪类 5.11.1 :first-child 伪类 :first-child 伪类匹配一个元素，该元素是某个元素的第一个子元素。 下例中，选择器匹配所有 作为 元素的第一个子元素 的 元素。该规则禁止 中的第一个段落缩进： div > p:first-child { text-indent: 0 } 该选择器匹配下面片段中 里的 ： The last P before the note. The first P inside the note. 但不会匹配下面片段中 里的 ： The last P before the note. Note The first P inside the note. 下面的规则匹配所有 作为第一子元素 的 元素的后代中的 元素： p:first-child em { font-weight : bold } 注意：因为 匿名盒子 不是文档树中的一部分，在计算 第一个子（元素）不会对它们进行计数。 比如， 在 abc default 中是 的第一个子元素 下列两个选择器等价： * > a:first-child /* A is first child of any element */ a:first-child /* Same */ 5.11.2 link 伪类：:link 和 :visited 用户代理通常把 未访问过的链接 和 已访问过的链接 区分显示。CSS 提供了伪类 :link 和 :visited 来区分它们： :link 伪类用于 未访问过的链接 :visited 伪类用于 已访问过的链接 UA 可能在某个时刻将 已访问过的链接 回到 未访问过的链接。 这两种状态是互斥的。 文档语言决定了哪些元素是超链接源锚点。比如，在 HTML4 中，link 伪类只适用于具有 href 属性的 元素。因此，在 CSS 2.2 中，下面声明具有相似的效果： a:link { color: red } :link { color: red } 如果下面的链接： external link 已经被访问过了，这条规则 a.external:visited { color: blue } 将让它变蓝。 注意：作者可能写样式表的时候滥用 :link 或 :visited 伪类，来确定用户已经曾访问过的的站点而不经过用户同意。 因此，UA 可以将所有链接都当作 未访问过的链接，或者在分别渲染 已访问过的链接和未访问过的链接时，采取其它措施来保护用户的隐私。 5.11.3 动态伪类：:hover、:active、:focus 交互式的用户代理有时会改变渲染（效果）以响应用户动作。CSS 针对常见情况提供了三个伪类： :hover 伪类应用于当用于指定了一个元素（用一些指针设备），但没有激活它时。比如当光标（鼠标指针）悬停在元素生成的盒子上时，可视化用户代理适用该伪类。不支持交互式媒体的用户代理不必支持该元素。某些支持交互式媒体的用户代理可能也不支持该伪类（比如，笔交互设备）。 :active 伪类应用于当一个元素被用户激活时。比如，当用户按下鼠标并释放时。 :focus 伪类应用于当一个元素拥有焦点（接受键盘事件或文本输入的其它形式）时。 一个元素可以同时匹配多个伪类。 CSS 没有定义哪些元素可以处于上述状态，以及这些状态怎样进入和离开。脚本可以改变 元素是否对用户事件做出响应，并且不同的设备和 UA 指向和激活 元素的方式可能也不相同。 CSS 2.2 没有定义 :active 或者 :hover 的父元素是不是也处于这种状态。 用户代理不必因为伪类转变而重排当前显示的文档。比如，一个样式表可以指定 :active 链接的 font-size 比非激活状态的链接的字体大，但因此这可能会导致字母在读者选中链接时改变位置，UA 可以忽略相应的样式规则。 a:link { color: red } /* unvisited links */ a:visited { color: blue } /* visited links */ a:hover { color: yellow } /* user hovers */ a:active { color: lime } /* active links */ 注意：a:hover 的规则必须放在 a:link 和 visited 的后面，否则 层叠规则 将会隐藏 a:hover 规则中的 color 属性。类似的，a:active 必须放在 a:hover 的后面，用户激活并悬停在 元素上时，将会使用 :active 激活状态下的颜色。 结合了 动态伪类 的例子： a:focus { background: yellow } a:focus:hover { background: white } 最后一个选择器匹配处于伪类 :focus和 伪类 :hover（状态）的 元素。 有关焦点轮廓的显示的信息，请查看 动态轮廓焦点 章节部分。 注意：在 CSS1 中，:active 伪类与 :link 和 :visited 是互斥的，而现在情况不一样了。一个元素可以同时处于 :visited和 :active（或者 :link和 :active），由常规层叠规则决定适用哪个样式声明。 注意：在 CSS1 中，:active 伪类只会应用于链接。 5.11.4 语言伪类：:lang 如果文档语言指定了怎样定义一个元素的人类语言（种类），就有可能用 CSS 写出选择器根据元素的语言来匹配一个元素。比如，HTML[HTML4] 中，语言是由 lang 属性， 元素以及可能的来自协议的信息（比如，HTTP 头）结合起来决定的。XML 用一个叫xml:lang 的属性和可能的其它文档特定语言的方法来确定语言。 伪类 :lang(C) 匹配语言为 C 的元素。是否存在匹配，仅由 标识符 C 是否等于元素的语言值 或者 连字符分隔元素的语言值的子字符串 来确定。同样的，就像 |= 操作符一样。对 于 ASCII 范围内的字符，C 与元素语言值的匹配过程是大小写不敏感的。标识符 C 不一定是一个合法的语言名称。 C 必须不能为空。 下列规则给一个加拿大法语或德语 HTML 文档设置引号： html:lang(fr-ca) { quotes: '« ' ' »' } html:lang(de) { quotes: '»' '«' '\\2039' '\\203A' } :lang(fr) > Q { quotes: '« ' ' »' } :lang(de) > Q { quotes: '»' '«' '\\2039' '\\203A' } 第二对规则实际上给 Q 元素根据其父级的语言设置了 quotes 属性。能这样做是因为引号是根据引号周围元素的语言选择的，而不是引号本身：比如这段英语文本中的法语 “à l'improviste” 用的是英文引号。 注意：[lang|=xx]和 :lang(xx) 的区别。在下面 HTML 示例中，只有 匹配[lang|=fr]（因为它有 lang 属性），但 和 都匹配 :lang(fr)（因为都是法语） Je suis Français. 5.12 伪元素 在 CSS 中，伪元素的行为就和真实元素的一样。但 下面描述的 以及 其它的（指的是 before-after-content 章节）例外。 注意：下面的小节没有严格定义 对 :first-line 和 :first-letter 的渲染，将来的CSS 版本可能会精确地定义它们。 5.12.1 :first-line 伪元素 :first-line 伪元素对 段落内容的第一个格式化行 适用特殊样式。比如： p:first-line { text-transform: uppercase } 上面的规则表示 \"把每个段落的第一个行的字母变成大写\"。然而，选择器 p:first-line 是不会匹配任何的真实的 HTML 元素。它匹配一个伪元素，该元素符合用户代理的话，将会在每个段落的开头插入。 注意：第一行的长度取决于许多因素，包括 页面宽度、字体大小 等。因此，一个段落原始可能是这样子： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. 其中可能有几行变成这样： THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. :first-line 可能会被用户代理重写成 含有虚拟标签序列的形式，这种虚拟标签序列有利于展示属性的继承方式： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. 如果伪元素把一个真实元素给拆开了，想要的效果是由 虚拟标签序列 闭合再重新打开该元素。因此如果我们用一个 元素标记之前的段落： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. 在给 :first-line 插入 虚拟标签序列 时，用户代理会为 模拟开始和结束标签： This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph. :first-line 伪元素只适用于 块容器元素。 元素的 \"第一个格式化行\" 可能 出现在 相同流（原因：the same flow）中的一个块级后代（即一个没有被定位且不浮动的块级后代）里面。比如，This line...中 的第一行是 的第一行（假设 和 都是块级的）。 表格单元格或行内块元素的第一行不能作为祖先元素的第一个格式化行。因此，在 HelloGoodbye etcetera 中， 的第一个格式化行不是 \"Hello\"， 注意：First... 中 的第一行不包含任何字母（假设是HTML4中 默认样式表）。单词 \"First\" 不在第一个格式行内。 UA 应该表现的就像 :first-line 伪元素的虚拟开始标签嵌套 在 最内层的闭合块级元素 中（因为 CSS1 和 CSS2 都没有说明这种情况，作者不应该依赖这种行为），比如： First paragraph Second paragraph 对应的虚拟标签序列为： First paragraph Second paragraph :first-line 伪元素 与 行内级元素 类似，但有一些限制。下列属性适用于 :first-line 伪元素：font、color、background、word-spacing、letter-spacing、text-decoration、text-transform、line-height。UA 还可能应用其它属性。 5.12.2 :first-letter 伪元素 :first-letter 伪元素必须选择一个块的第一行的第一个字母，如果这一行中在它前面没有跟着任何其它内容（比如，图片或者 inline table）的话。:first-letter 伪元素可以用于 \"首字母大写（initial caps）\" 和 \"首字母下沉（drop caps）\" 之类的常见排版效果。此类首字母与 float 属性为 none 的 行内级元素类似，否则就与 浮动元素 类似。 适用于 :first-letter 伪元素的属性有：font、text-decoration、text-transform、letter-spacing、word-spacing（在适当的时候），line-height、float、vertical-align（仅当 float 为 none 时），margin、padding、border、color、background。 UA 还可能会应用其它规则。为了让UA 正确渲染 首字母下沉 或者 首字母大写 排版，UA 可以根据字母的形状选择行高、宽度和高度，这与 常规元素（normal elements）不同。预期 CSS3 会有适用于首字母的具体属性。 下例展示了首字母大写渲染，注意，:first-letter 伪元素继承的 line-height 是 1.1，但例子中 UA 特别计算了首字母的高度，因此它不会导致前两行之间有任何不必要的空隙。还要注意，首字母的虚拟开始标签在 里面，因此首字母的字重是正常的，而不是和 一样的粗体： p { line-height: 1.1 } p:first-letter { font-size: 3em; font-weight: normal } span { font-weight: bold } ... Het hemelsche gerecht heeft zich ten lange lesten Erbarremt over my en mijn benaeuwde vesten En arme burgery, en op mijn volcx gebed En dagelix geschrey de bange stad ontzet. 下列 CSS2.2（规则）将会让首字母下沉大约两行： Drop cap initial letter p { font-size: 12pt; line-height: 1.2 } p:first-letter { font-size: 200%; font-style: italic; font-weight: bold; float: left } span { text-transform: uppercase } The first few words of an article in The Economist. 可能被格式化成这样： 虚拟标签序列为： T he first few words of an article in the Economist. 注意：:first-letter 伪元素（虚拟）标签挨着内容（content）（即首字母），而 :first-line 伪元素的开始标签紧跟在 块元素开始标签之后。 为了达到传统首字母下沉的格式化效果，用户代理可以用近似字体大小，比如为了对齐基线。另外，在格式化时，还可能会把字形轮廓考虑在内 （:first-letter 伪元素）应该包括紧跟在首字母前后的标点符号（即用 Unicode 定义的 \"open\" (Ps)、\"close\" (Pe)、\"initial\" (Pi)、\"final\" (Pf)和 \"other\" (Po)标点类字符），比如： 如果首字母是数字的话，:first-letter 伪元素也同样适用，例如，\"67 million dollars is a lot of money.\" 中的 \"6\"。 :first-letter 伪元素适用于块容器元素。 :first-letter 伪元素可以用于所有含有文本的元素或者相同流（the same flow）中有含有文本的后代（元素）。UA 应该表现得像 :first-letter 伪元素的虚拟开始标签恰好在该元素的第一块文本内容之前，即使第一块文本内容位于后代元素中。 比如，此 HTML 片段： The first text. 对应的的虚构标记序列： The first text. 表格单元格或行内块元素的首字母不能作为祖先元素的首字母。因此，在 HelloGoodbye etcetera 中， 的首字母不是字母 \"H\"，实际上，该 没有首字母。 首字母必须出现在 第一个格式化行 中，比如，片段 First... 中，第一行没有任何字母，那么 :first-letter 伪元素 不会匹配任何东西（假设是 HTML4 中 的默认样式）。这种情况下，它也不会匹配 \"First\" 的 \"F\"。 如果一个元素是列表项（display: list-item），则 :first-letter 伪元素将应用于标记后的 主盒子（principal box）中的第一个字母。UA 可能忽略具有 list-style-position: inside 的列表项上的 :first-letter 的规则。如果一个元素 具有 :before 或者 :after 内容，:first-letter 伪元素应用于包含该内容的元素的第一个字母。 比如，声明 p:before {content: \"Note: \"} 规则后，选择器 p:first-letter 会匹配 \"Note\" 的 \"N\"。 有些语言可能有 关于怎样对待特定字母组合 的具体规则，在荷兰，比如，如果字母组合 \"ij\" 出现在单词开头，这两个字母应该都属于 :first-letter 伪元素。 如果将要作为第一个字母的字母不在同一个元素中，例如 'T...中的 \"'T\"，UA 可能会从中取一个元素创建 :first-letter 伪元素，或者都给创建伪元素，或者干脆不创建伪元素。 类似的，如果块的首字母不在行的开头（比如，由于双向重排序（bidirectional reordering）），那么 UA 不需要创建该伪元素。 下例描述了伪元素互相重叠的情况。 元素的首字母将是绿色的，字体大小为 '24pt'。第一个格式化行的其余部分将是 'blue'，而段落的其它部分将是 'red'： p { color: red; font-size: 12pt } p:first-letter { color: green; font-size: 200% } p:first-line { color: blue } Some text that ends up on two lines 假设一个 行结束符 将出现在单词 \"ends\" 之前，该片段的虚拟标签序列可能是： S ome text that ends up on two lines 注意：:first-letter 伪元素在 :first-line 伪元素里面。设置在 :first-line 上的属性被 :first-letter 继承了，而且如果设置的是 :first-letter 的相同属性，则会被重写。 5.12.3 :before 和 :after 伪元素 :before 和 :after 伪元素可以用来在 一个元素的内容 之前或之后插入 生成的内容，在 生成文本 章节中有解释。 h1:before {content: counter(chapno, upper-roman) \". \"} 当 :first-letter 和 :first-line 伪元素被应用在一个具有使用 :before 和 :after 生成内容 的元素，它们适用于元素 包括生成的内容在内 的首字母或首行： p.special:before {content: \"Special! \"} p.special:first-letter {color: #ffd800} 将会把 \"Special!\" 的 \"S\" 渲染成金色。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/6 分配属性值、层叠、继承.html":{"url":"docs/CSS/CSS2.2/6 分配属性值、层叠、继承.html","title":"6 分配属性值、层叠、继承","keywords":"","body":"6 分配属性值、层叠、继承 6.1 指定值、计算值、实际值（Specified, computed, and actual values） 一旦用户代理解析了文档并构建了文档树，它就必须为树中的每个元素分配一个值，该值应用于每个属性，这些属性都适用于目标媒体类型。 属性的最终值（final value）是四步计算的结果： 开始，该值通过规范指定，此时为 指定值（specified value） 然后，解析用于继承的值，此时为 计算值（computed value） 然后，转换成绝对值（如果有必要），此时为 应用值（used value） 最后，根据本地的环境进行变换得到的值，此时为 实际值（actual value） 6.1.1 指定值（Specified values） 用户代理必须首先根据一下机制为每个属性属性分配指定的值（按优先顺序排列）： 如果层叠产生了值，就使用它 否则，如果属性是继承的并且该元素不是文档树的根元素，使用其父元素的计算值 否则使用属性的初始值。每个属性的初始值在属性的定义中指出了。 6.1.2 计算值（Computed values） 指定值通过层叠被计算成了计算值，比如 URL 被解析成绝对的，em 和 ex 单位被计算为像素或者绝对长度。计算一个值永远不需要用户代理呈现文档。 UA 无法处理为绝对 URI 的话，该 URI 的计算值就是指定值。 一个属性的计算值由属性定义中 \"Computed Value\" 行决定。当指定值为 inherit 时，计算值的定义见继承小节。 即使属性不适用（当前元素），其计算值也存在，定义在 \"Applies To\" 行。然而，有些属性可能根据属性是否适用于该元素来定义元素属性的计算值。 6.1.3 应用值（Used values） 在不格式化文档的情况下尽可能地处理计算值。但是，有些值只能在文档布局完成时确定。比如，如果一个元素的宽度是其包含块的特定百分比，在包含块的宽度确定之前无法确定这个宽度。应用值是获取计算值，并将其剩余的依赖（值）都处理成绝对值后的结果。 6.1.4 实际值（Actual values） 原则上，应用值应该用于渲染，但用户代理可能无法在给定的环境中使用该值。比如，用户代理可能只能使用整数像素宽度渲染边框，因此不得不对宽度的计算值做近似处理，或者用户代理被迫只能用黑白色调而不是全彩色。实际值是经过近似处理后的应用值。 6.2 继承（Inheritance） 如上所述，某些值由文档树中元素的子元素继承。 每个属性都定义了它是否可继承的。 假设 H1 元素里有个强调元素(EM)： The headline is important! 如果没有给 EM 元素赋值颜色，强调的 \"is\" 将从其父元素继承颜色，所以如果 H1 是蓝色的，EM 元素同样也将是蓝色的。 发生继承时，元素继承计算值。来自父元素的计算值同时作为指定值和其子元素的计算值。 比如，给出如下样式表： body { font-size: 10pt } h1 { font-size: 130% } 和文档片段： A large heading H1 元素的 font-size 属性将获得计算值 \"13pt\"（130% 乘以父元素的值 10pt）。因为 font-size 的计算值是继承的，EM 元素也将获得计算值 \"13pt\"。如果用户代理没有可用的 13pt 字体，H1 和 EM 的 font-size 的实际值可能是，比如，\"12pt\"。 注意：继承遵循文档树并且不会被匿名盒子截断 6.2.1 inherit 值 每个属性也可能有一个 inherit 层叠值，这意味着，对于一个给定的元素，属性采用与其父元素属性相同的指定值。inherit 值可以用来实现值的继承，并且它也可以用在那些一般不是继承的属性上。 如果 inherit 值设置在根元素上，该属性会被赋值为其初始值。 下例中，color 和 background 属性被设置在 BODY 元素上。对于其它所有元素，color 值都将被继承并且背景将是透明的。如果这些规则是用户样式表的一部分，整个文档都将是白色背景上的黑色文本。 body { color: black !important; background: white !important; } * { color: inherit !important; background: transparent !important; } 6.3 @import 规则 @import 规则允许用户从其他样式表导入样式规则。在 CSS 2.2 中，任何 @import 规则必须在其他规则之前（除了 @charset，如果有的话）。关于用户代理什么情况下必须忽略 @import 规则，见 解析 章节。@import 关键字后面必须跟着想要引入的样式表的 URI。字符串也可以接受，也可以是 url(...) 形式。 下面这几行在意义上是等价的，都描述了 @import 语法（一个有 url(...)，另一个是字符串）： @import \"mystyle.css\"; @import url(\"mystyle.css\"); 为了让用户代理能够避免为不支持的媒体类型检索资源，作者可以指定带媒体依赖的 @import 规则。这种条件引入在 URI 后面指定了逗号分隔的媒体类型。 下列规则描述了 @import 规则怎样带媒体依赖的： @import url(\"fineprint.css\") print; @import url(\"bluish.css\") projection, tv; 在没有任何媒体类型的情况下，引入是无条件的，与把媒体指定为 all 效果一样。仅当目标媒体与媒体列表匹配时，导入才会生效。 如果媒体列表中有一项是目标媒体或者 all时，目标媒体匹配媒体列表。 注意：媒体查询[MEDIAQ]扩展了媒体列表的语法和匹配的定义。 引入相同样式表或者在多处链接同一文档时，用户代理必须处理（或者表现得像那样）每一个链接，就像链接都指向一个单独的样式表一样。 6.4 层叠（The cascade） 样式表可能有三个不同的来源：作者（author）、用户（user）和用户代理（user agent）。 作者：作者根据文档语言的约定编写源文档的样式表。比如，样式表可以包含在文档中或外部链接。 用户：用户可能会为特定的文档指定样式信息。用户可以指定包含样式表的文件，或者用户代理可以提供生成 用户样式表 的界面（或者表现得像这样做了一样）。 用户代理：用户代理必须应用 默认样式表（或者表现像用了一样）。用户代理的默认样式表应该以满足文档语言所期望的一般展现方式去 呈现 文档语言的元素（比如，对于可视浏览器， 应该以斜体呈现）。有关 HTML 文档的默认样式表的建议，请参阅 HTML 的示例样式表。 注意：用户可以修改系统设置（比如，系统颜色）以此来影响默认样式表。但是某些用户代理实现使得无法更改默认样式表的值。 三个来源的样式表将在一定范围内进行重叠，并且根据 层叠 进行交互。 CSS 层叠为每个样式规则都分配了权重。当适用多个规则时，权重最大的规则优先。 默认情况下，作者样式表的规则比用户样式表的规则更重要。然而，对于 !important 规则，优先顺序是相反的。所有用户和作者的规则都比 UA 默认样式表中的规则更重要。 6.4.1 层叠顺序（Cascading order） 要找出 元素/属性 组合的值，用户代理必须使用以下顺序排序： 查找出 适用于目标媒体类型的相关元素和属性 所有声明。如果 关联的选择器 与 相关元素匹配，且 目标媒体 与 包含声明的所有 @media 规则上的媒体列表 以及 样式表上路径的所有链接 匹配，则声明适用。 根据 重要性(normal or important) 和 来源（作者、用户、用户代理）进行排序。在层叠中的优先级顺序，按升序排列： 用户代理声明（原：user agent declarations） 用户常规声明（原：user normal declarations） 作者常规声明（原：author normal declarations） 作者重要声明（原：author important declarations） 用户重要声明（原：user important declarations） 通过 选择器的特殊性 对具有 相同重要性和来源 进行排序的规则： 更具体（注：可理解为特殊）的规则将覆盖更一般的选择器 伪元素 和 伪类 分别都计算为 常规元素 和 类。 最后，按指定的顺序进行排序： 如果两个声明具有相同的权重、来源和特殊性，则后者指定的获胜。 引入样式表（指：@import）中的声明被认为是在样式表本身中的任何声明之前。 除了给个别声明的 !important 外，比起用户样式表，这种策略给了作者样式表更多的权重。用户代理必须给予用户 去除特定作者样式表影响 的能力。 6.4.2 !important 规则 CSS 尝试在 作者 和 用户 之间建立权力平衡。默认情况下，作者样式表中的规则会覆盖用户样式表中的规则（见 层叠规则3）。 但是，为了平衡，!important 声明（分隔符 ! 和关键字 important遵循声明）优先于 常规声明。作者和用户样式表都可能包含 !important 声明，而 用户 !important 规则会覆盖作者 !important 规则。此 CSS 特性能通过满足用户的特殊要求（大字体，颜色组合等）来控制演示，从而提高了文档的访问性。 声明 一个简写属性（如 background） 为 !important 等同于将所有子属性声明为 !important。 下例中用户样式表的第一条规则含有一个 !important 声明，重写了作者样式表中的相关声明。第二条声明也将生效，因为被标记为 !important 了。然而，用户样式表中的第三条规则不是 !important，因此被作者样式表（恰好在简写属性上设置了）中的第二条规则重写了。而且，第三条作者规则将被第二条作者规则重写，因为第二条规则是 !important。这说明 !important 声明在作者样式表中也有效 /* From the user's style sheet */ p { text-indent: 1em ! important } p { font-style: italic ! important } p { font-size: 18pt } /* From the author's style sheet */ p { text-indent: 1.5em !important } p { font: normal 12pt sans-serif !important } p { font-size: 24pt } 6.4.3 计算选择器的特殊性 选择器的特殊性由以下规则计算： 如果声明是来自 style 属性（原：attribute）而不是一个带选择器的规则，则为 1，否则就为 0（=a）（在 HTML 中，元素 style 属性（原：attribute）的值是样式表规则，这些规则没有选择器，所以 a=1,b=0,c=0,d=0） 计算选择器中 ID 属性（原：attribute）的数量（=b）。 计算选择器中 其它属性和伪类 的数量（=c）。 计算选择器中 元素名称和伪元素 的数量 (=d)。 特殊性只根据选择器的形式来决定。特殊地，一个 \"[id=p33]\" 形式的选择器被计算为一个属性选择器(a=0,b=0,c=1,d=0)，即使 id 属性在源文档的 DTD 中被定义为 \"ID\"。 4 个数字连起来 a-b-c-d（在一个基数很大的数字系统中）表示其特殊性。 一些示例： * {} /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */ li {} /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */ li:first-line {} /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */ ul li {} /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */ ul ol+li {} /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */ h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */ ul ol li.red {} /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */ li.red.level {} /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */ #x34y {} /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */ style=\"\" /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */ #x97z { color: red } 上面的示例中，P 元素的颜色将是绿色，\"style\" 属性中的声明将重写 STYLE 元素中的，因为层叠规则3，它的特殊性更高。 6.4.4 非 CSS 表现型提示的样式优先级 UA 可能选择尊重 HTML 源文档中的表现型属性。如果是这样，这些属性将会被转换为 CSS 规则的特殊性为 0，并被当作是在 作者样式表 的开头插入它们。因此，它们可能会被后续的样式表规则所重写。在过渡阶段，这种策略让表现型属性更容易与样式表共存。 对于 HTML，不应将以下列表中的任何属性视为表现型属性：abbr, accept-charset, accept, accesskey, action, alt, archive, axis, charset, checked, cite, class, classid, code, codebase, codetype, colspan, coords, data, datetime, declare, defer, dir, disabled, enctype, for, headers, href, hreflang, http-equiv, id, ismap, label, lang, language, longdesc, maxlength, media, method, multiple, name, nohref, object, onblur, onchange, onclick, ondblclick, onfocus, onkeydown, onkeypress, onkeyup, onload, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup, onreset, onselect, onsubmit, onunload, onunload, profile, prompt, readonly, rel, rev, rowspan, scheme, scope, selected, shape, span, src, standby, start, style, summary, title, type (except on LI, OL and UL elements), usemap, value, valuetype, version。 对于其它语言，所有基于文档语言的样式必须被转换为相应的CSS，并且要么在用户代理的层叠中，要么与 HTML 表现型提示一起被当作特殊性为 0 的作者级别规则放在作者样式表开头 下列用户样式表将会重写所有文档中 b 元素的字重，以及 XML 文档中具有 color 属性的 font 元素的颜色。它将不会影响 HTML 文档中任何具有 color 属性的 font 元素的颜色(译注：实际上，在 HTML 里这个样式对有 color 属性的 font元素 也是有效的。但一致性章节有声明 “示例和注意事项是非规范的”，这里是示例)： b { font-weight: normal; } font[color] { color: orange; } 然而，下面的（样式表）将会重写所有文档中 font 元素的颜色： font[color] { color: orange ! important; } Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/7 媒体类型.html":{"url":"docs/CSS/CSS2.2/7 媒体类型.html","title":"7 媒体类型","keywords":"","body":"7 媒体类型 7.1 媒体类型简介 样式表最重要的特征之一是它们指定文档在不同媒体的呈现方式：屏幕上，纸上，语音合成设备，盲文设备等。 某些 CSS 属性仅针对特定媒体设计（比如，page-break-before 属性仅适用于 paged media）。但是有时候，不同媒体类型的样式表可能共享一个属性，但需要该属性的不同值。比如，font-size 对于 屏幕媒体 和 打印媒体 就都有用。两种媒体类型的不同要求共同属性使用不同的值，文档在计算机屏幕上通常要比在纸上的字体更大。因此有必要使用样式表或样式表的一部分适用于某些媒体类型。 7.2 指定与媒体相关的样式表 目前有两种方式可以为样式表指定媒体依赖关系： 使用 @media 或 @import 的规则从样式表中指定目标媒介 @import url(\"fancyfonts.css\") screen; @media print { /* style sheet for print goes here */ } 在文档语言中指定目标媒体 Link to a target medium The body... @import 规则在 层叠 章节中定义。 7.2.1 @media 规则 @media 规则指定 一组语句（由花括号分隔）的目标媒体类型（以逗号分隔）。非法语句会被忽略调。@media 允许在同一样式表中指定各种媒体的样式表规则： @media print { body { font-size: 10pt } } @media screen { body { font-size: 13px } } @media screen, print { body { line-height: 1.2 } } @media 规则之外的样式规则 适用于 样式表适用的所有媒体类型。 7.3 认可的媒体类型（Recognized media types） 给 CSS 媒体类型选择的名称反映了 相关属性有意义的 目标设备。在以下 CSS 媒体类型列表中，媒体类型的名称是规范的，但描述信息是信息性的。同样，每个属性的描述中的 media 字段是提供信息的。 all：适用于所有设备 braille：适用于盲人触觉反馈设备 embossed：适用于分页盲文打印机 handheld：适用于手持设备（通常为小屏幕，有限带宽） print：适用于 分页材料 和在打印预览模式下在屏幕上查看的文档。有关 分页媒体 的部分 请参考 分页媒体 章节 projection：适用于投影展示，比如投影机。有关 分页媒体 的部分 请参考 分页媒体 章节 screen：适用于彩色电脑屏幕 speech：适用于语音合成器。注意：CSS 2.2 有一个媒体类型叫 aural tty：适用于固定间距字符网格的媒体类型（比如电视、终端、具有有限显示功能的便携式设备） tv：适用于电视类设备（低分辨率，彩色，有限滚动屏幕，可用声音） 媒体类型不区分大小写。 用户代理在渲染文档时支持一种媒体类型时，此时媒体类型之间是互斥的。但是用户代理可以在不同的画布上使用不同的媒体类型。比如，文档可以（同时）在一个画布上以 screen 模式显示，在另一个画布上以 print 模式显示。 注意：多模式媒体类型仍然只是一种媒体类型。比如，tv 媒体类型是一种多模式媒体类型，在单个画布上可以在 视觉上 和 听觉上 呈现单个。 带有未知媒体类型的 @media 和 @import 规则（仍然是有效标识符）被视为不存在未知媒体类型。如果 @medida 和 @import 规则包含格式错误的媒体类型（不是标识符），则该语句失效。 注意：CSS 在未来更新中可能会引入新的媒体类型。 7.3.1 媒体集（Media groups） 本节内容不具有规范性。 每个 CSS 属性定义 都会指定 属性适用的媒体类型。由于属性通常适用于多种媒体类型，因此每个属性定义的 适用媒体（Applies to media） 会列出媒体集而不是单个媒体类型。每个属性都适用于其定义的 媒体集 里的所有媒体类型。 CSS 2.2 定义了以下媒体集： 连续或分页（原：continuous or paged） 视觉、听觉、语音、触觉（原：visual, audio, speech, or tactile） 网格（用于网格字符设备）或位图（原：grid (for character grid devices), or bitmap） 互动式（用于允许用户交互的设备）或静态（用于不允许用户交互的设备）（原：interactive (for devices that allow user interaction), or static (for those that do not)） 全部（包含所有媒体类型）（原：all (includes all media types)） 下面表格表示了媒体集和媒体类型之间的关系： Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/8 盒子模型.html":{"url":"docs/CSS/CSS2.2/8 盒子模型.html","title":"8 盒子模型","keywords":"","body":"8 盒子模型 CSS 盒子模型描述了一个 为文档树中的元素生成的 矩形盒子，该盒子并根据视觉格式化模型布局。 8.1 盒子尺寸 每个盒子具有 内容区域（原：content area）（比如文本、图像等）和周围可选的 填充区域（原：padding area）、边框区域（原：border area）、外边距区域（原：margin area）），每块区域的大小由下面定义的属性指定。下图显示了这些区域怎么关联的和以及用于引用 外边距、边框、填充的术语： 外边距、边框、填充可以分为 top、right、bottom、left 区段（比如 LM 代表左外边距、RP 代表右填充、TB 代表上边框）。 四块区域（content、padding、border、margin）中的每一块的界限称为 边缘（原：edge），因此每个盒子有四条边缘： 内容边缘或内边缘（原：content edge or inner edge） 内容边缘环绕着由 盒子的宽度（原：width）和 高度（原：height）给出的矩形，这通常取决于元素呈现的内容。四个 内容边缘 定义了盒子的 内容盒子（原：content box）。 填充边缘（原：padding edge） 填充边缘 围绕着 盒子的填充（区域）。如果填充的宽度为 0，则填充边缘与内容边缘相同。四个 填充边缘 定义了盒子的 填充盒子（原：padding box）。 边框边缘（原：border edge） 边框边缘 围绕着 盒子的边框（区域）。如果边框的宽度为 0，则边框边缘与填充边缘相同。四个边框边缘 定义了盒子的 边框盒子（原：border box）。 外边距边缘或外边缘（原：margin edge or outer edge） 外边距边缘 围绕着 盒子的外边距（区域）。如果外边距的宽度为 0，则外边距边缘与边框边缘相同。四个外边距边缘 定义了盒子的 外边距盒子（原：margin box）。 每个（围绕着的）边缘都可以被细分为 top、right、bottom、left。 一个盒子的 内容区域 的尺寸 - 内容宽度（原：content width）和内容高度（原：content height）- 取决于几个因素： 生成该盒子的元素是否设置了 width 或 height 属性 该盒子是否包含 文本 或 其它盒子 盒子是否是 table ... 盒子的宽度和高度在 视觉格式化模型细节 中有详细讲解。 盒子的 内容区域、填充区域、边框区域 的背景样式 由生成（该盒子）的元素的 background 属性指定。外边距区域 的背景总是 透明的（transparent）。 8.2 案例：外边距、填充、边框 本例描述了 外边距、填充、边框 之间的相互影响。案例分析： Examples of margins, padding, and borders ul { background: yellow; margin: 12px 12px 12px 12px; padding: 3px 3px 3px 3px; /* No borders set */ } li { color: white; /* text color is white */ background: blue; /* Content, padding will be blue */ margin: 12px 12px 12px 12px; padding: 12px 0px 12px 12px; /* Note 0px padding right */ list-style: none /* no glyphs before a list item */ /* No borders set */ } li.withborder { border-style: dashed; border-width: medium; /* sets border width on all sides */ border-color: lime; } First element of list Second element of list is a bit longer to illustrate wrapping. 结果是产生了一个拥有 2 个 孩子的 元素的文档树（文档树中还有其它关系）。 第一幅图中描述本例产生的结果。第二幅图描述了 元素的 外边距、填充、边框 和它的 元素的这些属性之间的关系（图像不是按比例给出）。 注意： 每个 盒子的 content width 是自顶向下计算的，每个 盒子的包含块由 元素建立的。 每个 盒子的 外边距盒子 的高度取决于其 content height、以及上下的填充、上下的边框、上下的外边距。 盒子之间的 垂直外边距 合并了。 每个 盒子的右填充区域被设置为 0 宽度（padding 属性）。第二幅图中效果就很明显。 每个 盒子的 margin 是透明的—外边距总是透明的。因此， 盒子的填充和内容区域的背景色（yellow）透出来了。 第二个 盒子指定了虚线边框（border-style 属性）。 8.3 外边距属性：margin-top、margin-right、margin-bottom、margin-left、margin 外边距属性指定了一个盒子的 外边距区域 的宽度。margin 这个简写属性可以设置 外边距的四边，而其它外边距属性只能设置一边。 这些属性适用于所有元素，但对 行内非替换元素 的垂直外边距不会产生任何效果。 本节定义的属性参考 的值类型，可以采用以下值之一： ：指定一个固定的宽度。 ：百分比是根据 生成的盒子的包含块的 宽度 计算的。请注意，对于 margin-top 和 margin-bottom 也是如此。如果包含块的宽度取决于该元素，则产生的布局在 CSS 2.2 中没有定义。 auto：请查阅 10.3 允许外边距为负值，但可能存在具体实现限制。 关键信息摘要： 属性名称：margin-top, margin-bottom 值： | inherit 初始值：0 适用元素：all elements except elements with table display types other than table-caption, table and inline-table（除 display 类型为 table 系列中除了 table-caption、table和 inline-table 以外的所有元素（译注：也就是说，table 系列 display 值中，margin-* 只适用于 table-caption、table、inline-table，其余的都不适用，但 margin-* 对 非table 系列都适用）） 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：指定的百分比或者绝对长度 注意：这些属性对 行内非替换元素 没有影响。 关键信息摘要： 属性名称：margin-right, margin-left 值： | inherit 初始值：0 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：指定的百分比或者绝对长度 关键信息摘要： 属性名称：margin 值：{1,4} | inherit 初始值：see individual properties 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：见单独的各个属性 margin 属性是 margin-top、margin-right、margin-bottom、margin-left 的简写属性。 只有一个值时，则应用于四个属性 只有两个值时，则 margin-top 和 margin-bottom 为第一个值，margin-left 和 margin-right 为第二个值 只有三个值时，则 margin-top 为第一个值，margin-left 和 margin-right 为第二个值，margin-bottom 为第三个值 只有四个值时，则 margin-top 为第一个值，margin-right 为第二个值，margin-bottom 为第三个值，margin-left 为第四个值 8.3.1 合并外边距（Collapsing margins） 在 CSS 中，两个或多个盒子（可能是兄弟也可能不是兄弟）的相邻的 margin 会被结合成一个 margin。外边距按这种方式结合叫做合并（collapse），产生的结合的外边距叫做折叠外边距（collapsed margin 译注：这里译作折叠表示结果，与合并的动作区分开）。 相邻的垂直外边距会合并，除了： 根元素盒子的 margin 不合并。 如果一个带有间隙（clearance 译注：是指 clear 属性导致元素位置移动形成的间隙）的元素的上外边距与下外边距相邻，它的外边距会和紧挨着的兄弟（元素）的相邻外边距合并，但合并后不会再和父级块的下外边距合并。 水平外边距永不合并。 两个 margin 是相邻的，当且仅当： 都属于 流内（in-flow）的块级盒子，处于同一个 块格式化上下文（BFC）。 没有行盒子、没有间隙（clearance）、没有填充、没有边框把它们隔开（注意：为此目的，忽略某些零高度盒子）。 都属于垂直相邻盒子边缘，即形成下列某一对： 盒子的上外边距与其第一个流内 孩子 的外边距 盒子的下外边距与下一个流内 紧挨着的兄弟 的上外边距 最后一个流内 孩子的下外边距与其 height 计算值为 auto 的父元素的下外边距 盒子的上外边距和下外边距，要求该盒子没有建立新的块格式化上下文，并且 min-height 计算值为 0，height计算值为 0 或 auto，还没有流内孩子。 折叠外边距也能与另一个外边距相邻，只要其外边距的任意一部分与那个外边距相邻就算。 注意： 相邻外边距也可以由不具有 兄弟或祖先 元素的关系 的元素生成。 注意，上面的规则说明： 浮动盒子与其它任意盒子的 margin 不会合并（甚至一个浮动盒子与它的 流内子元素 之间也不会）。 建立了新的 块格式化上下文 的元素（比如，浮动盒子与 overflow 不为 visible 的元素）的 margin 不会与它们的 流内子元素 合并。 绝对定位盒子的 margin 不会合并（甚至与它们的 流内子元素 也不会）。 inline-block 盒子的 margin 不会合并（甚至与它们的 流内子元素 也不会）。 流内 块级元素的 margin-bottom 总会与 它的 下一个流内块级兄弟的 margin-top 合并。除非该兄弟元素具有 间隙（clearance）。 流内 块级元素的 margin-top 总会与 它的 第一个流内块级子元素的 margin-top 合并，条件是该元素没有 border-top、没有 padding-top、且其孩子（the child）没有 间隙。 一个 height 为 auto 且 min-height 为 0 的 流内块级盒的 margin-bottom 会与它的 最后一个流内块级子（盒子） 的 margin-bottom 合并，条件是该盒子没有 border-bottom、没有 padding-bottom、且其孩子的 margin-bottom 没有与 具有 间隙 的 margin-top 合并。 盒子自身的外边距也会合并，条件是 min-height 属性值为 0、既没有 padding-top || padding-bottom 也没有 border-top || border-bottom、height 属性值为 0 或 auto，且没有 行盒子，那么其所有流内 孩子 的外边距（若存在）都会合并。 当两个或更多的 margin 合并时，产生的 margin 的宽度为 被合并的 外边距宽度 的最大值。对于 负 margin，就从 (正相邻 margin 的最大值) 减去 (负相邻 margin 绝对值 的最大值)。如果没有 正 margin，就用 0 减去 相邻 margin 的绝对值 的最大值。 如果盒子的上下外边距相邻，那么外边距合并可能会穿过它。这种情况下，该元素的位置取决于 它 与 其它外边距被合并了的元素 的关系。 如果该元素的外边距（margin）与其父元素的上外边距（margin-top）合并了，盒子的 上边框边缘 被定义为与其父元素的相同。 否则，要么该元素的父元素没参与 外边距合并，要么只涉及其父元素的下外边距（margin-bottom）。该元素 上边框边缘 的位置与元素下边框 非 0 时的位置相同。 注意：被折叠外边距穿过的元素 的位置 不影响 其它外边距正要被合并 的元素的位置，其 上边框边缘的位置 仅用于布局 这些元素的后代元素。 8.4 填充属性：padding-top、padding-right、padding-bottom、padding-left、padding 填充属性指定了一个盒子的 填充区域 的宽度。padding 这个简写属性可以设置 填充区域的四边，而其它填充属性只能设置一边。 本节定义的属性参考 的值类型，可以采用以下值之一： ：指定一个固定的宽度。 ：百分比是根据生成的盒子的 包含块的宽度 计算的。请注意，对于 padding-top 和 padding-bottom 也是如此。如果包含块的宽度取决于该元素，则产生的布局在 CSS 2.2 中没有定义。 不允许 padding 为负值。 关键信息摘要： 属性名称：padding-top, padding-right, padding-bottom, padding-left 值： | inherit 初始值：0 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：指定的百分比或者绝对长度 关键信息摘要： 属性名称：padding 值：{1,4} | inherit 初始值：see individual properties 适用元素：all elements except elements with table display types other than table-caption, table and inline-table 继承：no 百分比：相对于 包含块的宽度 适用媒体：visual 计算值：见单独的各个属性 padding 属性是 padding-top、padding-right、padding-bottom、padding-left 的简写属性。 只有一个值时，则应用于四个属性 只有两个值时，则 padding-top 和 padding-bottom 为第一个值，padding-left 和 padding-right 为第二个值 只有三个值时，则 padding-top 为第一个值，padding-left 和 padding-right 为第二个值，padding-bottom 为第三个值 只有四个值时，则 padding-top 为第一个值，padding-right 为第二个值，padding-bottom 为第三个值，padding-left 为第四个值 填充区域的 表面颜色或图像 通过 background 属性指定： h1 { background: white; padding: 1em 2em; } 上例指定了 '1em' 的垂直填充区域（padding-top 和 padding-bottom）和 '2em' 的水平填充区域（padding-right 和 padding-left）。em 单位与当前元素的字体大小有关：'1em' 等于当前所用字体的大小。 8.5 边框属性（Border properties） 边框属性指定了一个盒子的 边框区域 的宽度。border 这个简写属性可以设置 边框区域 的四边，而其它边框属性只能设置一边。 注意：对于 HTML，用户代理可能为某些用户界面元素渲染边框区域，不同于 \"普通\" 的元素。 8.5.1 边框宽度：border-top-width、border-right-width、border-bottom-width、border-left-width、border-width 边框宽度 属性指定了一个盒子的 边框区域 的宽度。该属性定义了 的值类型，可取下列值之一： thin：细边框 medium：中等边框 thick：粗边框 ：边框的粗细有固定值且不能为负 前三个值的解释由用户代理定义，但必须保持以下关系：'thin' 。 关键信息摘要： 属性名称：border-top-width、border-right-width、border-bottom-width、border-left-width 值： | inherit 初始值：medium 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：绝对长度；'0'，如果 border-style 为 none 或 hidden 关键信息摘要： 属性名称：border-width 值：{1,4} | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border-width 属性是 border-top-width、border-right-width、border-bottom-width、border-left-width 的简写属性。 只有一个值时，则应用于四个属性 只有两个值时，则 border-top-width 和 border-bottom-width 为第一个值，border-right-width 和 border-left-width 为第二个值 只有三个值时，则 border-top-width 为第一个值，border-left-width 和 border-right-width 为第二个值，border-bottom-width 为第三个值 只有四个值时，则 border-top-width 为第一个值，border-right-width 为第二个值，border-bottom-width 为第三个值，border-left-width 为第四个值 8.5.2 边框颜色：border-top-color、border-right-color、border-bottom-color、border-left-color、border-color 边框颜色 属性指定了一个盒子的 边框（区域）的颜色。 关键信息摘要： 属性名称：border-top-color、border-right-color、border-bottom-color、border-left-color 值： | transparent | inherit 初始值：color 属性的值 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：当从 color 属性取值的话，取 color 的计算值。否则，就和指定值一样。 关键信息摘要： 属性名称：border-width 值：[ | transparent ]{1,4} | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border-color 可以一次性设置 4 条边框的颜色。值含义如下： ：指定一个颜色值 transparent：边框是透明的（尽管可能具有宽度） border-color 属性也有 1 到 4 个值，并且值可以用来设置不同方向的颜色，同 border-width。 如果一个元素没有用 border 属性指定 border-color，用户代理则必须把该元素的 color 属性作为 border-color 的计算值。 下例中，border 将是黑色： p { color: black; background: white; border: solid; } 8.5.3 边框风格：border-top-style、border-right-style、border-bottom-style、border-left-style、border-style 边框风格 属性指定了一个盒子的 边框（区域）的线条风格（实线、双实线、虚线等等）。 该属性定义了 的值类型，可取下列值之一： none：无边框，边框的宽度计算为 0 hidden：同 none，除了在 表格元素 的 边框冲突处理 时 dotted：边框是一系列点 dashed：边框是一系列短线段 solid：边框是一条单独的线段 double：边框是两条实线。两条实线及它们之间的距离等于 border-width 的值 groove：边框看起来好像刻在画布上（3D 凹槽效果） ridge：边框看起来好像要从画布上出来（3D 凹槽效果） inset：边框让盒子看起来像是嵌进画布上（无 3D 效果） outset：边框让盒子看起来像要从画布上出来（无 3D 效果） 所有的边框都是在 盒子的背景（原：background）上绘制的。border 属性值为 groove、ridge、inset 和 outset 的边框颜色取决于元素的 border-color 属性，但 UA 可能会选用它们自己的算法来计算要应用的实际颜色。 关键信息摘要： 属性名称：border-top-style、border-right-style、border-bottom-style、border-left-style 值： | inherit 初始值：color 属性的值 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 关键信息摘要： 属性名称：border-style 值：{1,4} | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border-style 可以一次性设置 4 条边框的线条风格。也有 1 到 4 个值，并且值可以用来设置不同方向的线条风格，同 border-width。 下例中，水平边框将是 solid，垂直边框将是 dotted： #xy34 { border-style: solid dotted } 由于边框风格的初始值为 none，因此除非设置了 border-style，否则不会有 可见的边框。 8.5.4 边框简写属性：border-top、border-right、border-bottom、border-left、border 关键信息摘要： 属性名称：border-top、border-right、border-bottom、border-left 值：[ || || ] | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 这些都是简写属性，用来设置盒子的 上、右、下、左 的边框的宽度、风格和颜色 h1 { border-bottom: thick solid red } 上面的规则将设置 元素下方的边框宽度、样式和颜色。省略的值会被设置为其初始值。因为下面的规则没有指定 border-color，边框将获得 color 属性指定的颜色： h1 { border-bottom: thick solid } 关键信息摘要： 属性名称：border 值：[ || || ] | inherit 初始值：见单独的各个属性 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：见单独的各个属性 border 也是简写属性，用来设置盒子的 4 条边框设置相同的宽度、样式和颜色。与 margin 和 padding 不同，border 属性不能对 4 条边框设置不同的值。因此，只能使用其它的边框属性。 下例，第一条规则等价于它后面的 4 条规则集： p { border: solid red } p { border-top: solid red; border-right: solid red; border-bottom: solid red; border-left: solid red } 由于在某种程度上，属性功能有所重叠，（样式）的规则的声明顺序很重要 看下例： blockquote { border: solid red; border-left: double; color: black; } 上例中，左边框的颜色是黑色，其余边框是红色。这是因为 border-left 同时设置了宽度、风格、颜色。因为颜色值没有从 border-left 属性给出，则将从 color 属性获取。color 属性虽然是在 border-left 属性之后设置的，但这并没影响。 8.6 双向上下文中行内元素的盒子模型 对于每个 行盒子（原：line box），UA 必须为每个元素生成 行内盒子 并且按照可视顺序（原：visual order）（不是逻辑顺序（原：logical order））呈现外边距（区域）、边框（区域）、填充（区域）。 当元素的 direction 属性为 ltr 时，元素出现的 第一个行盒子 里的 最左边生成的盒子 拥有 左外边距（区域）、左边框（区域）、左填充（区域），并且 元素出现的 最后一个行盒子 里的 最右边生成的盒子 拥有 右外边距（区域）、右边框（区域）、右填充（区域）。 当元素的 direction 属性为 rtl 时，元素出现的 第一个行盒子 里的 最右边生成的盒子 拥有 右外边距（区域）、右边框（区域）、右填充（区域），并且 元素出现的 最后一个行盒子 里的 最左边生成的盒子 拥有 左外边距（区域）、左边框（区域）、左填充（区域）。 Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "},"docs/CSS/CSS2.2/9 视觉格式化模型.html":{"url":"docs/CSS/CSS2.2/9 视觉格式化模型.html","title":"9 视觉格式化模型","keywords":"","body":"9 视觉格式化模型 9.1 视觉格式化模型的介绍 本章与下一章描述了视觉格式化模型：客户端如何处理可视化媒体下的文档树。 在视觉格式化模型下，在文档树中每个元素会按照盒子模型生成 0 个或多个盒子。盒子的布局会受到以下因素控制： 盒子尺寸和类型 定位方案：普通流，浮动定位，绝对定位 文档树中元素之间的关系 外部因素（如：视口大小，图片的固有尺寸等等） 本篇和下一篇文章定义的属性适用于连续媒体和分页媒体。但是用于分页媒体中，margin 属性的含义可能会不同。 视觉格式化模型没有指定格式化的所有方面，比如字母间距的算法。对于本规范未涵盖的格式问题，（与 CSS 规范一致的）用户代理的表现可能有所不同。 9.1.1 视口 用于连续媒体的用户代理通常会为用户提供其查阅文档的视口（屏幕上的一个窗口或视图区域）。 用户代理在调整视口（见 初始包含块 小节）时，可能会改变文档的布局。 当视口小于渲染文档的画布区域时，用户代理应该提供滚动机制。一个画布最多只能有一个视口，但用户代理可能会渲染到多个画布上（即，提供同一文档的不同视图）。 9.1.2 包含块 在 CSS 2.2 中，盒子的位置和大小是相对于 称为包含块的矩形框 的边缘计算的。通常来说，生成的盒子可以作为后代盒子的包含块。我们说一个盒子为其后代 \"创建\" 了包含块。一个盒子的包含块 意思是 盒子所在的包含块，而不是它生成的那个（包含块）。 每个盒子都有一个相对于其包含块的位置，但它不受这个包含块的限制，它可能溢出（原：overflow）。 有关如何计算包含块的尺寸的详细信息将在下一章介绍。 9.2 控制盒子的生成 以下小节描述了在 CSS 2.2 中生成的盒子类型。盒子的类型部分影响在视觉格式化模型中的行为。下面描述的 display 属性指定了一个盒子的类型。 display 属性的某些值会导致源文档的元素生成一个主盒子（原：a principal box），这个主盒子包含后代盒子和生成的内容，同时这个主盒子也是所有的定位方案中所提及的盒子。 除了主盒子之外，某些元素可能会生成其它盒子：list-item 元素。这些附加盒子会相对于主盒的位置。 9.2.1 块级元素和块盒子 块级元素（原：block-level elements）：源文档的这些元素会被显示格式成块，并且是生成块级主盒子（原：block-level principal box）的元素。构成 块级元素 的 display 属性值：block、list-item、table。块级盒子（原：block-level boxes）是参与 块格式化上下文 的盒子。 在 CSS 2.2 中，块级盒子也就是块容器盒子，除非它是 表格盒子 或 替换元素的主盒子。块容器盒子要么只包含块级盒子，要么就建立 行内格式化上下文并只包含行内元素。元素的主盒子是块容器盒子，则该元素是块容器元素。display 属性的值为 block、list-item、inline-block 时可以使非替换元素生成块容器（盒子）。不是所有的块容器盒子都是块级盒子：非替换行内块、非替换表格单元是块容器但不是块级。块级盒子也叫块容器盒子的时候，称为块盒子。 三个术语块级盒子（原：block-level box）、块容器盒子（原：block container box）、块盒子（原：block box）在没有歧义的时候就简称为 块 block。 9.2.1.1 匿名块盒子（Anonymous block boxes） 在文档里像这样的（片段）： some text more text 假设：DIV 和 P 都是 display: block，DIV 同时具有 行内内容（原：inline content） 和 块元素（原：block element）。为了更容易定义 格式化，我们假设 some text 周围有一个 匿名块盒子。 图中显示了三个盒子，其中一个是 匿名盒子。 换句话说：如果一个块容器盒子（如上面的 DIV）里面有一个 块级盒子，然后我们强制让它里面只有块级盒子。 当一个 行内盒子 包含一个 流内块级盒子 时，这个行内盒子（及其在同一个行盒子里的行内祖先）会被周围的块级盒子打破（以及 任何连续的或只被可合并的 空白字符 和/或 流外元素隔开的块级兄弟盒子）？？？，会把行内盒子分成两个盒子（即使有一边是空的），分别位于块级盒子的两边。隔开前和隔开后的行内盒子都被包含在匿名块盒子中，并且该块级盒子会变成这些匿名块盒子的兄弟。当这样的行内盒子受到 相对定位 （而产生的偏移）的影响时，任何结果转换都会影响 行内盒子中所包含的块级盒子。 此模型会用于下例，如果下列规则： p { display: inline } span {display: block} 用在如下文档： This is anonymous text before the span This is the content of span. This is anonymous text after the span 分析：P 元素包含一个 匿名文本 的 chunk(c1)，后面紧跟 块级元素，再后面紧跟 另一个匿名文本 的 chunk(c2)。结果，盒子将会产生一个代表 BODY 的块盒子，包含一个 围绕 c1 的匿名块盒子，SPAN 块盒子，一个 围绕 c2 的匿名块盒子。 匿名块盒子的属性继承于非匿名盒子（比如第一个例子的 DIV 的盒子）。非继承属性具有初始值。比如匿名盒子的字体来源于 DIV，但是 margin 就为 0。 在生成匿名块盒子的元素上设置属性仍适用于该元素的盒子和内容。比如若在 P 元素上设置了边框，边框绘制 在 c1 结尾出打开，和在 c2 开头处打开。 一些用户代理已经以其它方式在包含块的行内上实现了边框，比如，通过把这种 嵌套块 包裹给在 \"匿名行盒子\" 内，从而使得这些盒子周围绘制 行内边框。CSS 1 和 CSS 2 没有定义该行为，因此仅 CSS 1 和 CSS 2 用户代理可以实现此替代模型，并且仍声明符合 CSS 2.2 这一部分。这不适用于此规范发布后的开发的 UA。 在 解析 百分比值 的时候，匿名块盒子会被忽略：使用最近的非匿名祖先盒子。比如如果上面 DIV 的匿名块盒子的子级需要知道其包含块的高度以解析百分比高度，那么将使用 DIV 所形成的包含块的高度，而不是匿名块盒子的高度。 9.2.2 行内级元素和行内盒子 行内级元素（原：inline-level elements）是源文档中不形成新内容块的元素。内容以行分布（比如强调段落中的一部分文本，行内图片等）。display 属性值为 inline、inline-table、inline-block 可以使元素成为 行内级元素。行内级元素生成行内级盒子，这些盒子会参与 行内格式化上下文。 行内盒子 是行内级盒子的一种，其内容参与所包含的行内格式化上下文。display 为 inline 的非替换元素会生成行内盒子。不是行内盒子（如行内级替换元素、行内块元素、行内表格元素）的行内级盒子称为原子行内级盒子，因为它们作为单一的不透明盒子参与其行内格式化上下文。 9.2.2.1 匿名行内盒子 任何直接包含在块容器元素里（不是在行内元素里）的文本都必须被视为匿名行内元素。 有一个如下 HTML 片段： Some emphasized text P 元素生成一个 块盒子，里面有几个行内盒子。emphasized 文本的行内盒子由行内元素 EM 生成，但是 Some 和 text 的行内盒子由块级元素 P 生成。后者叫 匿名行内盒子，因为它们没有相关联的 行内级元素。 此类匿名行内盒子可以从其父级块盒子继承可继承的属性。非继承属性取其初始值。比如匿名行内盒子的 color 是继承的，background 就是透明的。 根据 white-space 属性，合并掉的空白字符内容不会生成任何匿名行内盒子。 如果从上下文可以清楚看到是哪种匿名类型的盒子，则匿名行内盒子和匿名块盒子在本规范中简称为匿名盒子。 在格式化表格时会出现很多的匿名盒子类型，开不开心。 9.2.3 Run-in 盒子 display: run-in 将在 CSS3 中定义，见 CSS3 盒子 9.2.4 display 属性 关键信息摘要： 属性名称：display 值：inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit 初始值：inline 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：all 计算值：见下文 此属性的值具有以下含义： block：该值使元素生成 一个主块盒子 inline-block：该值使元素生成 主行内级块容器盒子。（inline-block 的内部会被格式化成一个块级盒子，元素本身会被格式化成为原子行内级盒子） inline：该值使元素生成 一个或多个行内盒子 list-item：该值使元素（如 ）生成 主块级盒子和标记盒子。 none：该值使元素不出现在格式化结构中（在视觉媒体中，元素不生成盒子且不影响布局）。后代元素也不会生成任何盒子。元素及其内容完全从格式化结构中删除。即使在后代上设置 display 值，也无法覆盖该行为。 注意：display: none 不会生成一个看不见的盒子，它根本就不会创造任何盒子。CSS 有一些机制能够使元素在格式化结构中产生影响，但本身不可见的盒子。详细信息请见 11-可见性 小节。 table, inline-table, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, and table-caption：这些值使其元素的行为像表格，见 17-表格 章节。 除了定位元素、浮动元素、根元素之外，（display 属性的）计算值与特定值相同。对于根元素，计算值 将按照 9.7 小节内容 'display'，'position'与'float' 之间的关系 描述的计算 注意：虽然 display 的初始值为 inline，但在客户端中的默认样式表中的规则可能会覆盖该值。见附录中的 HTML4 的样例样式表。 下面有 display 属性的例子： p { display: block } em { display: inline } li { display: list-item } img { display: none } /* Do not display images */ 9.3 定位方案 在 CSS 2.2 中，一个盒子可能根据三种定位方案进行布局： 普通流（原：Normal flow）：在 CSS 2.2 中，在普通流情况下包括 块级盒子的块格式化、行内级盒子的行内格式化、块级盒子和行内级盒子的相对定位。 浮动（原：Floats）：在浮动模型中，一个盒子首先在普通流情况下进行布局，然后在流中脱离并尽可能向左或向右移动。其它内容可能沿着浮动（盒子）的一侧排列。 绝对定位（原：Absolute positioning）：在绝对定位模型中，一个盒子完全从普通流中移除（对后面的 siblings 没有影响），并且相对于包含块指定了一个位置。 如果一个元素浮动、或绝对定位、或是根元素，则称该元素流外（原：out of flow）。如果元素没有流外，则称该元素流内（原：in-flow）。元素 A 的流由 A 和所有流内元素组成的集合，且最近可以流外的祖先为 A。 注意：CSS 2.2 的定位方案帮助作者的文档可读性更好，让他们避免那些用来实现布局效果的标记技巧（比如，不可见的图片）。 9.3.1 选择定位方案：position 属性 position 属性和 float 属性决定使用哪种 CSS 2.2 中的定位算法来计算盒子的位置。 关键信息摘要： 属性名称：position 值：static | relative | absolute | fixed | inherit 初始值：static 适用元素：所有元素 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 此属性的值具有以下含义： static：该盒子是一个普通盒子，根据普通流进行布局。top，right，bottom，left 属性不适用。 relative：盒子的位置根据普通流进行计算，这称之为在普通流中的位置，然后该盒子在相对于其正常位置进行偏移。当盒子 B 相对定位时，下一个盒子的位置计算就好像盒子 B 没有进行偏移一样。position: relative 对 table-row-group, table-header-group, table-footer-group, table-row, table-column-group, table-column, table-cell, table-caption 的元素的效果未定义。 absolute：盒子的位置（及可能的大小）由 top，right，bottom，left 属性进行指定。这些属性相对于该盒子的包含块的偏移。绝对定位的盒子脱离普通流，这意味着它们对后来的 siblings 的布局没有影响。此外，尽管绝对定位的盒子有 margin，但不会与任何其它的边距合并。 fixed：盒子的位置是根据 \"绝对\" 模型计算的，除此之外，盒子相对于某个参照物是固定的。和绝对模型一样，盒子的外边距不会与任何其它的外边距发生合并。 对于手持、投影、屏幕、tty、tv 媒体类型，该盒子是相对于其视口进行定位的，滚动时不会移动 在 打印 媒体类型上，即使通过视口看到页面，每个页面的该盒子都相对于页面盒子时固定的 对于其它媒体类型的效果未定义。 作者可能希望以媒体依赖的方式指定 fixed。比如，一个作者可能希望盒子保留在屏幕上视口的顶部，但不出现在每一个打印页的顶部。可以使用 @media 规则把它们分开，比如： @media screen { h1#first { position: fixed } } @media print { h1#first { position: static } } UA 不能对 fixed 的盒子的内容进行分页。注意：UA 可能以其它方式打印不可见的内容，见 13 章节 - 页面盒子外的内容。 用户代理可以把根元素的 position 属性视为 static。 9.3.2 盒子偏移：top right bottom left 如果元素的 position 是除 static 之外的值，则称该元素被定位（或称该元素为定位元素）。定位元素生成定位盒子，根据四个属性进行布局 top 属性 关键信息摘要： 属性名称：top 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的高度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 该属性指定了 绝对定位盒子的上外边距边缘 对于 该盒子的包含块的上边缘下方 的偏移量。对于相对定位的盒子，偏移量是相对于盒子自身的顶部边缘（即，盒子在普通流中指定了一个位置，然后根据这些属性从原位置偏移）。 right 属性 关键信息摘要： 属性名称：right 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 与 top 类似，但指定的 盒子的右边距边缘 对于 该盒子的包含块的右边缘的左边 的偏移量。对于相对定位的盒子，偏移量是相对于盒子自身的右边缘。 bottom 属性 关键信息摘要： 属性名称：bottom 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的高度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 与 top 类似，但指定 盒子的底部边距边缘 对于 该盒子的包含块的底部边缘的上方 的偏移量。对于相对定位的盒子，偏移量是相对于盒子自身的底部边缘。 left 属性 关键信息摘要： 属性名称：left 值： | | auto | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：相对于包含块的宽度 适用媒体：visual 计算值：如果指定为长度，则对应的绝对长度。如果是百分比，则为指定值。否则为 auto 与 top 类似，但指定 盒子的左边距边缘 对于 该盒子的包含块的左边缘的右边 的偏移量。对于相对定位的盒子，偏移量是相对于盒子本身的左边缘。 此属性的值具有以下含义： ：偏移量是距离边缘的固定距离。允许负值 ：偏移量是包含块的宽度（对于 left 或 right）或高度（对于 top 或 bottom）的百分比。允许负值 ：对于非替换元素，此值的影响取决于哪个相关属性的值为 auto。非替换元素的详细情况，见 9.6 小节。对于替换元素，此值的影响取决于替换内容的固有尺寸。详细情况，也见 9.6 小节。 9.4 普通流（Normal flow） 在普通流中盒子属于一个格式化上下文，这个格式化上下文可以是表格、块、行内。在 CSS 的未来中，将会引入其它类型的格式化上下文（比如，FFC 和 GFC）。 块级盒子参与 块格式化上下文。 行内盒子参与 行内格式化上下文。 表格格式化上下文会在表格章节中描述。 【理解：上下文其实是一个环境】 9.4.1 块格式化上下文（Block formatting contexts） 浮动（元素）、绝对定位元素、不是块盒子的块容器（元素）（比如 行内块（原：inline-blocks）、表格单元（原：table-cells）、表格标题（原：table-captions）），以及 overflow 不是 visible 的块盒子（除了 该值传播到视口 以外）会为其内容建立了新的块格式化上下文。 在 块格式化上下文 中，盒子从包含块的顶部开始一个接一个的垂直布局。两个兄弟盒子之间的垂直距离由 margin 属性决定。块级盒子的垂直外边距在块格式化上下文中会进行合并。 在块格式化上下文中，每个盒子的左外边缘触及包含块的左边缘（对于从右到左的格式化，右边缘触及）。即使存在浮动也如此（尽管盒子的行盒子可能会因为浮动而缩小），这也成立。除非该盒子建立了一个新的块格式化上下文（在这种情况下，盒子可能会因为浮动而缩小）。 关于分页媒体中分页相关的信息，请查看 13.3.3 合法的分页符 小节。 9.4.2 行内格式化上下文（Inline formatting contexts） 行内格式化上下文由 不包含块级盒子的 块容器盒子建立。在行内格式化上下文中，盒子从包含块的顶部一个接着一个水平布局。在这些盒子中，水平外边距（margin-left、margin-right）、边框(border)、填充（padding）都有效。盒子可能会以不同的方式垂直对齐：以它们的底部或顶部对齐，或以它们的文本的基线对齐。包含的这些盒子形成一行的矩形区域称之为行盒子。 行盒子的宽度由包含块和浮动情况决定。行盒子的高度由 10.8 行高的计算 的规则决定。 行盒子总是足够高，能够容纳它包含的所有盒子。然而，它可能比它包含的最高的盒子的高还要高（比如，如何盒子是以基线对齐的）。当盒子 B 的高度小于 包含它的行盒子的高度时，在行盒子内 B 的垂直对齐 由 vertical-align 属性决定。当多个行内级盒子不能在一个行盒子里水平放置时，它们就被分在两个或多个垂直堆叠的行盒子里。因此，段落就是一个垂直堆叠的行盒子集。行盒子垂直堆叠时没有垂直间隔（除非另有说明），它们从不重叠。 通常来说，行盒子的左边缘紧挨其包含块的左边缘，右边缘紧挨其包含块的右边缘。但是，浮动盒子可能在包含块边缘和行盒子边缘之间。因此，尽管在同一行内格式化上下文中行盒子通常具有相同的宽度（即，包含块的宽度），但是如果由于浮动而减少了可用的水平空间，则它们的宽度可用变化。在同一格式化上下文中行盒子一般高度各不相同（比如，一行可能有高图片，而其它只有文本）。 当一行上的行内级盒子的总宽度小于包含它们的行盒子的宽度时，它们在行盒子里的水平分布由 text-align 属性决定。如果属性的值为 justify，则用户代理也可以在行内盒子（不包含 inline-table 和 inline-block 盒子）里的空格和字符。 当行内盒子超出行盒子的宽度时，它会被分割成多个盒子，并且这些盒子分布在多个行盒子里。如果一个行内盒子无法被拆（比如，如果行内盒子包含单个字符或者特定语言的分词规则不允许在行内盒子里出现中断，又或者行内盒子受到 nowrap 或 pre 的空白字符的影响），那么该行内盒子会从行盒子溢出。 当一个行内盒子被分割后，外边距、边框、填充在发生分割的地方（或者，在任何分割的地方，有多个的时候）没有视觉效果。 由于双向文本的处理行内盒子也可以在同一个行盒子里里被分割称几个盒子。 行盒子根据需要被创建，以确保在行内格式化上下文里保存行内级内容。（这时候），该行盒子不包含文本，不包含保留空白字符，不包含非 0 外边距的行内元素，填充，边框，以及其它流内内容（比如，图片，行内块或行内表格），并且不以保留换行符结束的（行盒子）在确定其内部元素的位置时必须被当作 0 高度行盒子，出于其它目的时，必须当它不存在。 有个行内盒子构造的示例，下面的段落（由 HTML 块级元素 P 创建的）有匿名文本，散布在 EM 和 STRONG 元素间： Several emphasized words appear in this sentence, dear. P 元素生成了一个含有 5 个行内盒子的块盒子，其中有 3 个是匿名的： Anonymous: \"Several\" EM: \"emphasized words\" Anonymous: \"appear\" STRONG: \"in this\" Anonymous: \"sentence, dear.\" 为了格式化该段落，用户代理会把这 5 个盒子流到 行盒子里。本例中，P 元素生成的盒子为行盒子创建了包含块。如果该包含块足够宽，所有行内盒子都能放进一个行盒子里： 如果不行，行内盒子会被分割并分布在几个行盒子里。之前的段落可能如下： 或者像这样： 在之前的示例中，EM 盒子被分成了两个 EM 盒子（叫它们 split1 和 split2）。外边距，边框，填充或文本装饰不会在 split1 后面和 split2 前面产生可见的效果。 考虑下例： Example of inline flow on several lines em { padding: 2px; margin: 1em; border-width: medium; border-style: dashed; line-height: 2.4em; } Several emphasized words appear here. 由 P 的宽度决定，各个盒子的分布可能如下： 外边距插在 \"emphasized\" 前面和 \"words\" 后面 填充插在 \"emphasized\" 的前面，上面和下面，以及 \"words\" 的后面，上面和下面，虚线边框也出现在这 3 个方向 9.4.3 相对定位（Relative positioning） 一旦盒子按照普通流或浮动布局，它就有可能相对于该位置移动，这就称之为 相对定位。用这种方式偏移盒子（B1）不影响随后的盒子（B2）：B2 被给予了一个位置，就好像 B1 没有偏移并且在对 B1 偏移后，B2 没有重新定位。这就意味着相对定位可能导致盒子重叠。但是，如果相对定位导致 overflow: auto 或 overflow: scroll 的盒子溢出，则 UA 必须让用户能够访问这部分内容（在其偏移位置），这时候，滚动条的创建可能会影响布局。 相对定位的盒子保持其在普通流的大小，包括换行和空格都会原样保留。包含块 这一小节会解释相对定位盒子什么时候创建包含块。 对于相对定位元素，left 和 right 水平移动盒子，不会改变其大小。left 将盒子移动到右侧，right 将盒子移动到左侧。由于 left 或 right 的结果并不会导致盒子分割或拉伸，因此应用值应始终为：left = -right。 如果 left 和 right 都为 auto（初始值），则应用值为 0（即，盒子就呆在原地）。 如果 left 为 auto，则 left 的应用值为 负的 right 值（即，盒子像左移动 right 值）。 如果 right 为 auto，则 right 的应用值为 负的 left 值。 如果 left 和 right 都不为 auto，则位置过度约束，其中一个会被忽略。如果包含块的 direction 属性为 ltr，则 left 有效，right 变为 -left。如果包含块的 direction 属性为 rtl，则 right 有效，left 变为 -right。 示例，下列三条规则时一样的： div.a8 { position: relative; direction: ltr; left: -1em; right: auto } div.a8 { position: relative; direction: ltr; left: auto; right: 1em } div.a8 { position: relative; direction: ltr; left: -1em; right: 5em } top 和 bottom 属性向上或向下移动相对定位的元素而不改变其大小。top 向下移动盒子，bottom 向上移动盒子。由于 top 或 bottom 的结果并不会导致盒子分割或拉伸，因此应用值应始终为：top = -bottom。如果两者都为 auto，则它们的应用值都为 0。如果其中一个为 auto，则其中一个会变为另一个的负值。如果都不为 auto，则忽略 bottom（即，bottom 的应用值为 top 的负值）。 注意：在脚本环境中，相对定位盒子的动态移动会产生动画效果（见 visibility 属性）。尽管相对定位可用作上标或下标的形式，但行高不会因为定位而自动调整。相关信息，可以参考 见 行高计算 的描述。 9.8 小节-普通流、浮动与绝对定位之间的比较 提供了相对定位的例子。 9.5 浮动 浮动是一个在当前行上向左或向右移动的盒子。浮动盒子最有意思的特征是内容可能延其侧面流动（可以通过 clear 属性禁止这样做）。内容沿左浮动盒子的右侧向下流动，沿右浮动盒子的左侧向下流动。下面是浮动定位和内容流的介绍，控制浮动行为的详细规则由 float 属性中说明。 一个浮动盒子向左或向右移动，直到其外边缘挨到包含块的边缘或另一个浮动盒子的外边缘。如果有行盒子，则浮动盒子的外顶部与当前行盒子的顶部对齐。 如果对于浮动（盒子）没有足够的水平空间，那么它会向下移动直至它合适或不再出现浮动。 由于浮动盒子不在（普通）流中，因此在浮动盒子之前或之后创建的非定位块盒子会垂直排列，就好像浮动不存在一样。然而，会根据需要缩短挨着（浮动盒子）创建的当前和后续的行盒子，以便为浮动（盒子）的外边距腾出空间。 行盒子挨着浮动（盒子）的条件是，存在一个垂直位置，满足四个条件：（a）在行盒子顶部或顶部下面，（b）在行盒子底部或底部上面，（c）在浮动（盒子）上外边距边缘的下面，（d）在浮动（盒子）下外边距边缘的上面。 注意：这意味着 0 外高度（原：zero outer height）或负外高度（原：zero outer height）不会缩短行盒子。 如果缩短的行盒子太小而无法包含任何内容，则行盒子向下移动（并重新计算宽度），直到某些内容合适或不再出现浮动。在当前行里浮动盒子之前的任何内容都会在浮动的另一侧的同一行中重排。换句话说，如果行内级盒子被放置在同一行中左浮动（盒子）之前，并且在剩余的行盒子空间合适，则左浮动（盒子）就放置在该行，与行盒子的顶部对齐，然后，已经在该行的行内级盒子相应的移动到该浮动（盒子）的右侧（右侧是 左浮动（盒子）的另一侧），反之亦然，用于 rtl 和右浮动（盒子）。 表格的边框盒子（状态的元素）、块级替换元素、在普通流中创建新 BFC 的元素（比如 overflow 不为 visible 的元素）不得与元素自身处于同一块格式化上下文中的任何浮动（盒子）的外边距重叠。如果有必要的话，实现应该通过将所诉元素放在所有之前出现的浮动（盒子）的下方，以清除（原：clear）该元素（受到的浮动影响），但如果空间足够的话，可以将其放置在这些浮动（盒子）的附近。它们甚至可能会使所诉元素的边框比 第 10.3.3 节所定义的更窄。CSS 2 没有定义 UA 什么情况下可以把该元素放在浮动（盒子）旁边或者所诉元素可能变得更窄。 示例，在下面文档片段中，包含块太窄而不能包含浮动（盒子）旁边的内容，因此内容移动到浮动（盒子）下方，在行盒子中按照 text-align 属性对齐的位置放置 p { width: 10em; border: solid aqua; } span { float: left; width: 5em; height: 5em; border: solid blue; } Supercalifragilisticexpialidocious 效果可能如下： 几个浮动（盒子）可能相邻，该模型也适用于在同一行中的相邻浮动（盒子）。 下列规则让所有 class=\"icon\" 的 IMG 盒子左浮动（且 margin-left: 0）： img.icon { float: left; margin-left: 0; } 看下面的 HTML 源码和样式表： Float example IMG { float: left } BODY, P, IMG { margin: 2em } Some sample text that has no other... IMG 盒子左浮动。后面紧跟着的内容就被格式化到了浮动（盒子）的右侧，从浮动（盒子）的同一行开始。由于浮动的存在，浮动右侧的行盒子缩短，但在浮动之后恢复其 \"正常\" 宽度（P 元素所建立的包含块宽度）。本文档可能会格式化为： 如果文档是下面这样，则格式化效果一样： Some sample text that has no other... 因为浮动（盒子）左侧的内容被浮动（盒子）替代了，（内容）会沿着浮动（盒子）的右侧重排。 如 8.3.1 小节所述，浮动（盒子）的外边距不会与相邻盒子的外边距合并。因此，之前的示例中，P 盒子与浮动的 IMG 盒子之间的垂直外边距不会合并。 浮动（盒子）里的内容会堆叠起来，就好像浮动生成了新的堆叠上下文一样，除了定位元素和实际创建了新堆叠上下文的元素，都参与浮动（盒子）的父级堆叠上下文。在普通流中，浮动盒子会与其它盒子重叠（比如，浮动（盒子）旁边的普通流下的盒子有负的外边距时），出现这种情况时，浮动盒子会呈现在非定位流内的块（盒子）之前，但在流内的行内（盒子）之后。 另一幅图展示当浮动（盒子）与在普通流里的元素的边框重叠时会发生什么： 以下示例说明使用 clear 属性来阻止内容在浮动盒子旁边流动。 假设规则像这样： p { clear: left } 可能会格式化成这样： 两边段落都设置了 clear: left，这就导致第二段被 \"推下到了\" 浮动盒子的下方以实现此目的，间隙（原：clearance）被插入到其上外边距的上面。 9.5.1 定位浮动：float 属性 关键信息摘要： 属性名称：float 值：left | right | none | inherit 初始值：none 适用元素：所有（元素），除了 9.7 小节描述的 继承：no 百分比：N/A 适用媒体：visual 计算值：与指定值相同 此属性指定了盒子向左浮动还是向右浮动，或者不浮动。它可以为任何元素设置该属性，但仅适用于生成非绝对定位的盒子的元素。 此属性的值具有以下含义： left ：该元素生成浮动到左侧的一个块盒子。内容从该盒子的右侧流动，从顶部开始（取决于 clear 属性）。 right ：类似于 left，盒子向右浮动，内容从该盒子的左侧流动，从顶部开始。 none：该盒子不浮动。 用户代理可以把根元素的 float 属性作为 none。 以下是控制浮动行为的精确规则，类似的左浮动元素规则适用于右浮动元素： 左浮动盒子的左外侧边缘可能不位于其包含块的左边缘的左侧。 如果当前盒子是左浮动，并且在源文档中还有元素先生成左浮动的盒子，则对于每个之前此类盒子，当前盒子的左外侧边缘要么位于此类盒子的右外侧边缘的右边，或其顶部必须低于前一个此类盒子的底部。 左浮动盒子的右外边缘可能不位于其旁边的右浮动盒子的左外侧边缘的右边。 浮动盒子的外顶部可能不高于其包含块的顶部。当浮动发生在两个边距合并之间时，浮动的位置就好像它有一个匿名的块父级参与流。这种父级的位置由外边距合并的章节中的规则定义。 浮动盒子的外顶部可能不高于在源文档中还有元素先生成的块（盒子）或浮动盒子 的外顶部。 元素的浮动盒子的外顶部可能不高于在源文档中还有元素 先 生成的盒子的行盒子的顶部。 左浮动盒子左侧还有另一个左浮动盒子，其（指：另一个左浮动盒子）右侧外边缘可能没有位于其包含块的右侧边缘。（宽松的规则：左浮动可能不会超出右边缘，除非它尽可能地向左浮动） 浮动盒子必须尽可能地往高放。 左浮动盒子必须尽可能向左浮动，右浮动盒子必须尽可能向右浮动。较高的位置优于向左/右的位置。 但是在 CSS 2.2 中，在块格式化上下文中，有一个流内的父垂直外边距，使得浮动的位置高于它所处的位置，那么所有这些负边距都设置为 0，浮动的位置没有定义。 这些规则里涉及的其它元素仅仅只是指与浮动盒子处于同一个块格式化上下文的其它元素。 这段 HTML 片段 使 b 右浮动： ab 如果 P 元素足够宽，a 和 b 会在两侧，可能就像这样： 9.5.2 控制浮动旁边的流：clear 属性 关键信息摘要： 属性名称：clear 值：none | left | right | both | inherit 初始值：none 适用元素：块级元素 继承：no 百分比：N/A 适用媒体：visual 计算值：和指定值一样 此属性说明元素盒子的哪一侧不与先浮动的盒子相邻。clear 属性不考虑元素自身的（浮动）或其它 BFC 的浮动。 适用在非浮动块级盒子上有以下含义： left：要求该盒子的上边框边缘位于在源文档中在此之前的元素所生成的左浮动盒子的下外边缘的下方 right：要求该盒子的上边框边缘位于在源文档中在此之前的元素所生成的右浮动盒子的下外边缘的下方 both：要求该盒子的上边框边缘位于在源文档中在此之前的元素所生成的左浮动盒子和右浮动盒子的下外边缘的下方 none：盒子相对浮动（盒子）的位置没有约束 值不为 none 就意味着要引入 空隙（原：clearance）。空隙会抑制外边距合并，并作为 margin-top 上方的空间。用于在垂直方向上把元素推离浮动（元素）。 通过首先确定元素的上边框边缘的假定位置来计算含有 clear 属性的元素的位置。如果元素的 clear 属性为 none，则该位置是其上边框边缘实际所在的位置。 如果元素的上边框边缘的假定位置没有越过有关的浮动盒子，那么空隙就会引入，且外边距会根据 8.3.1 小节进行合并。 然后，空隙的高度（原：amount）设置为下面两者的最大值： 将块（盒子）的边框边缘放置在最低的即将被清除（原：clear）的浮动（盒子）的下外边缘，所必须要的高度。 将块（盒子）的上边框边缘放在某个假定位置（clear 为 none 的假定位置），所必须要的高度。 或者，空隙（的高度）可以设置为将块（盒子）的边框边缘放置在最低的即将被清除的浮动（盒子）的下外边缘，所必须要的高度。 注意： 两种行为都允许现有的 Web 内容评估的兼容性。未来的 CSS 规范会选择其一 空隙可以为负或0 示例1：简单起见，假设，我们只有三个盒子，依次顺序：块 B1 有下外边距 M1（B1 没有子级，没有填充，没有边框），浮动块（高度为 H），块 B2 有上外边距 M2（B2 没有子级，没有填充，没有边框）。B2 的 clear 为 both。同样，假设 B2 为空。 如果不考虑 B2 的 clear 属性，我们会看到下图情况。B1 和 B2 的外边距（垂直）合并了。假设 B1 的下边界边缘为 y=0，则 F 的顶部为 y=M1，B2 的上边界边缘为 y=max(M1, M2)，F 的底部为 y=M1+H。 我们假设 B2 不在 F 下方（垂直方向上），即这就是规范所说的需要添加额外空隙的，意味着： max(M1,M2) 我们需要计算两次空隙 C：C1 和 C2，取较大值：C = max(C1,C2)。 第一种方法是将 B2 的顶部与 F 的底部齐平，即在 y=M1+H 处。这意味着，外边距由于有空隙不再合并： bottom of F = top border edge of B2 ⇔ M1 + H = M1 + C1 + M2 ⇔ C1 = M1 + H - M1 - M2 = H - M2 第二种计算保持 B2 的顶部（位置）不变，即 y=max(M1, M2)，意味着： max(M1,M2) = M1 + C2 + M2 ⇔ C2 = max(M1,M2) - M1 - M2 我们假设 max(M1,M2) C2 = max(M1,M2) - M1 - M2 同时，因为 C1 = H - M2，所以： C2 所以： C = max(C1,C2) = C1 示例2：这是负空隙的情况，为 -1em，（假设元素没有边框或填充） First paragraph. Floating paragraph. Last paragraph. 解释：如果没有 clear，则第一段和第三段的外边距将会合并，最后一段的上边框边缘将会与浮动段落的顶部齐平。但是 clear 要求上边框边缘低于浮动盒子，即为 2em。这就意味着要引入空隙。这样一来，外边距不再合并，空隙的高度应满足 clearance + margin-top = 2em，即，clearance = 2em - margin-top = 2em - 3em = -1em。 当属性设置在浮动元素上，会导致修改浮动定位的规则，添加了一个额外的约束（#10）： 浮动盒子的上外边框边缘必须低于所有早期左浮动盒子的下外边缘（在 clear: left 的情况下），或者所有早期右浮动盒子的下外边缘（在 clear: right 的情况下），或者两者（在 clear: both 的情况下）。 注意：该属性适用于 CSS 1 中的所有元素，实现可能已经在所有元素上支持该属性了。CSS 2 和 CSS 2.2 中，clear 属性只适用于块级元素。因此，作者应该只把该属性用在块级元素上。如果需要实现支持行内元素上的 clear，而不像上面解释的那样设置一个空隙，实现应该是强制中断（原：break）并有效地插入一个或多个空 行盒子（或者按 9.5节 中描述的那样向下移动新的行盒子），以便将有 clear 的行内元素的行盒子的顶端移到对应的浮动盒子下方。 9.6 绝对定位（Absolute positioning） 在绝对定位模型中，一个盒子相对于其包含块明确偏移。完全从普通流中移除，对后来的兄弟（盒子）没有影响。绝对定位的盒子，为其盒子里在普通流里的子级和绝对定位（不是 fixed）创建了一个新的包含块。然而，绝对定位元素的内容不会围绕其它任何盒子流动。它们可能会遮挡另一个盒子的内容（或自身被遮挡），具体取决于重叠盒子的层叠级别。 本说明里的绝对定位元素意味着 元素的 position 属性为 absolute 或 fixed。 9.6.1 固定定位（Fixed positioning） 固定定位是绝对定位的一种。唯一的区别是，对于固定定位的盒子，包含块由 视口 创建。 对于连续的媒体，文档滚动时固定盒子不会移动，类似于固定的背景图像。 对于分页媒体，每页都会重复具有固定位置的盒子。这对于在每个页面的底部放置签名很有用。 作者可能想通过使用固定定位来创建类似演示文稿： A frame document with CSS body { height: 8.5in } /* Required for percentage heights below */ #header { position: fixed; width: 100%; height: 15%; top: 0; right: 0; bottom: auto; left: 0; } #sidebar { position: fixed; width: 10em; height: auto; top: 15%; right: auto; bottom: 100px; left: 0; } #main { position: fixed; width: auto; height: auto; top: 15%; right: 0; bottom: 100px; left: 10em; } #footer { position: fixed; width: 100%; height: 100px; top: auto; right: 0; bottom: 0; left: 0; } ... ... ... ... 9.7 display、position、float 之间的关系 影响盒子生成和布局的三个属性：display、position、float，遵循以下规则： 如果 display 的值为 none，则 position、float 无效。在这种情况下，元素不生成盒子。 否则，如果 position 的值为 absolute 或 fixed，则该盒子为绝对定位，float 的计算值为 none，并根据下表设置 display 属性。盒子的位置将由 top、right、bottom、left 和该盒子的包含块决定。 否则，如果 float 的值不为 none，则该盒子浮动，并根据下表设置 display 属性。 否则，如果元素为 根元素，则根据下表设置 display 属性。在 CSS2.2 中，指定值为 list-item 是否变为 block 或 list-item，这种情况未定义。 否则，其余的 display 属性按照指定值使用。 指定值（Specified value） 计算值（ Computed value） inline-table table inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block block others 和指定值一样 9.8 普通流、浮动、绝对定位之间的比较 为了说明 普通流，相对定位，浮动和绝对定位之间的差异，基于以下 HTML 提供了一些示例： Comparison of positioning schemes Beginning of body contents. Start of outer contents. Inner contents. End of outer contents. End of body contents. body { display: block; font-size:12px; line-height: 200%; width: 400px; height: 400px } p { display: block } span { display: inline } 由 #outer 和 #inter 元素生成的盒子的最终位置在每个示例中都不一样。每幅图中左边的数字表明了在普通流里双倍行距的位置。 注意：本节的图并不是按比例绘制，只是来说明各定位方案之间的差异。 9.8.1 普通流 考虑以下 CSS 声明，不会改变盒子的（默认）定位方案：普通流 #outer { color: red } #inner { color: blue } P 元素包含所有行内内容：匿名行内文本和两个 SPAN 元素。因此，所有内容都将在 由 P 元素创建的包含块里的行内格式化上下文中进行布局，从而产生以下内容： 此图描述 9.8.2 相对定位 为了看 相对定位 效果，指定： #outer { position: relative; top: -12px; color: red } #inner { position: relative; top: 12px; color: blue } 文本正常排列，直到 #outer（盒子）。 #outer 文本保持其普通流下的位置和尺寸，位于第一行末尾。然后，含有文本（分布在三行里）的行内盒子作为一个整体移动了 \"-12px\"（向上）。 #inner 的内容，作为 #outer 的子级，正常的紧跟着 \"of outer contents\" 文本排列（在 1.5 行）。然而，#inner 的内容自身相对于 #outer 的内容偏移了 \"12px\"（向下），回到了在第 2 行的原位置。 注意：#outer 后面的内容不受 #outer 相对定位的影响。 此图描述 注意：#outer 的偏移若为 -24px，则 #outer 文本与正文重叠。 9.8.3 浮动盒子 现在来使 #inner 元素向右浮动： #outer { color: red } #inner { float: right; width: 130px; color: blue } 文本正常排列，直到 #inner（盒子），从普通流里脱离，并浮动到右外边距（其宽度已显示指定）。浮动（盒子）左侧的行盒子被缩短了，文档的其余文本就排列在里面： 此图描述 为了展示 clear 属性的效果，我们增加了 #sibling 元素： Comparison of positioning schemes II Beginning of body contents. Start of outer contents. Inner contents. Sibling contents. End of outer contents. End of body contents. #inner { float: right; width: 130px; color: blue } #sibling { color: red } #inner 盒子会向之前一样右浮动，文档的其余文本就排列在腾出的空间里： 此图描述 然而，如果 #sibling 元素上的 clear 属性为 right（即生成的 #sibling 盒子不会接受一个右侧有浮动盒子的位置），则 #sibling 内容从浮动盒子下面开始流动排列： #inner { float: right; width: 130px; color: blue } #sibling { clear: right; color: red } 此图描述 9.8.4 绝对定位 最后，我们来看绝对定位的效果： #outer { position: absolute; top: 200px; left: 200px; width: 200px; color: red; } #inner { color: blue } #outer 盒子的顶部会相对于其包含块定位。定位盒子的包含块由最近的定位祖先创建（若不存在，则用初始包含块，就和我们示例一样）。#outer 盒子的顶部距离包含块的顶部为 200px，左侧距离左侧的 200px。#outer 的子级盒子相对于其父级正常排列。 此图描述 下面示例显示了一个绝对定位的盒子，它是相对定位的盒子的子级。虽然父级 #outer 盒子没有发生偏移，且 position: relative，表示其生成的盒子可以作为定位后代的包含块。由于 #outer 是一个分成几行的行内盒子，第一个行内盒子的顶部（边缘）和左侧边缘（下图用粗虚线显示）作为 top 和 left 偏移的参考 #outer { position: relative; color: red } #inner { position: absolute; top: 200px; left: -100px; height: 130px; width: 130px; color: blue; } 结果如图： 此图描述 如果不定位 #outer 盒子： #outer { color: red } #inner { position: absolute; top: 200px; left: -100px; height: 130px; width: 130px; color: blue; } #inner 的包含块变成了初始包含块。下图显示了最终位置： 此图描述 相对定位和绝对定位可能会用来实现变更标记符，如下面片段所示： I used two red hyphens to serve as a change bar. They will \"float\" to the left of the line containing THIS -- word. 产生如下结果： 此图描述 首先，段落正常排列。然后从包含块的左边缘偏移了 10px（在预期偏移的情况下保留了 10px 的右外边距）。两个作为变更标记符的连字符脱离了流，并定位在当前行（因为 top: auto），-1em 是距离其包含块（由 P 元素的最终位置创建）的左边缘的长度。结果是变更标记符好像 \"浮动\" 到了当前行的左侧。 9.9 分层显示（Layered presentation） 9.9.1 指定层叠级别：z-index 属性 关键信息摘要： 属性名称：z-index 值：auto | | inherit 初始值：auto 适用元素：定位元素 继承：no 百分比：N/A 适用媒体：all 计算值：和指定值一样 对于定位盒子，z-index 属性指定： 在当前层叠上下文中盒子的层叠级别 盒子是否创建层叠上下文 此属性的值具有以下含义： ：此整数是生成的盒子在当前层叠上下文中层叠级别。该盒子还会创建新的层叠上下文。 auto：生成的盒子在当前层叠上下文中层叠级别为 0。如果盒子的 position 属性为 fixed 或者是 根元素，则还会创建新的层叠上下文。 在这部分里，在...之前意味着当用户面向屏幕时更接近用户。 在 CSS 2.2 里，每个盒子都有三维位置。除了它们的水平位置和垂直位置之外，盒子沿着 Z 轴放置，并且一个在另一个上面进行格式化。当盒子视觉上重叠时，这与 Z 轴的位置尤其相关。本节讨论如何沿 Z 轴定位盒子。 根据层叠上下文来描述渲染树在画布上的绘制顺序。层叠上下文可以包含更多的层叠上下文。从其父级层叠上下文的角度来看，层叠上下文是原子的。在其它层叠上下文的盒子不可能出现在其它盒子之间。 每个盒子都属于一个层叠上下文。每个定位盒子在给定的层叠上下文里都有着整数的层叠级别，这是在 Z 轴上相对于同一层叠上下文中的其它层叠级别的位置。具有更高层叠级别的盒子总是在具有较低层叠级别的盒子前面格式化。盒子可能具有负层叠级别。在层叠上下文中具有相同层叠级别的盒子根据文档树上的顺序进行从后向前的堆放。 根元素形成根层叠上下文。其它层叠上下文由 具有除 auto 值以外的 z-index 属性的任何定位元素（包括相对定位的元素）生成。层叠上下文不一定与包含块有关。 在未来的 CSS 级别中，其它属性可能会创建层叠上下文，比如 opacity。 在每个层叠上下文中，以下层按从前到后的顺序进行绘制： 形成层叠上下文的元素的 background 和 border 具有负值的层叠级别（负数中绝对值最大的）的子层叠上下文 流内的（原：in-flow）、非行内级的（原：non-inline-level）、非定位（原：non-positioned ）的后代 非定位的浮动（原：non-positioned） 流内的（原：in-flow）、行内级的（原：inline-level）、非定位（原：non-positioned ）的后代，包括 行内表格（原：inline-table）和行内块（原：inline-block） 层叠级别为 0 的子层叠上下文和层叠级别为 0 的已定位后代 具有正值的层叠级别（正数中绝对值最小的第一个）的子层叠上下文 在每个层叠上下文中，层叠级别为 0 的定位元素（第 6 层），非定位的浮动（第 4 层），行内块（第 5 层）和行内表格（第 5 层），被绘制为就好像这些元素本身生成了新的层叠上下文，除了它们 定位的后代 和 任何可能的子层叠上下文参与当前的层叠上下文。 此绘制顺序以递归形式应用于每个层叠上下文中。层叠上下文绘制顺序的在 附录 E 中有详细描述。 下例中，每个 id 盒子的层叠级别分别为：\"text2\"=0、\"image\"=1、\"text3\"=2、和 \"text1\"=3。\"text2\" 的层叠级别是从根盒子继承下来的，其它由 z-index 属性指定。 Z-order positioning .pile { position: absolute; left: 2in; top: 2in; width: 3in; height: 3in; } This text will overlay the butterfly image. This text will be beneath everything. This text will underlay text1, but overlay the butterfly image 例子中说明了透明度的概念。背景的默认行为是允许它后面的盒子可见。本例中，每个盒子都透明覆盖在其下面的盒子上面，这种可以通过 background 取控制可见性。 9.10 文本方向：direction 属性和 unicode-bidi 属性 ⌛️... Copyright © chouchou 2019 all right reserved，powered by Gitbook当前页面修订时间： 2019-08-30 14:03:47 "}}